{
  "version": 3,
  "file": "/jobs/genie.orion/orion-client-stable/workspace/built-js/built-editor.min.js",
  "sources": [
    "requirejs/almond.js",
    "requirejs/i18n.js",
    "orion/editor/nls/messages.js",
    "orion/editor/nls/root/messages.js",
    "orion/editor/nls/messages!i18n",
    "orion/editor/eventTarget.js",
    "orion/regex.js",
    "orion/util.js",
    "orion/editor/textModel.js",
    "orion/keyBinding.js",
    "orion/editor/keyModes.js",
    "orion/editor/textTheme.js",
    "orion/editor/util.js",
    "orion/metrics.js",
    "orion/editor/textView.js",
    "orion/editor/projectionTextModel.js",
    "orion/Deferred.js",
    "orion/webui/littlelib.js",
    "orion/editor/tooltip.js",
    "orion/editor/annotations.js",
    "orion/objects.js",
    "orion/editor/editor.js",
    "orion/editor/find.js",
    "orion/editor/findUI.js",
    "orion/editor/actions.js",
    "orion/editor/undoStack.js",
    "orion/editor/rulers.js",
    "orion/editor/textDND.js",
    "orion/editor/linkedMode.js",
    "orion/editor/factories.js",
    "orion/editor/editorFeatures.js",
    "orion/editor/contentAssist.js",
    "orion/editor/textStyler.js",
    "orion/editor/edit.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrMA,ADsMA;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChNA,ADiNA;AEjNA,ADCA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA,AD0EA;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvMA,ADwMA;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA,ADqEA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9tPA,AD+tPA;AC9tPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrlBA,ADslBA;ACrlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpcA,ADqcA;ACpcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC93BA,AD+3BA;AC93BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACn9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA,ADwEA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtyCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjMA,ADkMA;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/uCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClhBA,ADmhBA;AClhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxJA,ADyJA;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnfA,ADofA;ACnfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7GA,AD8GA;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA,ADqBA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACh7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1pDA,AD2pDA;AC1pDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "/**\n * almond 0.2.4 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        return req;\n    };\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n\n",
    "/**\n * @license RequireJS i18n 2.0.4 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/i18n for details\n */\n/*jslint regexp: true */\n/*global require: false, navigator: false, define: false */\n\n/**\n * This plugin handles i18n! prefixed modules. It does the following:\n *\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\n * module does not want to specify what locale to load. So it just specifies\n * the top-level bundle, like \"i18n!nls/colors\".\n *\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\n * bundle since it does not have a locale in its name. It will then try to find\n * the best match locale available in that master bundle, then request all the\n * locale pieces for that best match locale. For instance, if the locale is \"en-us\",\n * then the plugin will ask for the \"en-us\", \"en\" and \"root\" bundles to be loaded\n * (but only if they are specified on the master bundle).\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/colors bundle to be that mixed in locale.\n *\n * 2) A regular module specifies a specific locale to load. For instance,\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\n * since maybe only fr or just root is defined for that locale. Once that best\n * fit is found, all of its locale pieces need to have their bundles loaded.\n *\n * Once all the bundles for the locale pieces load, then it mixes in all those\n * locale pieces into each other, then finally sets the context.defined value\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\n */\n(function () {\n    'use strict';\n\n    //regexp for reconstructing the master bundle name from parts of the regexp match\n    //nlsRegExp.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\n    //[\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\n    //nlsRegExp.exec(\"foo/bar/baz/nls/foo\") gives:\n    //[\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\n    //so, if match[5] is blank, it means this is the top bundle definition.\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/;\n\n    //Helper function to avoid repeating code. Lots of arguments in the\n    //desire to stay functional and support RequireJS contexts without having\n    //to know about the RequireJS contexts.\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\n        if (master[locale]) {\n            needed.push(locale);\n            if (master[locale] === true || master[locale] === 1) {\n                toLoad.push(prefix + locale + '/' + suffix);\n            }\n        }\n    }\n\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\n        var fullName = prefix + locale + '/' + suffix;\n        if (require._fileExists(req.toUrl(fullName + '.js'))) {\n            toLoad.push(fullName);\n        }\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     * This is not robust in IE for transferring methods that match\n     * Object.prototype names, but the uses of mixin here seem unlikely to\n     * trigger a problem related to that.\n     */\n    function mixin(target, source, force) {\n        var prop;\n        for (prop in source) {\n            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {\n                target[prop] = source[prop];\n            } else if (typeof source[prop] === 'object') {\n                if (!target[prop] && source[prop]) {\n                    target[prop] = {};\n                }\n                mixin(target[prop], source[prop], force);\n            }\n        }\n    }\n\n    define('i18n',['module'], function (module) {\n        var masterConfig = module.config ? module.config() : {};\n\n        return {\n            version: '2.0.4',\n            /**\n             * Called when a dependency needs to be loaded.\n             */\n            load: function (name, req, onLoad, config) {\n                config = config || {};\n\n                if (config.locale) {\n                    masterConfig.locale = config.locale;\n                }\n\n                var masterName,\n                    match = nlsRegExp.exec(name),\n                    prefix = match[1],\n                    locale = match[4],\n                    suffix = match[5],\n                    parts = locale.split(\"-\"),\n                    toLoad = [],\n                    value = {},\n                    i, part, current = \"\";\n\n                //If match[5] is blank, it means this is the top bundle definition,\n                //so it does not have to be handled. Locale-specific requests\n                //will have a match[4] value but no match[5]\n                if (match[5]) {\n                    //locale-specific bundle\n                    prefix = match[1];\n                    masterName = prefix + suffix;\n                } else {\n                    //Top-level bundle.\n                    masterName = name;\n                    suffix = match[4];\n                    locale = masterConfig.locale;\n                    if (!locale) {\n                        locale = masterConfig.locale =\n                            typeof navigator === \"undefined\" ? \"root\" :\n                            (navigator.language ||\n                             navigator.userLanguage || \"root\").toLowerCase();\n                    }\n                    parts = locale.split(\"-\");\n                }\n\n                if (config.isBuild) {\n                    //Check for existence of all locale possible files and\n                    //require them if exist.\n                    toLoad.push(masterName);\n                    addIfExists(req, \"root\", toLoad, prefix, suffix);\n                    for (i = 0; i < parts.length; i++) {\n                        part = parts[i];\n                        current += (current ? \"-\" : \"\") + part;\n                        addIfExists(req, current, toLoad, prefix, suffix);\n                    }\n                                        \n                    if(config.locales) {\n                    \tvar j, k; \n                    \tfor (j = 0; j < config.locales.length; j++) {\n                    \t\tlocale = config.locales[j];\n                    \t\tparts = locale.split(\"-\");\n                    \t\tcurrent = \"\";\n\t                    \tfor (k = 0; k < parts.length; k++) {\n\t\t                        part = parts[k];\n\t\t                        current += (current ? \"-\" : \"\") + part;\n\t\t                        addIfExists(req, current, toLoad, prefix, suffix);\n\t                    \t}\n                    \t}\n                    }\n\n                    req(toLoad, function () {\n                        onLoad();\n                    });\n                } else {\n                    //First, fetch the master bundle, it knows what locales are available.\n                    req([masterName], function (master) {\n                        //Figure out the best fit\n                        var needed = [],\n                            part;\n\n                        //Always allow for root, then do the rest of the locale parts.\n                        addPart(\"root\", master, needed, toLoad, prefix, suffix);\n                        for (i = 0; i < parts.length; i++) {\n                            part = parts[i];\n                            current += (current ? \"-\" : \"\") + part;\n                            addPart(current, master, needed, toLoad, prefix, suffix);\n                        }\n\n                        //Load all the parts missing.\n                        req(toLoad, function () {\n                            var i, partBundle, part;\n                            for (i = needed.length - 1; i > -1 && needed[i]; i--) {\n                                part = needed[i];\n                                partBundle = master[part];\n                                if (partBundle === true || partBundle === 1) {\n                                    partBundle = req(prefix + part + '/' + suffix);\n                                }\n                                mixin(value, partBundle);\n                            }\n\n                            //All done, notify the loader.\n                            onLoad(value);\n                        });\n                    });\n                }\n            }\n        };\n    });\n}());\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n/*eslint-env browser, amd*/\ndefine('orion/editor/nls/messages',{\n\troot:true\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n/*eslint-env browser, amd*/\ndefine('orion/editor/nls/root/messages',{//Default message bundle\n\t\"multipleAnnotations\": \"Multiple annotations:\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"line\": \"Line: ${0}\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"breakpoint\": \"Breakpoint\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"bookmark\": \"Bookmark\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"task\": \"Task\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"error\": \"Error\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"warning\": \"Warning\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"currentSearch\": \"Current Search\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"currentLine\": \"Current Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"matchingBracket\": \"Matching Bracket\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"currentBracket\": \"Current Bracket\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"diffAdded\": \"Diff Added Lines\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"diffDeleted\": \"Diff Deleted Lines\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"diffModified\": \"Diff Modified Lines\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t\"lineUp\": \"Line Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"lineDown\": \"Line Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"lineStart\": \"Line Start\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"lineEnd\": \"Line End\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"charPrevious\": \"Previous Character\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"charNext\": \"Next Character\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"pageUp\": \"Page Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"pageDown\": \"Page Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"scrollPageUp\": \"Scroll Page Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"scrollPageDown\": \"Scroll Page Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"scrollLineUp\": \"Scroll Line Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"scrollLineDown\": \"Scroll Line Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"wordPrevious\": \"Previous Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"wordNext\": \"Next Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"textStart\": \"Document Start\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"textEnd\": \"Document End\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"scrollTextStart\": \"Scroll Document Start\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"scrollTextEnd\": \"Scroll Document End\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"centerLine\": \"Center Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t\"selectLineUp\": \"Select Line Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectLineDown\": \"Select Line Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectWholeLineUp\": \" Select Whole Line Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectWholeLineDown\": \"Select Whole Line Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectLineStart\": \"Select Line Start\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectLineEnd\": \"Select Line End\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectCharPrevious\": \"Select Previous Character\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectCharNext\": \"Select Next Character\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectPageUp\": \"Select Page Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectPageDown\": \"Select Page Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectWordPrevious\": \"Select Previous Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectWordNext\": \"Select Next Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectTextStart\": \"Select Document Start\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectTextEnd\": \"Select Document End\", //$NON-NLS-1$ //$NON-NLS-0$\n\n\t\"deletePrevious\": \"Delete Previous Character\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"deleteNext\": \"Delete Next Character\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"deleteWordPrevious\": \"Delete Previous Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"deleteWordNext\": \"Delete Next Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"deleteLineStart\": \"Delete Line Start\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"deleteLineEnd\": \"Delete Line End\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"tab\": \"Insert Tab\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"enter\": \"Insert Line Delimiter\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"enterNoCursor\": \"Insert Line Delimiter\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"escape\": \"Escape\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"selectAll\": \"Select All\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"copy\": \"Copy\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"cut\": \"Cut\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"paste\": \"Paste\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t\"uppercase\": \"To Upper Case\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"lowercase\": \"To Lower Case\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"capitalize\": \"Capitalize\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"reversecase\" : \"Reverse Case\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t\"toggleWrapMode\": \"Toggle Wrap Mode\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"toggleTabMode\": \"Toggle Tab Mode\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"toggleOverwriteMode\": \"Toggle Overwrite Mode\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t\"committerOnTime\": \"${0} on ${1}\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t//Emacs\n\t\"emacs\": \"Emacs\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"exchangeMarkPoint\": \"Exchange Mark and Point\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"setMarkCommand\": \"Set Mark\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"clearMark\": \"Clear Mark\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"digitArgument\": \"Digit Argument ${0}\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"negativeArgument\": \"Negative Argument\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\n\t\"Comment\": \"Comment\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"Flat outline\": \"Flat outline\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"incrementalFindStr\": \"Incremental find: ${0}\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"incrementalFindStrNotFound\": \"Incremental find: ${0} (not found)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"incrementalFindReverseStr\": \"Reverse Incremental find: ${0}\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"incrementalFindReverseStrNotFound\": \"Reverse Incremental find: ${0} (not found)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"find\": \"Find...\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"undo\": \"Undo\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"redo\": \"Redo\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"cancelMode\": \"Cancel Current Mode\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"findNext\": \"Find Next Occurrence\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"findPrevious\": \"Find Previous Occurrence\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"incrementalFind\": \"Incremental Find\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"incrementalFindReverse\": \"Incremental Find Reverse\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"indentLines\": \"Indent Lines\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"unindentLines\": \"Unindent Lines\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"moveLinesUp\": \"Move Lines Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"moveLinesDown\": \"Move Lines Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"copyLinesUp\": \"Copy Lines Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"copyLinesDown\": \"Copy Lines Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"deleteLines\": \"Delete Lines\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"gotoLine\": \"Goto Line...\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"gotoLinePrompty\": \"Goto Line:\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"nextAnnotation\": \"Next Annotation\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"prevAnnotation\": \"Previous Annotation\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"expand\": \"Expand\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"collapse\": \"Collapse\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"expandAll\": \"Expand All\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"collapseAll\": \"Collapse All\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"lastEdit\": \"Last Edit Location\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"trimTrailingWhitespaces\": \"Trim Trailing Whitespaces\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"toggleLineComment\": \"Toggle Line Comment\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"addBlockComment\": \"Add Block Comment\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"removeBlockComment\": \"Remove Block Comment\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"linkedModeEntered\": \"Linked Mode: Enter or ESC to exit\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"linkedModeExited\": \"Linked Mode exited\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"syntaxError\": \"Syntax Error\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"contentAssist\": \"Content Assist\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"lineColumn\": \"Line ${0} : Column ${1}\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"multiSelections\": \"${0} selection regions\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t//vi\n\t\"vi\": \"vi\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vimove\": \"(Move)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viyank\": \"(Yank)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"videlete\": \"(Delete)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vichange\": \"(Change)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viLeft\": \"${0} Left\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viRight\": \"${0} Right\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viUp\": \"${0} Up\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viDown\": \"${0} Down\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viw\": \"${0} Next Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vib\": \"${0} Beginning of Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viW\": \"${0} Next Word (ws stop)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viB\": \"${0} Beginning of Word (ws stop)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vie\": \"${0} End of Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viE\": \"${0} End of Word (ws stop)\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi$\": \"${0} End of the line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi^_\": \"${0} First non-blank Char Current Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi+\": \"${0} First Char Next Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi-\": \"${0} First Char Previous Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi|\": \"${0} nth Column in Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viH\": \"${0} Top of Page\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viM\": \"${0} Middle of Page\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viL\": \"${0} Bottom of Page\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi/\": \"${0} Search Forward\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi?\": \"${0} Search Backward\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vin\": \"${0} Next Search\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viN\": \"${0} Previous Search\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vif\": \"${0} Search Char Fwd\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viF\": \"${0} Search Char Bckwd\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vit\": \"${0} Search Before Char Fwd\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viT\": \"${0} Search Before Char Bckwd\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi,\": \"${0} Repeat Reverse Char Search\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vi;\": \"${0} Repeat Char Search\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viG\": \"${0} Go to Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viycd\": \"${0} Current Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"via\": \"Append After Cursor\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viA\": \"Append to End of Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vii\": \"Insert Before Cursor\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viI\": \"Insert at Beginning of Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viO\": \"Insert Line Above\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vio\": \"Insert Line Below\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viR\": \"Begin Overwriting Text\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vis\": \"Substitute a Character\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viS\": \"Substitute Entire Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viC\": \"Change Text Until Line End\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"vip\": \"Paste After Char or Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viP\": \"Paste Before Char or Line\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"viStar\": \"Search Word Under Cursor\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t\"next\": \"Next\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"previous\": \"Previous\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"replace\": \"Replace\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"replaceAll\": \"Replace All\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"findWith\": \"Find With\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"replaceWith\": \"Replace With\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"caseInsensitive\": \"Aa\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"regex\": \"/.*/\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"wholeWord\": \"\\\\b\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"caseInsensitiveTooltip\": \"Toggle Case Insensitive\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"regexTooltip\": \"Toggle Regex\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"wholeWordTooltip\": \"Toggle Whole Word\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"closeTooltip\": \"Close\", //$NON-NLS-1$ //$NON-NLS-0$\n\n\t\"replacingAll\": \"Replacing all...\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"replacedMatches\": \"Replaced ${0} matches\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"nothingReplaced\": \"Nothing replaced\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\"notFound\": \"Not found\" //$NON-NLS-1$ //$NON-NLS-0$\n});\n\n",
    "\n",
    "/*******************************************************************************\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n \n/*eslint-env browser, amd*/\ndefine(\"orion/editor/eventTarget\", [], function() { //$NON-NLS-0$\n\t/** \n\t * Constructs a new EventTarget object.\n\t * \n\t * @class \n\t * @name orion.editor.EventTarget\n\t */\n\tfunction EventTarget() {\n\t}\n\t/**\n\t * Adds in the event target interface into the specified object.\n\t *\n\t * @param {Object} object The object to add in the event target interface.\n\t */\n\tEventTarget.addMixin = function(object) {\n\t\tvar proto = EventTarget.prototype;\n\t\tfor (var p in proto) {\n\t\t\tif (proto.hasOwnProperty(p)) {\n\t\t\t\tobject[p] = proto[p];\n\t\t\t}\n\t\t}\n\t};\n\tEventTarget.prototype = /** @lends orion.editor.EventTarget.prototype */ {\n\t\t/**\n\t\t * Adds an event listener to this event target.\n\t\t * \n\t\t * @param {String} type The event type.\n\t\t * @param {Function|EventListener} listener The function or the EventListener that will be executed when the event happens. \n\t\t * @param {Boolean} [useCapture=false] <code>true</code> if the listener should be trigged in the capture phase.\n\t\t * \n\t\t * @see orion.editor.EventTarget#removeEventListener\n\t\t */\n\t\taddEventListener: function(type, listener, useCapture) {\n\t\t\tif (!this._eventTypes) { this._eventTypes = {}; }\n\t\t\tvar state = this._eventTypes[type];\n\t\t\tif (!state) {\n\t\t\t\tstate = this._eventTypes[type] = {level: 0, listeners: []};\n\t\t\t}\n\t\t\tvar listeners = state.listeners;\n\t\t\tlisteners.push({listener: listener, useCapture: useCapture});\n\t\t},\n\t\t/**\n\t\t * Dispatches the given event to the listeners added to this event target.\n\t\t * @param {Event} evt The event to dispatch.\n\t\t */\n\t\tdispatchEvent: function(evt) {\n\t\t\tvar type = evt.type;\n\t\t\tthis._dispatchEvent(\"pre\" + type, evt); //$NON-NLS-0$\n\t\t\tthis._dispatchEvent(type, evt);\n\t\t\tthis._dispatchEvent(\"post\" + type, evt); //$NON-NLS-0$\n\t\t},\n\t\t_dispatchEvent: function(type, evt) {\n\t\t\tvar state = this._eventTypes ? this._eventTypes[type] : null;\n\t\t\tif (state) {\n\t\t\t\tvar listeners = state.listeners;\n\t\t\t\ttry {\n\t\t\t\t\tstate.level++;\n\t\t\t\t\tif (listeners) {\n\t\t\t\t\t\tfor (var i=0, len=listeners.length; i < len; i++) {\n\t\t\t\t\t\t\tif (listeners[i]) {\n\t\t\t\t\t\t\t\tvar l = listeners[i].listener;\n\t\t\t\t\t\t\t\tif (typeof l === \"function\") { //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\tl.call(this, evt);\n\t\t\t\t\t\t\t\t} else if (l.handleEvent && typeof l.handleEvent === \"function\") { //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\tl.handleEvent(evt);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tstate.level--;\n\t\t\t\t\tif (state.compact && state.level === 0) {\n\t\t\t\t\t\tfor (var j=listeners.length - 1; j >= 0; j--) {\n\t\t\t\t\t\t\tif (!listeners[j]) {\n\t\t\t\t\t\t\t\tlisteners.splice(j, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (listeners.length === 0) {\n\t\t\t\t\t\t\tdelete this._eventTypes[type];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.compact = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns whether there is a listener for the specified event type.\n\t\t * \n\t\t * @param {String} type The event type\n\t\t * \n\t\t * @see orion.editor.EventTarget#addEventListener\n\t\t * @see orion.editor.EventTarget#removeEventListener\n\t\t */\n\t\tisListening: function(type) {\n\t\t\tif (!this._eventTypes) { return false; }\n\t\t\treturn this._eventTypes[type] !== undefined;\n\t\t},\t\t\n\t\t/**\n\t\t * Removes an event listener from the event target.\n\t\t * <p>\n\t\t * All the parameters must be the same ones used to add the listener.\n\t\t * </p>\n\t\t * \n\t\t * @param {String} type The event type\n\t\t * @param {Function|EventListener} listener The function or the EventListener that will be executed when the event happens. \n\t\t * @param {Boolean} [useCapture=false] <code>true</code> if the listener should be trigged in the capture phase.\n\t\t * \n\t\t * @see orion.editor.EventTarget#addEventListener\n\t\t */\n\t\tremoveEventListener: function(type, listener, useCapture){\n\t\t\tif (!this._eventTypes) { return; }\n\t\t\tvar state = this._eventTypes[type];\n\t\t\tif (state) {\n\t\t\t\tvar listeners = state.listeners;\n\t\t\t\tfor (var i=0, len=listeners.length; i < len; i++) {\n\t\t\t\t\tvar l = listeners[i];\n\t\t\t\t\tif (l && l.listener === listener && l.useCapture === useCapture) {\n\t\t\t\t\t\tif (state.level !== 0) {\n\t\t\t\t\t\t\tlisteners[i] = null;\n\t\t\t\t\t\t\tstate.compact = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (listeners.length === 0) {\n\t\t\t\t\tdelete this._eventTypes[type];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\treturn {EventTarget: EventTarget};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2011, 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n/*eslint-env browser, amd*/\n/**\n * @name orion.regex\n * @class Utilities for dealing with regular expressions.\n * @description Utilities for dealing with regular expressions.\n */\ndefine(\"orion/regex\", [], function() { //$NON-NLS-0$\n\t/**\n\t * @memberOf orion.regex\n\t * @function\n\t * @static\n\t * @description Escapes regex special characters in the input string.\n\t * @param {String} str The string to escape.\n\t * @returns {String} A copy of <code>str</code> with regex special characters escaped.\n\t */\n\tfunction escape(str) {\n\t\treturn str.replace(/([\\\\$\\^*\\/+?\\.\\(\\)|{}\\[\\]])/g, \"\\\\$&\"); //$NON-NLS-0$\n\t}\n\n\t/**\n\t * @memberOf orion.regex\n\t * @function\n\t * @static\n\t * @description Parses a pattern and flags out of a regex literal string.\n\t * @param {String} str The string to parse. Should look something like <code>\"/ab+c/\"</code> or <code>\"/ab+c/i\"</code>.\n\t * @returns {Object} If <code>str</code> looks like a regex literal, returns an object with properties\n\t * <code><dl>\n\t * <dt>pattern</dt><dd>{String}</dd>\n\t * <dt>flags</dt><dd>{String}</dd>\n\t * </dl></code> otherwise returns <code>null</code>.\n\t */\n\tfunction parse(str) {\n\t\tvar regexp = /^\\s*\\/(.+)\\/([gim]{0,3})\\s*$/.exec(str);\n\t\tif (regexp) {\n\t\t\treturn {\n\t\t\t\tpattern : regexp[1],\n\t\t\t\tflags : regexp[2]\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tescape: escape,\n\t\tparse: parse\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors: IBM Corporation - initial API and implementation\n *******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine('orion/util',[],function() {\n\n\tvar userAgent = navigator.userAgent;\n\tvar isIE = (userAgent.indexOf(\"MSIE\") !== -1 || userAgent.indexOf(\"Trident\") !== -1) ? document.documentMode : undefined; //$NON-NLS-1$ //$NON-NLS-0$\n\tvar isFirefox = parseFloat(userAgent.split(\"Firefox/\")[1] || userAgent.split(\"Minefield/\")[1]) || undefined; //$NON-NLS-1$ //$NON-NLS-0$\n\tvar isOpera = userAgent.indexOf(\"Opera\") !== -1 ? parseFloat(userAgent.split(\"Version/\")[1]) : undefined; //$NON-NLS-0$\n\tvar isChrome = parseFloat(userAgent.split(\"Chrome/\")[1]) || undefined; //$NON-NLS-0$\n\tvar isSafari = userAgent.indexOf(\"Safari\") !== -1 && !isChrome; //$NON-NLS-0$\n\tvar isWebkit = parseFloat(userAgent.split(\"WebKit/\")[1]) || undefined; //$NON-NLS-0$\n\tvar isAndroid = userAgent.indexOf(\"Android\") !== -1; //$NON-NLS-0$\n\tvar isIPad = userAgent.indexOf(\"iPad\") !== -1; //$NON-NLS-0$\n\tvar isIPhone = userAgent.indexOf(\"iPhone\") !== -1; //$NON-NLS-0$\n\tvar isIOS = isIPad || isIPhone;\n\tvar isMac = navigator.platform.indexOf(\"Mac\") !== -1; //$NON-NLS-0$\n\tvar isWindows = navigator.platform.indexOf(\"Win\") !== -1; //$NON-NLS-0$\n\tvar isLinux = navigator.platform.indexOf(\"Linux\") !== -1; //$NON-NLS-0$\n\tvar isTouch = typeof document !== \"undefined\" && \"ontouchstart\" in document.createElement(\"input\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\tvar platformDelimiter = isWindows ? \"\\r\\n\" : \"\\n\"; //$NON-NLS-1$ //$NON-NLS-0$\n\n\tfunction formatMessage(msg) {\n\t\tvar args = arguments;\n\t\treturn msg.replace(/\\$\\{([^\\}]+)\\}/g, function(str, index) { return args[(index << 0) + 1]; });\n\t}\n\t\n\tvar XHTML = \"http://www.w3.org/1999/xhtml\"; //$NON-NLS-0$\n\tfunction createElement(document, tagName) {\n\t\tif (document.createElementNS) {\n\t\t\treturn document.createElementNS(XHTML, tagName);\n\t\t}\n\t\treturn document.createElement(tagName);\n\t}\n\n\treturn {\n\t\tformatMessage: formatMessage,\n\t\t\n\t\tcreateElement: createElement,\n\t\t\n\t\t/** Browsers */\n\t\tisIE: isIE,\n\t\tisFirefox: isFirefox,\n\t\tisOpera: isOpera,\n\t\tisChrome: isChrome,\n\t\tisSafari: isSafari,\n\t\tisWebkit: isWebkit,\n\t\tisAndroid: isAndroid,\n\t\tisIPad: isIPad,\n\t\tisIPhone: isIPhone,\n\t\tisIOS: isIOS,\n\t\t\n\t\t/** OSs */\n\t\tisMac: isMac,\n\t\tisWindows: isWindows,\n\t\tisLinux: isLinux,\n\n\t\t/** Capabilities */\n\t\tisTouch: isTouch,\n\n\t\tplatformDelimiter: platformDelimiter\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n \n/*eslint-env browser, amd*/\ndefine(\"orion/editor/textModel\", ['orion/editor/eventTarget', 'orion/regex', 'orion/util'], function(mEventTarget, mRegex, util) { //$NON-NLS-2$  //$NON-NLS-1$ //$NON-NLS-0$\n\n\t/**\n\t * Constructs a new TextModel with the given text and default line delimiter.\n\t *\n\t * @param {String} [text=\"\"] the text that the model will store\n\t * @param {String} [lineDelimiter=platform delimiter] the line delimiter used when inserting new lines to the model.\n\t *\n\t * @name orion.editor.TextModel\n\t * @class The TextModel is an interface that provides text for the view. Applications may\n\t * implement the TextModel interface to provide a custom store for the view content. The\n\t * view interacts with its text model in order to access and update the text that is being\n\t * displayed and edited in the view. This is the default implementation.\n\t * <p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.TextView}<br/>\n\t * {@link orion.editor.TextView#setModel}\n\t * </p>\n\t * @borrows orion.editor.EventTarget#addEventListener as #addEventListener\n\t * @borrows orion.editor.EventTarget#removeEventListener as #removeEventListener\n\t * @borrows orion.editor.EventTarget#dispatchEvent as #dispatchEvent\n\t */\n\tfunction TextModel(text, lineDelimiter) {\n\t\tthis._lastLineIndex = -1;\n\t\tthis._text = [\"\"];\n\t\tthis._lineOffsets = [0];\n\t\tthis.setText(text);\n\t\tthis.setLineDelimiter(lineDelimiter);\n\t}\n\n\tTextModel.prototype = /** @lends orion.editor.TextModel.prototype */ {\n\t\t/**\n\t\t * Destroys this text model.\n\t\t */\n\t\tdestroy: function() {\n\t\t},\n\t\t/**\n\t\t * @class This object describes the options to use while finding occurrences of a string in a text model.\n\t\t * @name orion.editor.FindOptions\n\t\t *\n\t\t * @property {String} string the search string to be found.\n\t\t * @property {Boolean} [regex=false] whether or not the search string is a regular expression.\n\t\t * @property {Boolean} [wrap=false] whether or not to wrap search.\n\t\t * @property {Boolean} [wholeWord=false] whether or not to search only whole words.\n\t\t * @property {Boolean} [caseInsensitive=false] whether or not search is case insensitive.\n\t\t * @property {Boolean} [reverse=false] whether or not to search backwards.\n\t\t * @property {Number} [start=0] The start offset to start searching\n\t\t * @property {Number} [end=charCount] The end offset of the search. Used to search in a given range.\n\t\t */\n\t\t/**\n\t\t * @class This object represents a find occurrences iterator.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextModel#find}<br/>\n\t\t * </p>\t\t \n\t\t * @name orion.editor.FindIterator\n\t\t * \n\t\t * @property {Function} hasNext Determines whether there are more occurrences in the iterator.\n\t\t * @property {Function} next Returns the next matched range {start,end} in the iterator.\n\t\t */\t\n\t\t/**\n\t\t * Finds occurrences of a string in the text model.\n\t\t *\n\t\t * @param {orion.editor.FindOptions} options the search options\n\t\t * @return {orion.editor.FindIterator} the find occurrences iterator.\n\t\t */\n\t\tfind: function(options) {\n\t\t\tif (this._text.length > 1) {\n\t\t\t\tthis._text = [this._text.join(\"\")];\n\t\t\t}\n\t\t\tvar string = options.string;\n\t\t\tvar regex = options.regex;\n\t\t\tvar pattern = string;\n\t\t\tvar flags = \"\";\n\t\t\tvar caseInsensitive = options.caseInsensitive;\n\t\t\tif (pattern) {\n\t\t\t\tif (regex) {\n\t\t\t\t\tvar parsed = mRegex.parse(pattern);\n\t\t\t\t\tif (parsed) {\n\t\t\t\t\t\tpattern = parsed.pattern;\n\t\t\t\t\t\tflags = parsed.flags;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpattern = string.replace(/([\\\\$\\^*\\/+?\\.\\(\\)|{}\\[\\]])/g, \"\\\\$&\"); //$NON-NLS-0$\n\t\t\t\t\t/*\n\t\t\t\t\t* Bug in JS RegEx. In a Turkish locale, dotless i (u0131) capitalizes to I (u0049) and i (u0069) \n\t\t\t\t\t* capitalizes to dot I (u0130). The JS RegEx does not match correctly the Turkish i's in case\n\t\t\t\t\t* insensitive mode. The fix is to detect the presence of Turkish i's in the search pattern and \n\t\t\t\t\t* to modify the pattern to search for both upper and lower case.\n\t\t\t\t\t*/\n\t\t\t\t\tif (caseInsensitive) {  //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\tpattern = pattern.replace(/[iI\\u0130\\u0131]/g, \"[Ii\\u0130\\u0131]\"); //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar current = null, skip;\n\t\t\tif (pattern) {\n\t\t\t\tvar reverse = options.reverse;\n\t\t\t\tvar wrap = options.wrap;\n\t\t\t\tvar wholeWord = options.wholeWord;\n\t\t\t\tvar start = options.start || 0;\n\t\t\t\tvar end = options.end;\n\t\t\t\tvar isRange = (end !== null && end !== undefined);\n\t\t\t\tif (flags.indexOf(\"g\") === -1) { flags += \"g\"; } //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tif (flags.indexOf(\"m\") === -1) { flags += \"m\"; } //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tif (caseInsensitive) {\n\t\t\t\t\tif (flags.indexOf(\"i\") === -1) { flags += \"i\"; } //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (wholeWord) {\n\t\t\t\t\tpattern = \"\\\\b\" + pattern + \"\\\\b\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tvar text = this._text[0], result, lastIndex, offset = 0;\n\t\t\t\tif (isRange) {\n\t\t\t\t\tvar s = start < end ? start : end;\n\t\t\t\t\tvar e = start < end ? end : start;\n\t\t\t\t\ttext = text.substring(s, e);\n\t\t\t\t\toffset = s;\n\t\t\t\t}\n\t\t\t\tvar re = new RegExp(pattern, flags);\n\t\t\t\tif (reverse) {\n\t\t\t\t\tskip = function() {\n\t\t\t\t\t\tvar match = null;\n\t\t\t\t\t\tre.lastIndex = 0;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlastIndex = re.lastIndex;\n\t\t\t\t\t\t\tresult = re.exec(text);\n\t\t\t\t\t\t\tif (lastIndex === re.lastIndex) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\tif (result.index + offset < start) {\n\t\t\t\t\t\t\t\t\tmatch = {start: result.index + offset, end: re.lastIndex + offset};\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (!wrap || match) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstart = text.length + offset;\n\t\t\t\t\t\t\t\t\tmatch = {start: result.index + offset, end: re.lastIndex + offset};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (match) { start = match.start; }\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tif (!isRange) {\n\t\t\t\t\t\tre.lastIndex = start;\n\t\t\t\t\t}\n\t\t\t\t\tskip = function() {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlastIndex = re.lastIndex;\n\t\t\t\t\t\t\tresult = re.exec(text);\n\t\t\t\t\t\t\tif (lastIndex === re.lastIndex) {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\treturn {start: result.index + offset, end: re.lastIndex + offset};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (lastIndex !== 0) {\n\t\t\t\t\t\t\t\tif (wrap) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcurrent = skip();\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tnext: function() {\n\t\t\t\t\tvar result = current;\n\t\t\t\t\tif (result) { current = skip(); }\n\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn current !== null;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * Returns the number of characters in the model.\n\t\t *\n\t\t * @returns {Number} the number of characters in the model.\n\t\t */\n\t\tgetCharCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0; i<this._text.length; i++) {\n\t\t\t\tcount += this._text[i].length;\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\t\t/**\n\t\t * Returns the text of the line at the given index.\n\t\t * <p>\n\t\t * The valid indices are 0 to line count exclusive.  Returns <code>null</code> \n\t\t * if the index is out of range. \n\t\t * </p>\n\t\t *\n\t\t * @param {Number} lineIndex the zero based index of the line.\n\t\t * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. \n\t\t * @returns {String} the line text or <code>null</code> if out of range.\n\t\t *\n\t\t * @see orion.editor.TextModel#getLineAtOffset\n\t\t */\n\t\tgetLine: function(lineIndex, includeDelimiter) {\n\t\t\tvar lineCount = this.getLineCount();\n\t\t\tif (!(0 <= lineIndex && lineIndex < lineCount)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar start = this._lineOffsets[lineIndex];\n\t\t\tif (lineIndex + 1 < lineCount) {\n\t\t\t\tvar text = this.getText(start, this._lineOffsets[lineIndex + 1]);\n\t\t\t\tif (includeDelimiter) {\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\t\t\t\tvar end = text.length, c;\n\t\t\t\twhile (((c = text.charCodeAt(end - 1)) === 10) || (c === 13)) {\n\t\t\t\t\tend--;\n\t\t\t\t}\n\t\t\t\treturn text.substring(0, end);\n\t\t\t} else {\n\t\t\t\treturn this.getText(start); \n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns the line index at the given character offset.\n\t\t * <p>\n\t\t * The valid offsets are 0 to char count inclusive. The line index for\n\t\t * char count is <code>line count - 1</code>. Returns <code>-1</code> if\n\t\t * the offset is out of range.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} offset a character offset.\n\t\t * @returns {Number} the zero based line index or <code>-1</code> if out of range.\n\t\t */\n\t\tgetLineAtOffset: function(offset) {\n\t\t\tvar charCount = this.getCharCount();\n\t\t\tif (!(0 <= offset && offset <= charCount)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tvar lineCount = this.getLineCount();\n\t\t\tif (offset === charCount) {\n\t\t\t\treturn lineCount - 1; \n\t\t\t}\n\t\t\tvar lineStart, lineEnd;\n\t\t\tvar index = this._lastLineIndex;\n\t\t\tif (0 <= index && index < lineCount) {\n\t\t\t\tlineStart = this._lineOffsets[index];\n\t\t\t\tlineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;\n\t\t\t\tif (lineStart <= offset && offset < lineEnd) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar high = lineCount;\n\t\t\tvar low = -1;\n\t\t\twhile (high - low > 1) {\n\t\t\t\tindex = Math.floor((high + low) / 2);\n\t\t\t\tlineStart = this._lineOffsets[index];\n\t\t\t\tlineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;\n\t\t\t\tif (offset <= lineStart) {\n\t\t\t\t\thigh = index;\n\t\t\t\t} else if (offset < lineEnd) {\n\t\t\t\t\thigh = index;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlow = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._lastLineIndex = high;\n\t\t\treturn high;\n\t\t},\n\t\t/**\n\t\t * Returns the number of lines in the model.\n\t\t * <p>\n\t\t * The model always has at least one line.\n\t\t * </p>\n\t\t *\n\t\t * @returns {Number} the number of lines.\n\t\t */\n\t\tgetLineCount: function() {\n\t\t\treturn this._lineOffsets.length;\n\t\t},\n\t\t/**\n\t\t * Returns the line delimiter that is used by the view\n\t\t * when inserting new lines. New lines entered using key strokes \n\t\t * and paste operations use this line delimiter.\n\t\t *\n\t\t * @return {String} the line delimiter that is used by the view when inserting new lines.\n\t\t */\n\t\tgetLineDelimiter: function() {\n\t\t\treturn this._lineDelimiter;\n\t\t},\n\t\t/**\n\t\t * Returns the end character offset for the given line. \n\t\t * <p>\n\t\t * The end offset is not inclusive. This means that when the line delimiter is included, the \n\t\t * offset is either the start offset of the next line or char count. When the line delimiter is\n\t\t * not included, the offset is the offset of the line delimiter.\n\t\t * </p>\n\t\t * <p>\n\t\t * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> \n\t\t * if the index is out of range. \n\t\t * </p>\n\t\t *\n\t\t * @param {Number} lineIndex the zero based index of the line.\n\t\t * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. \n\t\t * @return {Number} the line end offset or <code>-1</code> if out of range.\n\t\t *\n\t\t * @see orion.editor.TextModel#getLineStart\n\t\t */\n\t\tgetLineEnd: function(lineIndex, includeDelimiter) {\n\t\t\tvar lineCount = this.getLineCount();\n\t\t\tif (!(0 <= lineIndex && lineIndex < lineCount)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (lineIndex + 1 < lineCount) {\n\t\t\t\tvar end = this._lineOffsets[lineIndex + 1];\n\t\t\t\tif (includeDelimiter) {\n\t\t\t\t\treturn end;\n\t\t\t\t}\n\t\t\t\tvar text = this.getText(Math.max(this._lineOffsets[lineIndex], end - 2), end);\n\t\t\t\tvar i = text.length, c;\n\t\t\t\twhile (((c = text.charCodeAt(i - 1)) === 10) || (c === 13)) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\treturn end - (text.length - i);\n\t\t\t} else {\n\t\t\t\treturn this.getCharCount();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns the start character offset for the given line.\n\t\t * <p>\n\t\t * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> \n\t\t * if the index is out of range. \n\t\t * </p>\n\t\t *\n\t\t * @param {Number} lineIndex the zero based index of the line.\n\t\t * @return {Number} the line start offset or <code>-1</code> if out of range.\n\t\t *\n\t\t * @see orion.editor.TextModel#getLineEnd\n\t\t */\n\t\tgetLineStart: function(lineIndex) {\n\t\t\tif (!(0 <= lineIndex && lineIndex < this.getLineCount())) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn this._lineOffsets[lineIndex];\n\t\t},\n\t\t/**\n\t\t * Returns the text for the given range.\n\t\t * <p>\n\t\t * The end offset is not inclusive. This means that character at the end offset\n\t\t * is not included in the returned text.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} [start=0] the zero based start offset of text range.\n\t\t * @param {Number} [end=char count] the zero based end offset of text range.\n\t\t *\n\t\t * @see orion.editor.TextModel#setText\n\t\t */\n\t\tgetText: function(start, end) {\n\t\t\tif (start === undefined) { start = 0; }\n\t\t\tif (end === undefined) { end = this.getCharCount(); }\n\t\t\tif (start === end) { return \"\"; }\n\t\t\tvar offset = 0, chunk = 0, length;\n\t\t\twhile (chunk<this._text.length) {\n\t\t\t\tlength = this._text[chunk].length; \n\t\t\t\tif (start <= offset + length) { break; }\n\t\t\t\toffset += length;\n\t\t\t\tchunk++;\n\t\t\t}\n\t\t\tvar firstOffset = offset;\n\t\t\tvar firstChunk = chunk;\n\t\t\twhile (chunk<this._text.length) {\n\t\t\t\tlength = this._text[chunk].length; \n\t\t\t\tif (end <= offset + length) { break; }\n\t\t\t\toffset += length;\n\t\t\t\tchunk++;\n\t\t\t}\n\t\t\tvar lastOffset = offset;\n\t\t\tvar lastChunk = chunk;\n\t\t\tif (firstChunk === lastChunk) {\n\t\t\t\treturn this._text[firstChunk].substring(start - firstOffset, end - lastOffset);\n\t\t\t}\n\t\t\tvar beforeText = this._text[firstChunk].substring(start - firstOffset);\n\t\t\tvar afterText = this._text[lastChunk].substring(0, end - lastOffset);\n\t\t\treturn beforeText + this._text.slice(firstChunk+1, lastChunk).join(\"\") + afterText; \n\t\t},\n\t\t/**\n\t\t * Notifies all listeners that the text is about to change.\n\t\t * <p>\n\t\t * This notification is intended to be used only by the view. Application clients should\n\t\t * use {@link orion.editor.TextView#event:onModelChanging}.\n\t\t * </p>\n\t\t * <p>\n\t\t * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel\n\t\t * as part of the implementation of {@link #setText}. This method is included in the public API for documentation\n\t\t * purposes and to allow integration with other toolkit frameworks.\n\t\t * </p>\n\t\t *\n\t\t * @param {orion.editor.ModelChangingEvent} modelChangingEvent the changing event\n\t\t */\n\t\tonChanging: function(modelChangingEvent) {\n\t\t\treturn this.dispatchEvent(modelChangingEvent);\n\t\t},\n\t\t/**\n\t\t * Notifies all listeners that the text has changed.\n\t\t * <p>\n\t\t * This notification is intended to be used only by the view. Application clients should\n\t\t * use {@link orion.editor.TextView#event:onModelChanged}.\n\t\t * </p>\n\t\t * <p>\n\t\t * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel\n\t\t * as part of the implementation of {@link #setText}. This method is included in the public API for documentation\n\t\t * purposes and to allow integration with other toolkit frameworks.\n\t\t * </p>\n\t\t *\n\t\t * @param {orion.editor.ModelChangedEvent} modelChangedEvent the changed event\n\t\t */\n\t\tonChanged: function(modelChangedEvent) {\n\t\t\treturn this.dispatchEvent(modelChangedEvent);\n\t\t},\n\t\t/**\n\t\t * Sets the line delimiter that is used by the view\n\t\t * when new lines are inserted in the model due to key\n\t\t * strokes and paste operations. The line delimiter of\n\t\t * existing lines are unchanged unless the to <code>all</code>\n\t\t * argument is <code>true</code>.\n\t\t * <p>\n\t\t * If lineDelimiter is \"auto\", the delimiter is computed to be\n\t\t * the first delimiter found in the current text. If lineDelimiter\n\t\t * is undefined or if there are no delimiters in the current text, the\n\t\t * platform delimiter is used.\n\t\t * </p>\n\t\t *\n\t\t * @param {String} lineDelimiter the line delimiter that is used by the view when inserting new lines.\n\t\t * @param {Boolean} [all=false] whether or not the delimiter of existing lines are changed.\n\t\t */\n\t\tsetLineDelimiter: function(lineDelimiter, all) {\n\t\t\tif (lineDelimiter === \"auto\") { //$NON-NLS-0$\n\t\t\t\tlineDelimiter = undefined;\n\t\t\t\tif (this.getLineCount() > 1) {\n\t\t\t\t\tlineDelimiter = this.getText(this.getLineEnd(0), this.getLineEnd(0, true));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._lineDelimiter = lineDelimiter ? lineDelimiter : util.platformDelimiter;\n\t\t\tif (all) {\n\t\t\t\tvar lineCount = this.getLineCount();\n\t\t\t\tif (lineCount > 1) {\n\t\t\t\t\tvar lines = new Array(lineCount);\n\t\t\t\t\tfor (var i=0; i<lineCount; i++) {\n\t\t\t\t\t\tlines[i] = this.getLine(i);\n\t\t\t\t\t}\n\t\t\t\t\tthis.setText(lines.join(this._lineDelimiter));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Replaces the text in the given range with the given text.\n\t\t * <p>\n\t\t * The end offset is not inclusive. This means that the character at the \n\t\t * end offset is not replaced.\n\t\t * </p>\n\t\t * <p>\n\t\t * The text model must notify the listeners before and after the\n\t\t * the text is changed by calling {@link #onChanging} and {@link #onChanged}\n\t\t * respectively. \n\t\t * </p>\n\t\t *\n\t\t * @param {String} [text=\"\"] the new text.\n\t\t * @param {Number} [start=0] the zero based start offset of text range.\n\t\t * @param {Number} [end=char count] the zero based end offset of text range.\n\t\t *\n\t\t * @see orion.editor.TextModel#getText\n\t\t */\n\t\tsetText: function(text, start, end) {\n\t\t\tif (text === undefined) { text = \"\"; }\n\t\t\tif (start === undefined) { start = 0; }\n\t\t\tif (end === undefined) { end = this.getCharCount(); }\n\t\t\tif (start === end && text === \"\") { return; }\n\t\t\tvar startLine = this.getLineAtOffset(start);\n\t\t\tvar endLine = this.getLineAtOffset(end);\n\t\t\tvar eventStart = start;\n\t\t\tvar removedCharCount = end - start;\n\t\t\tvar removedLineCount = endLine - startLine;\n\t\t\tvar addedCharCount = text.length;\n\t\t\tvar addedLineCount = 0;\n\t\t\tvar lineCount = this.getLineCount();\n\t\t\t\n\t\t\tvar cr = 0, lf = 0, index = 0;\n\t\t\tvar newLineOffsets = [];\n\t\t\twhile (true) {\n\t\t\t\tif (cr !== -1 && cr <= index) { cr = text.indexOf(\"\\r\", index); } //$NON-NLS-0$\n\t\t\t\tif (lf !== -1 && lf <= index) { lf = text.indexOf(\"\\n\", index); } //$NON-NLS-0$\n\t\t\t\tif (lf === -1 && cr === -1) { break; }\n\t\t\t\tif (cr !== -1 && lf !== -1) {\n\t\t\t\t\tif (cr + 1 === lf) {\n\t\t\t\t\t\tindex = lf + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tindex = (cr < lf ? cr : lf) + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (cr !== -1) {\n\t\t\t\t\tindex = cr + 1;\n\t\t\t\t} else {\n\t\t\t\t\tindex = lf + 1;\n\t\t\t\t}\n\t\t\t\tnewLineOffsets.push(start + index);\n\t\t\t\taddedLineCount++;\n\t\t\t}\n\t\t\n\t\t\tvar modelChangingEvent = {\n\t\t\t\ttype: \"Changing\", //$NON-NLS-0$\n\t\t\t\ttext: text,\n\t\t\t\tstart: eventStart,\n\t\t\t\tremovedCharCount: removedCharCount,\n\t\t\t\taddedCharCount: addedCharCount,\n\t\t\t\tremovedLineCount: removedLineCount,\n\t\t\t\taddedLineCount: addedLineCount\n\t\t\t};\n\t\t\tthis.onChanging(modelChangingEvent);\n\t\t\t\n\t\t\t//TODO this should be done the loops below to avoid getText()\n\t\t\tif (newLineOffsets.length === 0) {\n\t\t\t\tvar startLineOffset = this.getLineStart(startLine), endLineOffset;\n\t\t\t\tif (endLine + 1 < lineCount) {\n\t\t\t\t\tendLineOffset = this.getLineStart(endLine + 1);\n\t\t\t\t} else {\n\t\t\t\t\tendLineOffset = this.getCharCount();\n\t\t\t\t}\n\t\t\t\tif (start !== startLineOffset) {\n\t\t\t\t\ttext = this.getText(startLineOffset, start) + text;\n\t\t\t\t\tstart = startLineOffset;\n\t\t\t\t}\n\t\t\t\tif (end !== endLineOffset) {\n\t\t\t\t\ttext = text + this.getText(end, endLineOffset);\n\t\t\t\t\tend = endLineOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar changeCount = addedCharCount - removedCharCount;\n\t\t\tfor (var j = startLine + removedLineCount + 1; j < lineCount; j++) {\n\t\t\t\tthis._lineOffsets[j] += changeCount;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t* Feature in Chrome.  Chrome exceeds the maximum call stack when calling splice\n\t\t\t* around 62k arguments. The limit seems to be higher on IE (250K) and Firefox (450k).\n\t\t\t* The fix is to break the splice in junks of 50k.\n\t\t\t*/\n\t\t\tvar SPLICE_LIMIT = 50000;\n\t\t\tvar limit = SPLICE_LIMIT, args;\n\t\t\tif (newLineOffsets.length < limit) {\n\t\t\t\targs = [startLine + 1, removedLineCount].concat(newLineOffsets);\n\t\t\t\tArray.prototype.splice.apply(this._lineOffsets, args);\n\t\t\t} else {\n\t\t\t\tindex = startLine + 1;\n\t\t\t\tthis._lineOffsets.splice(index, removedLineCount);\n\t\t\t\tfor (var k = 0; k < newLineOffsets.length; k += limit) {\n\t\t\t\t\targs = [index, 0].concat(newLineOffsets.slice(k, Math.min(newLineOffsets.length, k + limit)));\n\t\t\t\t\tArray.prototype.splice.apply(this._lineOffsets, args);\n\t\t\t\t\tindex += limit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar offset = 0, chunk = 0, length;\n\t\t\twhile (chunk<this._text.length) {\n\t\t\t\tlength = this._text[chunk].length; \n\t\t\t\tif (start <= offset + length) { break; }\n\t\t\t\toffset += length;\n\t\t\t\tchunk++;\n\t\t\t}\n\t\t\tvar firstOffset = offset;\n\t\t\tvar firstChunk = chunk;\n\t\t\twhile (chunk<this._text.length) {\n\t\t\t\tlength = this._text[chunk].length; \n\t\t\t\tif (end <= offset + length) { break; }\n\t\t\t\toffset += length;\n\t\t\t\tchunk++;\n\t\t\t}\n\t\t\tvar lastOffset = offset;\n\t\t\tvar lastChunk = chunk;\n\t\t\tvar firstText = this._text[firstChunk];\n\t\t\tvar lastText = this._text[lastChunk];\n\t\t\tvar beforeText = firstText.substring(0, start - firstOffset);\n\t\t\tvar afterText = lastText.substring(end - lastOffset);\n\t\t\tvar params = [firstChunk, lastChunk - firstChunk + 1];\n\t\t\tif (beforeText) { params.push(beforeText); }\n\t\t\tif (text) { params.push(text); }\n\t\t\tif (afterText) { params.push(afterText); }\n\t\t\tArray.prototype.splice.apply(this._text, params);\n\t\t\tif (this._text.length === 0) { this._text = [\"\"]; }\n\t\t\t\n\t\t\tvar modelChangedEvent = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tstart: eventStart,\n\t\t\t\tremovedCharCount: removedCharCount,\n\t\t\t\taddedCharCount: addedCharCount,\n\t\t\t\tremovedLineCount: removedLineCount,\n\t\t\t\taddedLineCount: addedLineCount\n\t\t\t};\n\t\t\tthis.onChanged(modelChangedEvent);\n\t\t}\n\t};\n\tmEventTarget.EventTarget.addMixin(TextModel.prototype);\n\t\n\treturn {TextModel: TextModel};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/keyBinding\", ['orion/util'], function(util) { //$NON-NLS-1$ //$NON-NLS-0$\n\n    /**\n\t * @class A KeyBinding is an interface used to define keyboard shortcuts.\n\t * @name orion.KeyBinding\n\t * \n\t * @property {Function} match The function to match events.\n\t * @property {Function} equals The funtion to compare to key bindings.\n\t *\n\t * @see orion.KeyStroke\n\t * @see orion.KeySequence\n\t */\n\n\t/**\n\t * Constructs a new key stroke with the given key code, modifiers and event type.\n\t * \n\t * @param {String|Number} keyCode the key code.\n\t * @param {Boolean} mod1 the primary modifier (usually Command on Mac and Control on other platforms).\n\t * @param {Boolean} mod2 the secondary modifier (usually Shift).\n\t * @param {Boolean} mod3 the third modifier (usually Alt).\n\t * @param {Boolean} mod4 the fourth modifier (usually Control on the Mac).\n\t * @param {String} type the type of event that the keybinding matches; either \"keydown\" or \"keypress\".\n\t * \n\t * @class A KeyStroke represents of a key code and modifier state that can be triggered by the user using the keyboard.\n\t * @name orion.KeyStroke\n\t * \n\t * @property {String|Number} keyCode The key code.\n\t * @property {Boolean} mod1 The primary modifier (usually Command on Mac and Control on other platforms).\n\t * @property {Boolean} mod2 The secondary modifier (usually Shift).\n\t * @property {Boolean} mod3 The third modifier (usually Alt).\n\t * @property {Boolean} mod4 The fourth modifier (usually Control on the Mac).\n\t * @property {String} [type=keydown] The type of event that the keybinding matches; either \"keydown\" or \"keypress\"\n\t *\n\t * @see orion.editor.TextView#setKeyBinding\n\t */\n\tfunction KeyStroke (keyCode, mod1, mod2, mod3, mod4, type) {\n\t\tthis.type = type || \"keydown\"; //$NON-NLS-0$\n\t\tif (typeof(keyCode) === \"string\" && this.type === \"keydown\") { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tthis.keyCode = keyCode.toUpperCase().charCodeAt(0);\n\t\t} else {\n\t\t\tthis.keyCode = keyCode;\n\t\t}\n\t\tthis.mod1 = mod1 !== undefined && mod1 !== null ? mod1 : false;\n\t\tthis.mod2 = mod2 !== undefined && mod2 !== null ? mod2 : false;\n\t\tthis.mod3 = mod3 !== undefined && mod3 !== null ? mod3 : false;\n\t\tthis.mod4 = mod4 !== undefined && mod4 !== null ? mod4 : false;\n\t}\n\tKeyStroke.prototype = /** @lends orion.KeyStroke.prototype */ {\n\t\tgetKeys: function() {\n\t\t\treturn [this];\n\t\t},\n\t\t/**\n\t\t * Determines either this key stroke matches the specifed event.  It can match either a\n\t\t * a whole sequence of key events or a single key event at a specified index.\n\t\t * <p>\n\t\t * <code>KeyStroke</code> only matches single key events. <code>KeySequence</code> handles\n\t\t * matching a sequence of events.\n\t\t * </p>\n\t\t * TODO explain this better\n\t\t * \n\t\t * @param {DOMEvent|DOMEvent[]} e the key event or list of events to match.\n\t\t * @param index the key event to match.\n\t\t * @returns {Boolean} <code>true</code> whether the key binding matches the key event.\n\t\t *\n\t\t * @see orion.KeySequence#match\n\t\t */\n\t\tmatch: function (e, index) {\n\t\t\tif (index !== undefined) {\n\t\t\t\tif (index !== 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (e instanceof Array) {\n\t\t\t\t\tif (e.length > 1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\te = e[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.type !== this.type) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.keyCode === e.keyCode || this.keyCode === String.fromCharCode(util.isOpera ? e.which : (e.charCode !== undefined ? e.charCode : e.keyCode))) {\n\t\t\t\tvar mod1 = util.isMac ? e.metaKey : e.ctrlKey;\n\t\t\t\tif (this.mod1 !== mod1) { return false; }\n\t\t\t\tif (this.type === \"keydown\") { //$NON-NLS-0$\n\t\t\t\t\tif (this.mod2 !== e.shiftKey) { return false; }\n\t\t\t\t}\n\t\t\t\tif (this.mod3 !== e.altKey) { return false; }\n\t\t\t\tif (util.isMac && this.mod4 !== e.ctrlKey) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t/**\n\t\t * Returns whether this key stroke is the same as the given parameter.\n\t\t * \n\t\t * @param {orion.KeyBinding} kb the key binding to compare with.\n\t\t * @returns {Boolean} whether or not the parameter and the receiver describe the same key binding.\n\t\t */\n\t\tequals: function(kb) {\n\t\t\tif (!kb) { return false; }\n\t\t\tif (this.keyCode !== kb.keyCode) { return false; }\n\t\t\tif (this.mod1 !== kb.mod1) { return false; }\n\t\t\tif (this.mod2 !== kb.mod2) { return false; }\n\t\t\tif (this.mod3 !== kb.mod3) { return false; }\n\t\t\tif (this.mod4 !== kb.mod4) { return false; }\n\t\t\tif (this.type !== kb.type) { return false; }\n\t\t\treturn true;\n\t\t} \n\t};\n\t\n\t/**\n\t * Constructs a new key sequence with the given key strokes.\n\t * \n\t * @param {orion.KeyStroke[]} keys the key strokes for this sequence.\n\t * \n\t * @class A KeySequence represents of a list of key codes and a modifiers state that can be triggered by the user using the keyboard.\n\t * @name orion.KeySequence\n\t * \n\t * @property {orion.KeyStroke[]} keys the list of key strokes.\n\t *\n\t * @see orion.editor.TextView#setKeyBinding\n\t */\n\tfunction KeySequence (keys) {\n\t\tthis.keys = keys;\n\t}\n\tKeySequence.prototype = /** @lends orion.KeySequence.prototype */ {\n\t\tgetKeys: function() {\n\t\t\treturn this.keys.slice(0);\n\t\t},\n\t\tmatch: function (e, index) {\n\t\t\tvar keys = this.keys;\n\t\t\tif (index !== undefined) {\n\t\t\t\tif (index > keys.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (keys[index].match(e)) {\n\t\t\t\t\tif (index === keys.length - 1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn index + 1;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (!(e instanceof Array)) {\n\t\t\t\t\te = [e];\n\t\t\t\t}\n\t\t\t\tif (e.length > keys.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < e.length; i++) {\n\t\t\t\t\tif (!keys[i].match(e[i])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i === keys.length) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn i;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns whether this key sequence is the same as the given parameter.\n\t\t * \n\t\t * @param {orion.KeyBinding|orion.KeySequence} kb the key binding to compare with.\n\t\t * @returns {Boolean} whether or not the parameter and the receiver describe the same key binding.\n\t\t */\n\t\tequals: function(kb) {\n\t\t\tif (!kb.keys) { return false; }\n\t\t\tif (kb.keys.length !== this.keys.length) { return false; }\n\t\t\tfor (var i=0; i<kb.keys.length; i++) {\n\t\t\t\tif (!kb.keys[i].equals(this.keys[i])) { return false; }\n\t\t\t}\n\t\t\treturn true;\n\t\t}\t\n\t};\n\t\n\treturn {\n\t\tKeyBinding: KeyStroke, // for backwards compatibility\n\t\tKeyStroke: KeyStroke,\n\t\tKeySequence: KeySequence\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n \n/*eslint-env browser, amd*/\ndefine(\"orion/editor/keyModes\", [ //$NON-NLS-0$\n\t\t\"orion/keyBinding\", //$NON-NLS-0$\n\t\t\"orion/util\" //$NON-NLS-0$\n], function(mKeyBinding, util) {\n\n\tfunction KeyMode(view) {\n\t\tif (!view) {\n\t\t\treturn;\n\t\t}\n\t\tthis._view = view;\n\t\tthis._keyBindings = this.createKeyBindings();\n\t\tthis._keyBindingIndex = 0;\n\t}\n\tKeyMode.prototype = /** @lends orion.editor.KeyMode.prototype */ {\n\t\tcreateKeyBindings: function () {\n\t\t\treturn [];\n\t\t},\n\t\t/**\n\t\t * Returns all the key bindings associated to the given action ID.\n\t\t *\n\t\t * @param {String} actionID the action ID.\n\t\t * @returns {orion.KeyBinding[]} the array of key bindings associated to the given action ID.\n\t\t *\n\t\t * @see orion.editor.KeyModesetKeyBinding\n\t\t * @see orion.editor.KeyModesetAction\n\t\t */\n\t\tgetKeyBindings: function (actionID) {\n\t\t\tvar result = [];\n\t\t\tvar keyBindings = this._keyBindings;\n\t\t\tfor (var i = 0; i < keyBindings.length; i++) {\n\t\t\t\tif (keyBindings[i].actionID === actionID) {\n\t\t\t\t\tresult.push(keyBindings[i].keyBinding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetView: function() {\n\t\t\treturn this._view;\n\t\t},\n\t\tisActive: function () {\n\t\t\treturn this._view.getKeyModes().indexOf(this) !== -1;\n\t\t},\n\t\tmatch: function(e) {\n\t\t\tif (e.type === \"keydown\") { //$NON-NLS-0$\n\t\t\t\tswitch (e.keyCode) {\n\t\t\t\t\tcase 16: /* Shift */\n\t\t\t\t\tcase 17: /* Control */\n\t\t\t\t\tcase 18: /* Alt */\n\t\t\t\t\tcase 91: /* Command */\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar keyBindingIndex = this._keyBindingIndex;\n\t\t\tvar keyBindings = this._matchingKeyBindings || this._keyBindings;\n\t\t\tvar matchingKeyBindings = [];\n\t\t\tfor (var i = 0; i < keyBindings.length; i++) {\n\t\t\t\tvar kb = keyBindings[i];\n\t\t\t\tvar keyBinding = kb.keyBinding;\n\t\t\t\tvar match = keyBinding.match(e, keyBindingIndex);\n\t\t\t\tif (match === true) {\n\t\t\t\t\tthis._keyBindingIndex = 0;\n\t\t\t\t\tthis._matchingKeyBindings = null;\n\t\t\t\t\treturn kb.actionID;\n\t\t\t\t} else if (typeof match === \"number\") { //$NON-NLS-0$\n\t\t\t\t\tmatchingKeyBindings.push(kb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (matchingKeyBindings.length === 0) {\n\t\t\t\tthis._keyBindingIndex = 0;\n\t\t\t\tthis._matchingKeyBindings = null;\n\t\t\t} else {\n\t\t\t\tthis._keyBindingIndex++;\n\t\t\t\tthis._matchingKeyBindings = matchingKeyBindings;\n\t\t\t\treturn \"noop\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\t/**\n\t\t * Associates a key binding with the given action ID. Any previous\n\t\t * association with the specified key binding is overwriten. If the\n\t\t * action ID is <code>null</code>, the association is removed.\n\t\t * \n\t\t * @param {orion.KeyBinding} keyBinding the key binding\n\t\t * @param {String} actionID the action ID\n\t\t */\n\t\tsetKeyBinding: function(keyBinding, actionID) {\n\t\t\tvar keyBindings = this._keyBindings;\n\t\t\tfor (var i = 0; i < keyBindings.length; i++) {\n\t\t\t\tvar kb = keyBindings[i]; \n\t\t\t\tif (kb.keyBinding.equals(keyBinding)) {\n\t\t\t\t\tif (actionID) {\n\t\t\t\t\t\tkb.actionID = actionID;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (kb.predefined) {\n\t\t\t\t\t\t\tkb.actionID = \"noop\"; //$NON-NLS-0$\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkeyBindings.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (actionID) {\n\t\t\t\tkeyBindings.push({keyBinding: keyBinding, actionID: actionID});\n\t\t\t}\n\t\t},\n\t\tsetView: function(view) {\n\t\t\tthis._view = view;\n\t\t}\n\t};\n\t\n\tfunction DefaultKeyMode(view) {\n\t\tKeyMode.call(this, view);\n\t}\n\tDefaultKeyMode.prototype = new KeyMode();\n\tDefaultKeyMode.prototype.createKeyBindings = function () {\n\t\tvar KeyBinding = mKeyBinding.KeyBinding;\n\t\t//no duplicate keybindings\n\t\tvar bindings = [];\n\n\t\t// Cursor Navigation\n\t\tbindings.push({actionID: \"lineUp\",\t\tkeyBinding: new KeyBinding(38), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"lineDown\",\tkeyBinding: new KeyBinding(40), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"charPrevious\",\tkeyBinding: new KeyBinding(37), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"charNext\",\tkeyBinding: new KeyBinding(39), predefined: true}); //$NON-NLS-0$\n\t\tif (util.isMac) {\n\t\t\tbindings.push({actionID: \"scrollPageUp\",\t\tkeyBinding: new KeyBinding(33), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"scrollPageDown\",\tkeyBinding: new KeyBinding(34), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"pageUp\",\t\tkeyBinding: new KeyBinding(33, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"pageDown\",\tkeyBinding: new KeyBinding(34, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineStart\",\tkeyBinding: new KeyBinding(37, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineEnd\",\t\tkeyBinding: new KeyBinding(39, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"wordPrevious\",\tkeyBinding: new KeyBinding(37, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"wordNext\",\tkeyBinding: new KeyBinding(39, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"scrollTextStart\",\tkeyBinding: new KeyBinding(36), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"scrollTextEnd\",\t\tkeyBinding: new KeyBinding(35), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"textStart\",\tkeyBinding: new KeyBinding(38, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"textEnd\",\t\tkeyBinding: new KeyBinding(40, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"scrollPageUp\",\tkeyBinding: new KeyBinding(38, null, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"scrollPageDown\",\t\tkeyBinding: new KeyBinding(40, null, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineStart\",\tkeyBinding: new KeyBinding(37, null, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineEnd\",\t\tkeyBinding: new KeyBinding(39, null, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\t//TODO These two actions should be changed to paragraph start and paragraph end  when word wrap is implemented\n\t\t\tbindings.push({actionID: \"lineStart\",\tkeyBinding: new KeyBinding(38, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineEnd\",\t\tkeyBinding: new KeyBinding(40, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t} else {\n\t\t\tbindings.push({actionID: \"pageUp\",\t\tkeyBinding: new KeyBinding(33), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"pageDown\",\tkeyBinding: new KeyBinding(34), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineStart\",\tkeyBinding: new KeyBinding(36), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineEnd\",\t\tkeyBinding: new KeyBinding(35), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"wordPrevious\",\tkeyBinding: new KeyBinding(37, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"wordNext\",\tkeyBinding: new KeyBinding(39, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"textStart\",\tkeyBinding: new KeyBinding(36, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"textEnd\",\t\tkeyBinding: new KeyBinding(35, true), predefined: true}); //$NON-NLS-0$\n\t\t}\n\t\tif (util.isFirefox && util.isLinux) {\n\t\t\tbindings.push({actionID: \"lineUp\",\t\tkeyBinding: new KeyBinding(38, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineDown\",\tkeyBinding: new KeyBinding(40, true), predefined: true}); //$NON-NLS-0$\n\t\t}\n\t\tif (util.isWindows) {\n\t\t\tbindings.push({actionID: \"scrollLineUp\",\tkeyBinding: new KeyBinding(38, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"scrollLineDown\",\tkeyBinding: new KeyBinding(40, true), predefined: true}); //$NON-NLS-0$\n\t\t}\n\n\t\t// Select Cursor Navigation\n\t\tbindings.push({actionID: \"selectLineUp\",\t\tkeyBinding: new KeyBinding(38, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"selectLineDown\",\t\tkeyBinding: new KeyBinding(40, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"selectCharPrevious\",\tkeyBinding: new KeyBinding(37, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"selectCharNext\",\t\tkeyBinding: new KeyBinding(39, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"selectPageUp\",\t\tkeyBinding: new KeyBinding(33, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"selectPageDown\",\t\tkeyBinding: new KeyBinding(34, null, true), predefined: true}); //$NON-NLS-0$\n\t\tif (util.isMac) {\n\t\t\tbindings.push({actionID: \"selectLineStart\",\tkeyBinding: new KeyBinding(37, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectLineEnd\",\t\tkeyBinding: new KeyBinding(39, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectWordPrevious\",\tkeyBinding: new KeyBinding(37, null, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectWordNext\",\tkeyBinding: new KeyBinding(39, null, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectTextStart\",\tkeyBinding: new KeyBinding(36, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectTextEnd\",\t\tkeyBinding: new KeyBinding(35, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectTextStart\",\tkeyBinding: new KeyBinding(38, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectTextEnd\",\t\tkeyBinding: new KeyBinding(40, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectLineStart\",\tkeyBinding: new KeyBinding(37, null, true, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectLineEnd\",\t\tkeyBinding: new KeyBinding(39, null, true, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\t//TODO These two actions should be changed to select paragraph start and select paragraph end  when word wrap is implemented\n\t\t\tbindings.push({actionID: \"selectLineStart\",\tkeyBinding: new KeyBinding(38, null, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectLineEnd\",\t\tkeyBinding: new KeyBinding(40, null, true, true), predefined: true}); //$NON-NLS-0$\n\t\t} else {\n\t\t\tif (util.isLinux) {\n\t\t\t\tbindings.push({actionID: \"selectWholeLineUp\",\t\tkeyBinding: new KeyBinding(38, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\t\tbindings.push({actionID: \"selectWholeLineDown\",\t\tkeyBinding: new KeyBinding(40, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\t}\n\t\t\tbindings.push({actionID: \"selectLineStart\",\t\tkeyBinding: new KeyBinding(36, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectLineEnd\",\t\tkeyBinding: new KeyBinding(35, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectWordPrevious\",\tkeyBinding: new KeyBinding(37, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectWordNext\",\t\tkeyBinding: new KeyBinding(39, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectTextStart\",\t\tkeyBinding: new KeyBinding(36, true, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"selectTextEnd\",\t\tkeyBinding: new KeyBinding(35, true, true), predefined: true}); //$NON-NLS-0$\n\t\t}\n\t\t\n\t\t//Undo stack\n\t\tbindings.push({actionID: \"undo\", keyBinding: new mKeyBinding.KeyBinding('z', true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\tif (util.isMac) {\n\t\t\tbindings.push({actionID: \"redo\", keyBinding: new mKeyBinding.KeyBinding('z', true, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t} else {\n\t\t\tbindings.push({actionID: \"redo\", keyBinding: new mKeyBinding.KeyBinding('y', true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t}\n\n\t\t//Misc\n\t\tbindings.push({actionID: \"deletePrevious\",\t\tkeyBinding: new KeyBinding(8), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"deletePrevious\",\t\tkeyBinding: new KeyBinding(8, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"deleteNext\",\t\tkeyBinding: new KeyBinding(46), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"deleteWordPrevious\",\tkeyBinding: new KeyBinding(8, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"deleteWordPrevious\",\tkeyBinding: new KeyBinding(8, true, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"deleteWordNext\",\t\tkeyBinding: new KeyBinding(46, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"tab\",\t\t\tkeyBinding: new KeyBinding(9), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"shiftTab\",\t\t\tkeyBinding: new KeyBinding(9, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"enter\",\t\t\tkeyBinding: new KeyBinding(13), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"enter\",\t\t\tkeyBinding: new KeyBinding(13, null, true), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"escape\",\t\t\tkeyBinding: new KeyBinding(27), predefined: true}); //$NON-NLS-0$\n\t\tbindings.push({actionID: \"selectAll\",\t\tkeyBinding: new KeyBinding('a', true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\tbindings.push({actionID: \"toggleTabMode\",\tkeyBinding: new KeyBinding('m', true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\tif (util.isMac) {\n\t\t\tbindings.push({actionID: \"deleteNext\",\t\tkeyBinding: new KeyBinding(46, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"deleteWordPrevious\",\tkeyBinding: new KeyBinding(8, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"deleteWordNext\",\t\tkeyBinding: new KeyBinding(46, null, null, true), predefined: true}); //$NON-NLS-0$\n\t\t}\n\t\t\n\t\tbindings.push({actionID: \"toggleWrapMode\",\t\tkeyBinding: new mKeyBinding.KeyBinding('w', true, false, true)}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\tbindings.push({actionID: \"toggleOverwriteMode\",\t\tkeyBinding: new mKeyBinding.KeyBinding(45)}); //$NON-NLS-0$\n\t\t\n\t\t/*\n\t\t* Feature in IE/Chrome: prevent ctrl+'u', ctrl+'i', and ctrl+'b' from applying styles to the text.\n\t\t*\n\t\t* Note that Chrome applies the styles on the Mac with Ctrl instead of Cmd.\n\t\t*/\n\t\tif (!util.isFirefox) {\n\t\t\tvar isMacChrome = util.isMac && util.isChrome;\n\t\t\tbindings.push({actionID: \"noop\", keyBinding: new KeyBinding('u', !isMacChrome, false, false, isMacChrome), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"noop\", keyBinding: new KeyBinding('i', !isMacChrome, false, false, isMacChrome), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"noop\", keyBinding: new KeyBinding('b', !isMacChrome, false, false, isMacChrome), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t}\n\n\t\tif (util.isFirefox) {\n\t\t\tbindings.push({actionID: \"copy\", keyBinding: new KeyBinding(45, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"paste\", keyBinding: new KeyBinding(45, null, true), predefined: true}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"cut\", keyBinding: new KeyBinding(46, null, true), predefined: true}); //$NON-NLS-0$\n\t\t}\n\n\t\t// Add the emacs Control+ ... key bindings.\n\t\tif (util.isMac) {\n\t\t\tbindings.push({actionID: \"lineStart\", keyBinding: new KeyBinding(\"a\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineEnd\", keyBinding: new KeyBinding(\"e\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineUp\", keyBinding: new KeyBinding(\"p\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"lineDown\", keyBinding: new KeyBinding(\"n\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"charPrevious\", keyBinding: new KeyBinding(\"b\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"charNext\", keyBinding: new KeyBinding(\"f\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"deletePrevious\", keyBinding: new KeyBinding(\"h\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"deleteNext\", keyBinding: new KeyBinding(\"d\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"deleteLineEnd\", keyBinding: new KeyBinding(\"k\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tif (util.isFirefox) {\n\t\t\t\tbindings.push({actionID: \"scrollPageDown\", keyBinding: new KeyBinding(\"v\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tbindings.push({actionID: \"deleteLineStart\", keyBinding: new KeyBinding(\"u\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tbindings.push({actionID: \"deleteWordPrevious\", keyBinding: new KeyBinding(\"w\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tbindings.push({actionID: \"pageDown\", keyBinding: new KeyBinding(\"v\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tbindings.push({actionID: \"centerLine\", keyBinding: new KeyBinding(\"l\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tbindings.push({actionID: \"enterNoCursor\", keyBinding: new KeyBinding(\"o\", false, false, false, true), predefined: true}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t//TODO implement: y (yank), t (transpose)\n\t\t\t}\n\t\t}\n\t\treturn bindings;\n\t};\n\t\n\treturn {\n\t\tKeyMode: KeyMode,\n\t\tDefaultKeyMode: DefaultKeyMode\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013,2014 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n \n/*eslint-env browser, amd*/\ndefine(\"orion/editor/textTheme\", //$NON-NLS-0$\n[\n\t'require', //$NON-NLS-0$\n\t'orion/editor/eventTarget', //$NON-NLS-0$\n\t'orion/util' //$NON-NLS-0$\n], function(require, mEventTarget, util) {\n\tvar THEME_PREFIX = \"orion-theme-\"; //$NON-NLS-0$\n\t\n\tvar Themes = {};\n\n\t/**\n\t * Constructs a new text theme. \n\t * \n\t * @class A TextTheme is a class used to specify an editor theme.\n\t * @name orion.editor.TextTheme\n\t * @borrows orion.editor.EventTarget#addEventListener as #addEventListener\n\t * @borrows orion.editor.EventTarget#removeEventListener as #removeEventListener\n\t * @borrows orion.editor.EventTarget#dispatchEvent as #dispatchEvent\n\t */\n\tfunction TextTheme(options) {\n\t\toptions = options || {};\n\t\tthis._document = options.document || document;\n\t}\n\n\t/**\n\t * Gets an instance of <code>orion.editor.TextTheme</code> by name. If the name\n\t * paramenter is not speficed the default text theme instance is returned.\n\t * Subsequent calls of <code>getTheme</code> with the same name will return\n\t * the same instance.\n\t */\n\tTextTheme.getTheme = function(name) {\n\t\tname = name || \"default\"; //$NON-NLS-0$\n\t\tvar theme = Themes[name];\n\t\tif (!theme) {\n\t\t\ttheme = Themes[name] = new TextTheme();\n\t\t}\n\t\treturn theme;\n\t};\n\n\tTextTheme.prototype = /** @lends orion.editor.TextTheme.prototype */ {\n\t\t/**\n\t\t * Returns the theme className.\n\t\t *\n\t\t * @see orion.editor.TextTheme#setThemeClass\n\t\t */\n\t\tgetThemeClass: function() {\n\t\t\treturn this._themeClass;\n\t\t},\n\t\t/**\n\t\t * @class This object represents a style sheet for a theme manager.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextTheme#setThemeClass}\n\t\t * </p>\n\t\t * @name orion.editor.ThemeStyleSheet\n\t\t * \n\t\t * @property {String} href The href of the stylesheet\n\t\t */\n\t\t/**\n\t\t * Sets the theme className and style sheet.\n\t\t * <p>\n\t\t * If the <code>stylesheet</code> parameter is a string, it represents an inline\n\t\t * CSS and it will be added to the document as a <i>STYLE</i> tag element.  If the\n\t\t * <code>stylesheet</code> parameter is a <code>orion.editor.ThemeStyleSheet</code>,\n\t\t * its href property is loaded as either a <i>STYLE</i> tag element or as a <i>LINK</i>\n\t\t * tag element.\n\t\t * </p>\n\t\t * <p>\n\t\t * Listeners of the ThemeChanged event are notify once the styled sheet is loaded\n\t\t * into the document.\n\t\t * </p>\n\t\t *\n\t\t * @param {String} className the new theme className.\n\t\t * @param {String|orion.editor.ThemeStyleSheet} styleSheet the CSS stylesheet for the new theme className.\n\t\t *\n\t\t * @see orion.editor.TextTheme#getThemeClass\n\t\t * @see orion.editor.TextTheme#onThemeChanged\n\t\t */\n\t\t setThemeClass: function(className, styleSheet) {\n\t\t\tvar self = this;\n\t\t\tvar oldThemeClass = self._themeClass;\t\n\t\t\tself._themeClass = className;\n\t\t\tthis._load(className, styleSheet, function() {\n\t\t\t\tself.onThemeChanged({\n\t\t\t\t\ttype: \"ThemeChanged\", //$NON-NLS-0$\n\t\t\t\t\toldValue: oldThemeClass,\n\t\t\t\t\tnewValue: self.getThemeClass()\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the theme className or style sheet has changed.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextTheme}<br/>\n\t\t * {@link orion.editor.TextTheme#event:onThemeChanged}\n\t\t * </p>\n\t\t * @name orion.editor.ThemeChangedEvent\n\t\t * \n\t\t * @property {String} oldValue The old theme clasName.\n\t\t * @property {String} newValue The new theme className.\n\t\t */\n\t\t/**\n\t\t * This event is sent when the theme clasName has changed and its style sheet has been loaded in the document.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.ThemeChangedEvent} themeChangedEvent the event\n\t\t */\n\t\tonThemeChanged: function(themeChangedEvent) {\n\t\t\treturn this.dispatchEvent(themeChangedEvent);\n\t\t},\n\t\tbuildStyleSheet: function(themeClass, settings) {\n\t\t\tvar convertCSSname = function(name) {\n\t\t\t\treturn name.replace(this._capitalRegEx, function(match) {\n\t\t\t\t\treturn \"-\" + match; //$NON-NLS-0$\n\t\t\t\t}.bind(this)).toLowerCase();\n\t\t\t}.bind(this);\n\n\t\t\tvar parseStyles = function(object, ancestors, className, isTopLevel, result) {\n\t\t\t\tvar localResult = [];\n\t\t\t\tvar keys = Object.keys(object);\n\t\t\t\tkeys.forEach(function(key) {\n\t\t\t\t\tvar value = object[key];\n\t\t\t\t\tif (typeof(value) === \"string\") { //$NON-NLS-0$\n\t\t\t\t\t\tlocalResult.push(\"\\t\" + convertCSSname(key) + \": \" + value + \";\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparseStyles(\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tclassName === key ? ancestors : ancestors + (isTopLevel ? \" .\" : \".\") + key, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\tclassName,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tresult);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (localResult.length) {\n\t\t\t\t\tresult.push(ancestors + (isTopLevel ? \".textview\" : \"\") + \" {\"); //$NON-NLS-0$\n\t\t\t\t\tresult.push.apply(result, localResult);\n\t\t\t\t\tresult.push(\"}\"); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar result = [\"\"];\n\t\t\tparseStyles(settings.styles, \".\" + themeClass, settings.className, true, result); //$NON-NLS-0$\n\t\t\treturn result.join(\"\\n\"); //$NON-NLS-0$\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_createStyle: function(className, styleSheet, callback, link) {\n\t\t\tvar document = this._document;\n\t\t\tvar id = THEME_PREFIX + className;\n\t\t\tvar node = document.getElementById(id);\n\t\t\tif (node) {\n\t\t\t\tif (link || node.firstChild.data === styleSheet) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnode.removeChild(node.firstChild);\n\t\t\t\tnode.appendChild(document.createTextNode(styleSheet));\n\t\t\t} else {\n\t\t\t\tif (link) {\n\t\t\t\t\tnode = util.createElement(document, \"link\"); //$NON-NLS-0$\n\t\t\t\t\tnode.rel = \"stylesheet\"; //$NON-NLS-0$\n\t\t\t\t\tnode.type = \"text/css\"; //$NON-NLS-0$\n\t\t\t\t\tnode.href = styleSheet;\n\t\t\t\t\tnode.addEventListener(\"load\", function() { //$NON-NLS-0$\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode = util.createElement(document, \"style\"); //$NON-NLS-0$\n\t\t\t\t\tnode.appendChild(document.createTextNode(styleSheet));\n\t\t\t\t}\n\t\t\t\tnode.id = id;\n\t\t\t\tvar head = document.getElementsByTagName(\"head\")[0] || document.documentElement; //$NON-NLS-0$\n\t\t\t\thead.appendChild(node);\n\t\t\t}\n\t\t\tif (!link) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_load: function (className, styleSheet, callback) {\n\t\t\tif (!className) {\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (typeof styleSheet === \"string\") { //$NON-NLS-0$\n\t\t\t\tthis._createStyle(className, styleSheet, callback);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar href = styleSheet.href;\n\t\t\tvar extension = \".css\"; //$NON-NLS-0$\n\t\t\tif (href.substring(href.length - extension.length) !== extension) {\n\t\t\t\thref += extension;\n\t\t\t}\n\t\t\tif (/^\\//.test(href) || /[a-zA-Z0-9]+:\\/\\//i.test(href) || !require.toUrl /* almond cannot load dynamically */) {\n\t\t\t\tthis._createStyle(className, href, callback, true);\n\t\t\t} else {\n\t\t\t\tvar self = this;\n\t\t\t\trequire([\"text!\" + href], function(cssText) { //$NON-NLS-0$\n\t\t\t\t\tself._createStyle(className, cssText, callback, false);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t_capitalRegEx: /[A-Z]/g\n\t};\n\tmEventTarget.EventTarget.addMixin(TextTheme.prototype);\n\t\n\treturn {\n\t\tTextTheme: TextTheme\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n \n/*eslint-env browser, amd*/\ndefine(\"orion/editor/util\", [], function() { //$NON-NLS-0$\n\t\n\t/** @private */\n\tfunction addEventListener(node, type, handler, capture) {\n\t\tif (typeof node.addEventListener === \"function\") { //$NON-NLS-0$\n\t\t\tnode.addEventListener(type, handler, capture === true);\n\t\t} else {\n\t\t\tnode.attachEvent(\"on\" + type, handler); //$NON-NLS-0$\n\t\t}\n\t}\n\t/** @private */\n\tfunction removeEventListener(node, type, handler, capture) {\n\t\tif (typeof node.removeEventListener === \"function\") { //$NON-NLS-0$\n\t\t\tnode.removeEventListener(type, handler, capture === true);\n\t\t} else {\n\t\t\tnode.detachEvent(\"on\" + type, handler); //$NON-NLS-0$\n\t\t}\n\t}\n\t/** @private */\n\tfunction contains(topNode, node) {\n\t\tif (!node) { return false; }\n\t\tif (!topNode.compareDocumentPosition) {\n\t\t\tvar temp = node;\n\t\t\twhile (temp) {\n\t\t\t\tif (topNode === temp) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttemp = temp.parentNode;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn topNode === node || (topNode.compareDocumentPosition(node) & 16) !== 0;\n\t}\n\t/** @private */\n\tfunction getNodeStyle(node, prop, defaultValue) {\n\t\tvar value;\n\t\tif (node) {\n\t\t\tvalue = node.style[prop];\n\t\t\tif (!value) {\n\t\t\t\tif (node.currentStyle) {\n\t\t\t\t\tvar index = 0, p = prop;\n\t\t\t\t\twhile ((index = p.indexOf(\"-\", index)) !== -1) { //$NON-NLS-0$\n\t\t\t\t\t\tp = p.substring(0, index) + p.substring(index + 1, index + 2).toUpperCase() + p.substring(index + 2);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = node.currentStyle[p];\n\t\t\t\t} else {\n\t\t\t\t\tvar css = node.ownerDocument.defaultView.getComputedStyle(node, null);\n\t\t\t\t\tvalue = css ? css.getPropertyValue(prop) : null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value || defaultValue;\n\t}\n\n\t/**\n\t * @class\n\t * @private\n\t * @name orion.editor.Animation\n\t * @description Creates an animation.\n\t * @param {Object} options Options controlling the animation.\n\t * @param {Array} options.curve Array of 2 values giving the start and end points for the animation.\n\t * @param {Number} [options.duration=350] Duration of the animation, in milliseconds.\n\t * @param {Function} [options.easing]\n\t * @param {Function} [options.onAnimate]\n\t * @param {Function} [options.onEnd]\n\t * @param {Number} [options.rate=20] The time between frames, in milliseconds.\n\t */\n\tvar Animation = /** @ignore */ (function() {\n\t\tfunction Animation(options) {\n\t\t\tthis.options = options;\n\t\t}\n\t\t/**\n\t\t * Plays this animation.\n\t\t * @function\n\t\t * @memberOf orion.editor.Animation.prototype\n\t\t * @name play\n\t\t */\n\t\tAnimation.prototype.play = function() {\n\t\t\tvar duration = (typeof this.options.duration === \"number\") ? this.options.duration : 350, //$NON-NLS-0$\n\t\t\t    rate = (typeof this.options.rate === \"number\") ? this.options.rate : 20, //$NON-NLS-0$\n\t\t\t    easing = this.options.easing || this.defaultEasing,\n\t\t\t    onAnimate = this.options.onAnimate || function() {},\n\t\t\t    start = this.options.curve[0],\n\t\t\t    end = this.options.curve[1],\n\t\t\t    range = (end - start),\n\t\t\t    startedAt = -1,\n\t\t\t\tpropertyValue,\n\t\t\t\tself = this;\n\n\t\t\tfunction onFrame() {\n\t\t\t\tstartedAt = (startedAt === -1) ? new Date().getTime() : startedAt;\n\t\t\t\tvar now = new Date().getTime(),\n\t\t\t\t    percentDone = (now - startedAt) / duration;\n\t\t\t\tif (percentDone < 1) {\n\t\t\t\t\tvar eased = easing(percentDone);\n\t\t\t\t\tpropertyValue = start + (eased * range);\n\t\t\t\t\tonAnimate(propertyValue);\n\t\t\t\t} else {\n\t\t\t\t\tonAnimate(end);\n\t\t\t\t\tself.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.interval = this.options.window.setInterval(onFrame, rate);\n\t\t};\n\t\t/**\n\t\t * Stops this animation.\n\t\t * @function\n\t\t * @memberOf orion.editor.Animation.prototype\n\t\t */\n\t\tAnimation.prototype.stop = function() {\n\t\t\tthis.options.window.clearInterval(this.interval);\n\t\t    var onEnd = this.options.onEnd || function () {};\n\t\t\tonEnd();\n\t\t};\n\t\tAnimation.prototype.defaultEasing = function(x) {\n\t\t\treturn Math.sin(x * (Math.PI / 2));\n\t\t};\n\t\treturn Animation;\n\t}());\n\n\treturn {\n\t\tcontains: contains,\n\t\tgetNodeStyle: getNodeStyle,\n\t\taddEventListener: addEventListener,\n\t\tremoveEventListener: removeEventListener,\n\t\tAnimation: Animation\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2014 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License v1.0\n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution\n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html).\n *\n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine('orion/metrics',[], function() {\n\n\tvar _services = [];\n\n\tfunction init(services, args) {\n\t\t/* the following definitions are from https://developers.google.com/analytics/devguides/collection/analyticsjs/pages */\n\t\tvar href = window.location.protocol + '//' + window.location.hostname + window.location.pathname + window.location.search; //$NON-NLS-0$\n\t\tvar page = window.location.pathname + window.location.search;\n\t\tvar title = document.title;\n\n\t\t_services = services;\n\t\t_services.forEach(function(current) {\n\t\t\tcurrent.pageLoad(href, page, title, args);\n\t\t});\n\t};\n\n\tfunction initFromRegistry(serviceRegistry, args) {\n\t\tvar refs = serviceRegistry.getServiceReferences(\"orion.metrics\"); //$NON-NLS-0$\n\t\tvar services = [];\n\t\trefs.forEach(function(current) {\n\t\t\tservices.push(serviceRegistry.getService(current));\n\t\t});\n\t\tinit(services, args);\n\t};\n\n\tfunction logEvent(category, action, label, value) {\n\t\t_services.forEach(function(current) {\n\t\t\tcurrent.logEvent(category, action, label, value);\n\t\t});\n\t}\n\n\tfunction logPageLoadTiming(timingVar, timingLabel) {\n\t\t/* \n\t\t * The level of window.performance implementation varies across the browsers,\n\t\t * so check for the existence of all utilized functions up-front.\n\t\t */\n\t\tif (window.performance && window.performance.getEntriesByName && window.performance.mark && !window.performance.getEntriesByName(timingVar).length) {\n\t\t\twindow.performance.mark(timingVar); /* ensure that no more timings of this type are logged for this page */\n\t\t\tlogTiming(\"page\", timingVar, window.performance.now(), timingLabel); //$NON-NLS-0$\n\t\t}\n\t}\n\n\tfunction logTiming(timingCategory, timingVar, timingValue, timingLabel) {\n\t\t_services.forEach(function(current) {\n\t\t\tcurrent.logTiming(timingCategory, timingVar, timingValue, timingLabel);\n\t\t});\n\t}\n\n\treturn {\n\t\tinit: init,\n\t\tinitFromRegistry: initFromRegistry,\n\t\tlogEvent: logEvent,\n\t\tlogPageLoadTiming: logPageLoadTiming,\n\t\tlogTiming: logTiming\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2015 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n *\t\tMihai Sucan (Mozilla Foundation) - fix for Bug#334583 Bug#348471 Bug#349485 Bug#350595 Bug#360726 Bug#361180 Bug#362835 Bug#362428 Bug#362286 Bug#354270 Bug#361474 Bug#363945 Bug#366312 Bug#370584\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/textView\", [  //$NON-NLS-0$\n\t'i18n!orion/editor/nls/messages', //$NON-NLS-0$\n\t'orion/editor/textModel', //$NON-NLS-0$\n\t'orion/editor/keyModes', //$NON-NLS-0$\n\t'orion/editor/eventTarget', //$NON-NLS-0$\n\t'orion/editor/textTheme', //$NON-NLS-0$\n\t'orion/editor/util', //$NON-NLS-0$\n\t'orion/util', //$NON-NLS-0$\n\t'orion/metrics' //$NON-NLS-0$\n], function(messages, mTextModel, mKeyModes, mEventTarget, mTextTheme, textUtil, util, mMetrics) {\n\n\t/** @private */\n\tfunction getWindow(document) {\n\t\treturn document.defaultView || document.parentWindow;\n\t}\n\tfunction newArray(length) {\n\t\treturn new Array(length);\n\t}\n\tvar addHandler = textUtil.addEventListener;\n\tvar removeHandler = textUtil.removeEventListener;\n\t/** @private */\n\tfunction applyStyle(style, node, reset) {\n\t\tif (reset) {\n\t\t\tnode.className = \"\";\n\t\t\tvar attrs = node.attributes;\n\t\t\tfor (var i= attrs.length; i-->0;) {\n\t\t\t\tif (!util.isIE || util.isIE >= 9 || (util.isIE < 9 && attrs[i].specified)) {\n\t\t\t\t\tnode.removeAttribute(attrs[i].name); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!style) {\n\t\t\treturn;\n\t\t}\n\t\tif (style.styleClass) {\n\t\t\tnode.className = style.styleClass;\n\t\t}\n\t\tvar properties = style.style;\n\t\tif (properties) {\n\t\t\tfor (var s in properties) {\n\t\t\t\tif (properties.hasOwnProperty(s)) {\n\t\t\t\t\tnode.style[s] = properties[s];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar attributes = style.attributes;\n\t\tif (attributes) {\n\t\t\tfor (var a in attributes) {\n\t\t\t\tif (attributes.hasOwnProperty(a)) {\n\t\t\t\t\tnode.setAttribute(a, attributes[a]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/** @private */\n\tfunction clone(obj) {\n\t\t/*Note that this code only works because of the limited types used in TextViewOptions */\n\t\tif (obj instanceof Array) {\n\t\t\treturn obj.slice(0);\n\t\t}\n\t\treturn obj;\n\t}\n\t/**\t@private */\n\tfunction merge(obj1, obj2) {\n\t\tif (!obj1) {\n\t\t\treturn obj2;\n\t\t}\n\t\tif (!obj2) {\n\t\t\treturn obj1;\n\t\t}\n\t\tfor (var p in obj2) {\n\t\t\tif (obj2.hasOwnProperty(p)) {\n\t\t\t\tif (!obj1.hasOwnProperty(p)) {\n\t\t\t\t\tobj1[p] = obj2[p];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj1;\n\t}\n\t/** @private */\n\tfunction compare(s1, s2) {\n\t\tif (s1 === s2) { return true; }\n\t\tif (s1 && !s2 || !s1 && s2) { return false; }\n\t\tif ((s1 && s1.constructor === String) || (s2 && s2.constructor === String)) { return false; }\n\t\tif (s1 instanceof Array || s2 instanceof Array) {\n\t\t\tif (!(s1 instanceof Array && s2 instanceof Array)) { return false; }\n\t\t\tif (s1.length !== s2.length) { return false; }\n\t\t\tfor (var i = 0; i < s1.length; i++) {\n\t\t\t\tif (!compare(s1[i], s2[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (!(s1 instanceof Object) || !(s2 instanceof Object)) { return false; }\n\t\tvar p;\n\t\tfor (p in s1) {\n\t\t\tif (s1.hasOwnProperty(p)) {\n\t\t\t\tif (!s2.hasOwnProperty(p)) { return false; }\n\t\t\t\tif (!compare(s1[p], s2[p])) {return false; }\n\t\t\t}\n\t\t}\n\t\tfor (p in s2) {\n\t\t\tif (!s1.hasOwnProperty(p)) { return false; }\n\t\t}\n\t\treturn true;\n\t}\n\t/** @private */\n\tfunction convertDelimiter(text, addTextFunc, addDelimiterFunc) {\n\t\tvar cr = 0, lf = 0, index = 0, length = text.length;\n\t\twhile (index < length) {\n\t\t\tif (cr !== -1 && cr <= index) { cr = text.indexOf(\"\\r\", index); } //$NON-NLS-0$\n\t\t\tif (lf !== -1 && lf <= index) { lf = text.indexOf(\"\\n\", index); } //$NON-NLS-0$\n\t\t\tvar start = index, end;\n\t\t\tif (lf === -1 && cr === -1) {\n\t\t\t\taddTextFunc(text.substring(index));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cr !== -1 && lf !== -1) {\n\t\t\t\tif (cr + 1 === lf) {\n\t\t\t\t\tend = cr;\n\t\t\t\t\tindex = lf + 1;\n\t\t\t\t} else {\n\t\t\t\t\tend = cr < lf ? cr : lf;\n\t\t\t\t\tindex = (cr < lf ? cr : lf) + 1;\n\t\t\t\t}\n\t\t\t} else if (cr !== -1) {\n\t\t\t\tend = cr;\n\t\t\t\tindex = cr + 1;\n\t\t\t} else {\n\t\t\t\tend = lf;\n\t\t\t\tindex = lf + 1;\n\t\t\t}\n\t\t\taddTextFunc(text.substring(start, end));\n\t\t\tif (addDelimiterFunc) {\n\t\t\t\taddDelimiterFunc();\n\t\t\t} else {\n\t\t\t\tif (index === length) addTextFunc(\"\");\n\t\t\t}\n\t\t}\n\t}\n\t/** @private */\n\tfunction getBorder(node) {\n\t\tvar left,top,right,bottom;\n\t\tvar window = getWindow(node.ownerDocument);\n\t\tif (window.getComputedStyle) {\n\t\t\tvar style = window.getComputedStyle(node, null);\n\t\t\tleft = style.getPropertyValue(\"border-left-width\"); //$NON-NLS-0$\n\t\t\ttop = style.getPropertyValue(\"border-top-width\"); //$NON-NLS-0$\n\t\t\tright = style.getPropertyValue(\"border-right-width\"); //$NON-NLS-0$\n\t\t\tbottom = style.getPropertyValue(\"border-bottom-width\"); //$NON-NLS-0$\n\t\t} else if (node.currentStyle) {\n\t\t\tleft = node.currentStyle.borderLeftWidth;\n\t\t\ttop = node.currentStyle.borderTopWidth;\n\t\t\tright = node.currentStyle.borderRightWidth;\n\t\t\tbottom = node.currentStyle.borderBottomWidth;\n\t\t}\n\t\treturn {\n\t\t\tleft: parseInt(left, 10) || 0,\n\t\t\ttop: parseInt(top, 10) || 0,\n\t\t\tright: parseInt(right, 10) || 0,\n\t\t\tbottom: parseInt(bottom, 10) || 0\n\t\t};\n\t}\n\t/** @private */\n\tfunction getPadding(node) {\n\t\tvar left,top,right,bottom;\n\t\tvar window = getWindow(node.ownerDocument);\n\t\tif (window.getComputedStyle) {\n\t\t\tvar style = window.getComputedStyle(node, null);\n\t\t\tleft = style.getPropertyValue(\"padding-left\"); //$NON-NLS-0$\n\t\t\ttop = style.getPropertyValue(\"padding-top\"); //$NON-NLS-0$\n\t\t\tright = style.getPropertyValue(\"padding-right\"); //$NON-NLS-0$\n\t\t\tbottom = style.getPropertyValue(\"padding-bottom\"); //$NON-NLS-0$\n\t\t} else if (node.currentStyle) {\n\t\t\tleft = node.currentStyle.paddingLeft;\n\t\t\ttop = node.currentStyle.paddingTop;\n\t\t\tright = node.currentStyle.paddingRight;\n\t\t\tbottom = node.currentStyle.paddingBottom;\n\t\t}\n\t\treturn {\n\t\t\tleft: parseInt(left, 10) || 0, \n\t\t\ttop: parseInt(top, 10) || 0,\n\t\t\tright: parseInt(right, 10) || 0,\n\t\t\tbottom: parseInt(bottom, 10) || 0\n\t\t};\n\t}\n\t/** @private */\n\tfunction getLineTrim(line) {\n\t\tvar trim = line._trim;\n\t\tif (!trim) {\n\t\t\ttrim = getPadding(line);\n\t\t\tvar border = getBorder(line);\n\t\t\ttrim.left += border.left;\n\t\t\ttrim.top += border.top;\n\t\t\ttrim.right += border.right;\n\t\t\ttrim.bottom += border.bottom;\n\t\t\tline._trim = trim;\n\t\t}\n\t\treturn trim;\n\t}\n\t/** @private */\n\tfunction DOMReady(document, parent, className, callback) {\n\t\tclassName = \"_\" + className + \"DOMReady\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\tparent.className = parent.className ? parent.className + \" \" + className : className; //$NON-NLS-0$\n\t\tparent.__DOMReady = callback;\n\t\tvar id = className + \"Style\"; //$NON-NLS-0$\n\t\tif (document.getElementById(id)) { return; }\n\t\tvar animationName = className + \"Animation\"; //$NON-NLS-0$\n\t\tfunction insertListener(event) {\n\t\t\tif (event.animationName === animationName) {\n\t\t\t\tvar target = event.target;\n\t\t\t\tif (typeof target.__DOMReady === \"function\") { //$NON-NLS-0$\n\t\t\t\t\tgetWindow(document).setTimeout(function() {\n\t\t\t\t\t\ttarget.__DOMReady();\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction template(className, animationName) {\n\t\t\tvar props = [\"\", \"-webkit-\", \"-moz-\", \"-ms-\", \"-o-\"]; //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar frames = \"\", classRule = \"body .\" + className + \" {\\n\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tfor (var i=0; i<props.length; i++) {\n\t\t\t\tframes +=\n\t\t\t\t\"@\" + props[i] + \"keyframes \" + animationName + \" {\\n\" + //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"from { opacity: 0.99; }\\n\" + //$NON-NLS-0$\n\t\t\t\t\"to { opacity: 1; }\\n\" + //$NON-NLS-0$\n\t\t\t\t\"}\\n\"; //$NON-NLS-0$\n\t\t\t\tclassRule +=\n\t\t\t\tprops[i] + \"animation-duration: 0.001s;\\n\" + //$NON-NLS-0$\n\t\t\t\tprops[i] + \"animation-name: \" + animationName + \";\\n\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}\n\t\t\tclassRule += \"}\"; //$NON-NLS-0$\n\t\t\treturn frames + classRule;\n\t\t}\n\t\taddHandler(document, \"animationstart\", insertListener, false); //$NON-NLS-0$\n\t\taddHandler(document, \"MSAnimationStart\", insertListener, false);  //$NON-NLS-0$\n\t\taddHandler(document, \"webkitAnimationStart\", insertListener, false); //$NON-NLS-0$\n\t\tvar style = document.createElement(\"style\"); //$NON-NLS-0$\n\t\tstyle.id = id;\n\t\tvar head = document.getElementsByTagName(\"head\")[0] || document.documentElement; //$NON-NLS-0$\n\t\tstyle.appendChild(document.createTextNode(template(className, animationName)));\n\t\thead.insertBefore(style, head.firstChild);\n\t}\n\t\n\tvar Animation = textUtil.Animation;\n\t\n\t/** \n\t * Constructs a new Selection object.\n\t * \n\t * @class A Selection represents a range of selected text in the view.\n\t * @name orion.editor.Selection\n\t */\n\tfunction Selection (start, end, caret) {\n\t\t/**\n\t\t * The selection start offset.\n\t\t *\n\t\t * @name orion.editor.Selection#start\n\t\t */\n\t\tthis.start = start;\n\t\t/**\n\t\t * The selection end offset.\n\t\t *\n\t\t * @name orion.editor.Selection#end\n\t\t */\n\t\tthis.end = end;\n\t\t/** @private */\n\t\tthis.caret = caret; //true if the start, false if the caret is at end\n\t\t/** @private */\n\t\tthis._columnX = -1;\n\t}\n\t/** @private */\n\tSelection.compare = function(s1, s2) {\n\t\tif (s1.length !== s2.length) return false;\n\t\tfor (var i = 0; i < s1.length; i++) {\n\t\t\tif (!s1[i].equals(s2[i])) return false;\n\t\t}\n\t\treturn true;\n\t};\n\tSelection.editing = function(selections, back) {\n\t\tvar i;\n\t\tif (back) {\n\t\t\tfor (i = selections.length - 1; i >= 0; i--) {\n\t\t\t\tif (selections[i]._editing) return selections[i];\n\t\t\t}\n\t\t\treturn selections[selections.length - 1];\n\t\t}\n\t\tfor (i = 0; i < selections.length; i++) {\n\t\t\tif (selections[i]._editing) return selections[i];\n\t\t}\n\t\treturn selections[0];\n\t};\n\t/** @private */\n\tSelection.convert = function(selections) {\n\t\tif (selections.length === 1) return selections[0];\n\t\treturn selections;\n\t};\n\t/** @private */\n\tSelection.contains = function(selections, offset) {\n\t\treturn selections.some(function(selection) {\n\t\t\treturn selection.contains(offset);\n\t\t});\n\t};\n\t/** @private */\n\tSelection.merge = function(selections) {\n\t\tif (selections.length <= 1) return selections;\n\t\tselections.sort(function(a, b) {\n\t\t\treturn a.start - b.start;\n\t\t});\n\t\tvar result = [];\n\t\tvar current = selections[0];\n\t\tfor (var i = 1; i < selections.length; i++) {\n\t\t\tif (selections[i].start >= current.end || current._editing || selections[i]._editing) {\n\t\t\t\tresult.push(current);\n\t\t\t\tcurrent = selections[i];\n\t\t\t} else {\n\t\t\t\tcurrent.end = Math.max(current.end, selections[i].end);\n\t\t\t}\n\t\t}\n\t\tresult.push(current);\n\t\treturn result;\n\t};\n\tSelection.prototype = /** @lends orion.editor.Selection.prototype */ {\n\t\t/** @private */\n\t\tclone: function() {\n\t\t\tvar result = new Selection(this.start, this.end, this.caret);\n\t\t\tresult._columnX = this._columnX;\n\t\t\tresult._editing = this._editing;\n\t\t\tresult._docX = this._docX;\n\t\t\treturn result;\n\t\t},\n\t\t/** @private */\n\t\tcontains: function(offset) {\n\t\t\tif (this.start <= offset && offset < this.end) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t/** @private */\n\t\tcollapse: function() {\n\t\t\tif (this.caret) {\n\t\t\t\tthis.end = this.start;\n\t\t\t} else {\n\t\t\t\tthis.start = this.end;\n\t\t\t}\n\t\t},\n\t\t/** @private */\n\t\textend: function (offset) {\n\t\t\tif (this.caret) {\n\t\t\t\tthis.start = offset;\n\t\t\t} else {\n\t\t\t\tthis.end = offset;\n\t\t\t}\n\t\t\tif (this.start > this.end) {\n\t\t\t\tvar tmp = this.start;\n\t\t\t\tthis.start = this.end;\n\t\t\t\tthis.end = tmp;\n\t\t\t\tthis.caret = !this.caret;\n\t\t\t}\n\t\t},\n\t\t/** @private */\n\t\tsetCaret: function(offset) {\n\t\t\tthis.start = offset;\n\t\t\tthis.end = offset;\n\t\t\tthis.caret = false;\n\t\t},\n\t\t/** @private */\n\t\tgetCaret: function() {\n\t\t\treturn this.caret ? this.start : this.end;\n\t\t},\n\t\t/** @private */\n\t\tgetAnchor: function() {\n\t\t\treturn this.caret ? this.end : this.start;\n\t\t},\n\t\t/** @private */\n\t\tgetOrientedSelection: function() {\n\t\t\treturn {start: this.getAnchor(), end: this.getCaret()};\n\t\t},\n\t\t/** @private */\n\t\ttoString: function() {\n\t\t\treturn \"start=\" + this.start + \" end=\" + this.end + (this.caret ? \" caret is at start\" : \" caret is at end\"); //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t},\n\t\t/** @private */\n\t\tisEmpty: function() {\n\t\t\treturn this.start === this.end;\n\t\t},\n\t\t/** @private */\n\t\tequals: function(object) {\n\t\t\treturn this.caret === object.caret && this.start === object.start && this.end === object.end && this._editing === object._editing;\n\t\t}\n\t};\n\t/** @private */\n\tfunction DOMSelection (view) {\n\t\tthis._view = view;\n\t\tthis._divs = [];\n\t\tvar parent = view._clipDiv || view._rootDiv;\n\t\tfor (var i=0; i<3; i++) {\n\t\t\tvar div = view._createSelectionDiv();\n\t\t\tparent.appendChild(div);\n\t\t\tthis._divs.push(div);\n\t\t}\n\t}\n\tDOMSelection.prototype = /** @lends orion.editor.DOMSelection.prototype */ {\n\t\t/** @private */\n\t\tdestroy: function() {\n\t\t\tif (!this._divs) return;\n\t\t\tthis._divs.forEach(function(div) {\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t});\n\t\t\tthis._divs = null;\n\t\t},\n\t\t/** @private */\n\t\tsetPrimary: function(enabled) {\n\t\t\tthis.primary = enabled;\n\t\t},\n\t\t/** @private */\n\t\tupdate: function() {\n\t\t\tvar view = this._view;\n\t\t\tvar primary = this.primary;\n\t\t\tvar focused = view._hasFocus;\n\t\t\tvar visible = view._cursorVisible;\n\t\t\tvar cursor = !this.primary && this._selection && this._selection.isEmpty();\n\t\t\tvar className;\n\t\t\tif (cursor) {\n\t\t\t\tclassName = \"textviewSelectionCaret\"; //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tclassName = focused ? \"textviewSelection\" : \"textviewSelectionUnfocused\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._divs[0].style.visibility = (cursor && visible && focused) || !cursor ? \"visible\" : \"hidden\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tthis._divs[0].style.zIndex = visible && cursor ? \"2\" : \"0\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tthis._divs.forEach(function(div) {\n\t\t\t\tdiv.className = className;\n\t\t\t\tif (util.isWebkit && primary) {\n\t\t\t\t\tdiv.style.background = focused ? \"transparent\" : \"\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/** @private */\n\t\tsetSelection: function (selection) {\n\t\t\tthis._selection = selection;\n\t\t\tthis.update();\n\t\t\tvar view = this._view;\n\t\t\tvar model = view._model;\n\t\t\tvar startLine = model.getLineAtOffset(selection.start);\n\t\t\tvar endLine = model.getLineAtOffset(selection.end);\n\t\t\tvar firstNode = view._getLineNext();\n\t\t\t/*\n\t\t\t* Bug in Firefox. For some reason, after a update page sometimes the \n\t\t\t* firstChild returns null incorrectly. The fix is to ignore show selection.\n\t\t\t*/\n\t\t\tif (!firstNode) { return; }\n\t\t\tvar lastNode = view._getLinePrevious();\n\t\t\t\n\t\t\tvar topNode, bottomNode, topOffset, bottomOffset;\n\t\t\tif (startLine < firstNode.lineIndex) {\n\t\t\t\ttopNode = firstNode;\n\t\t\t\ttopOffset = model.getLineStart(firstNode.lineIndex);\n\t\t\t} else if (startLine > lastNode.lineIndex) {\n\t\t\t\ttopNode = lastNode;\n\t\t\t\ttopOffset = model.getLineStart(lastNode.lineIndex);\n\t\t\t} else {\n\t\t\t\ttopNode = view._getLineNode(startLine);\n\t\t\t\ttopOffset = selection.start;\n\t\t\t}\n\n\t\t\tif (endLine < firstNode.lineIndex) {\n\t\t\t\tbottomNode = firstNode;\n\t\t\t\tbottomOffset = model.getLineStart(firstNode.lineIndex);\n\t\t\t} else if (endLine > lastNode.lineIndex) {\n\t\t\t\tbottomNode = lastNode;\n\t\t\t\tbottomOffset = model.getLineStart(lastNode.lineIndex);\n\t\t\t} else {\n\t\t\t\tbottomNode = view._getLineNode(endLine);\n\t\t\t\tbottomOffset = selection.end;\n\t\t\t}\n\t\t\tthis._setDOMSelection(topNode, topOffset, bottomNode, bottomOffset, selection.caret);\n\t\t},\n\t\t/** @private */\n\t\t_setDOMSelection: function (startNode, startOffset, endNode, endOffset, startCaret) {\n\t\t\tthis._setDOMFullSelection(startNode, startOffset, endNode, endOffset);\n\t\t\tif (!this.primary) { return; }\n\t\t\tvar view = this._view;\n\t\t\tvar start = startNode._line.getNodeOffset(startOffset);\n\t\t\tvar end = endNode._line.getNodeOffset(endOffset);\n\t\t\tif (!start.node || !end.node) return;\n\t\t\tvar range;\n\t\t\tvar window = view._getWindow();\n\t\t\tvar document = view._parent.ownerDocument;\n\t\t\tif (window.getSelection) {\n\t\t\t\t//W3C\n\t\t\t\tvar sel = window.getSelection();\n\t\t\t\trange = document.createRange();\n\t\t\t\trange.setStart(start.node, start.offset);\n\t\t\t\trange.setEnd(end.node, end.offset);\n\t\t\t\tif (view._hasFocus && (\n\t\t\t\t\tsel.anchorNode !== start.node || sel.anchorOffset !== start.offset ||\n\t\t\t\t\tsel.focusNode !== end.node || sel.focusOffset !== end.offset ||\n\t\t\t\t\tsel.anchorNode !== end.node || sel.anchorOffset !== end.offset ||\n\t\t\t\t\tsel.focusNode !== start.node || sel.focusOffset !== start.offset))\n\t\t\t\t{\n\t\t\t\t\tview._anchorNode = start.node;\n\t\t\t\t\tview._anchorOffset = start.offset;\n\t\t\t\t\tview._focusNode = end.node;\n\t\t\t\t\tview._focusOffset = end.offset;\n\t\t\t\t\tview._ignoreSelect = false;\n\t\t\t\t\tif (sel.rangeCount > 0) { sel.removeAllRanges(); }\n\t\t\t\t\tsel.addRange(range);\n\t\t\t\t\tview._ignoreSelect = true;\n\t\t\t\t}\n\t\t\t\tif (view._cursorDiv) {\n\t\t\t\t\trange = document.createRange();\n\t\t\t\t\tif (startCaret) {\n\t\t\t\t\t\trange.setStart(start.node, start.offset);\n\t\t\t\t\t\trange.setEnd(start.node, start.offset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trange.setStart(end.node, end.offset);\n\t\t\t\t\t\trange.setEnd(end.node, end.offset);\n\t\t\t\t\t}\n\t\t\t\t\tvar rect = range.getClientRects()[0];\n\t\t\t\t\tvar cursorParent = view._cursorDiv.parentNode;\n\t\t\t\t\tvar clientRect = cursorParent.getBoundingClientRect();\n\t\t\t\t\tif (rect && clientRect) {\n\t\t\t\t\t\tview._cursorDiv.style.top = (rect.top - clientRect.top + cursorParent.scrollTop) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t\tview._cursorDiv.style.left = (rect.left - clientRect.left + cursorParent.scrollLeft) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (document.selection) {\n\t\t\t\tif (!view._hasFocus) { return; }\n\t\t\t\t//IE < 9\n\t\t\t\tvar body = document.body;\n\n\t\t\t\t/*\n\t\t\t\t* Bug in IE. For some reason when text is deselected the overflow\n\t\t\t\t* selection at the end of some lines does not get redrawn.  The\n\t\t\t\t* fix is to create a DOM element in the body to force a redraw.\n\t\t\t\t*/\n\t\t\t\tvar child = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tbody.appendChild(child);\n\t\t\t\tbody.removeChild(child);\n\t\t\t\t\n\t\t\t\trange = body.createTextRange();\n\t\t\t\trange.moveToElementText(start.node.parentNode);\n\t\t\t\trange.moveStart(\"character\", start.offset); //$NON-NLS-0$\n\t\t\t\tvar endRange = body.createTextRange();\n\t\t\t\tendRange.moveToElementText(end.node.parentNode);\n\t\t\t\tendRange.moveStart(\"character\", end.offset); //$NON-NLS-0$\n\t\t\t\trange.setEndPoint(\"EndToStart\", endRange); //$NON-NLS-0$\n\t\t\t\tview._ignoreSelect = false;\n\t\t\t\trange.select();\n\t\t\t\tview._ignoreSelect = true;\n\t\t\t}\n\t\t},\n\t\t/** @private */\n\t\t_setDOMFullSelection: function(startNode, startOffset, endNode, endOffset) {\n\t\t\tthis._divs.forEach(function(div) {\n\t\t\t\tdiv.style.width = div.style.height = \"0px\"; //$NON-NLS-0$\n\t\t\t});\n\t\t\tvar view = this._view;\n\t\t\tif (!view._fullSelection) { return; }\n\t\t\tif (util.isIOS) { return; }\n\t\t\tif (startNode === endNode && startOffset === endOffset && this.primary) { return; }\n\t\t\tvar viewPad = view._getViewPadding();\n\t\t\tvar clientRect = view._clientDiv.getBoundingClientRect();\n\t\t\tvar viewRect = view._viewDiv.getBoundingClientRect();\n\t\t\tvar left = viewRect.left + viewPad.left;\n\t\t\tvar right = clientRect.right;\n\t\t\tvar top = viewRect.top + viewPad.top;\n\t\t\tvar bottom = clientRect.bottom;\n\t\t\tvar hd = 0, vd = 0;\n\t\t\tif (view._clipDiv) {\n\t\t\t\tvar clipRect = view._clipDiv.getBoundingClientRect();\n\t\t\t\thd = clipRect.left - view._clipDiv.scrollLeft;\n\t\t\t\tvd = clipRect.top;\n\t\t\t} else {\n\t\t\t\tvar rootpRect = view._rootDiv.getBoundingClientRect();\n\t\t\t\thd = rootpRect.left;\n\t\t\t\tvd = rootpRect.top;\n\t\t\t}\n\t\t\tview._ignoreDOMSelection = true;\n\t\t\tvar startLine = new TextLine(view, startNode.lineIndex, startNode);\n\t\t\tvar startRect = startLine.getBoundingClientRect(startOffset, false);\n\t\t\tvar l = startRect.left, endLine, endRect;\n\t\t\tif (startNode === endNode && startOffset === endOffset) {\n\t\t\t\tendLine = startLine;\n\t\t\t\tendRect = startRect;\n\t\t\t} else {\n\t\t\t\tendLine = new TextLine(view, endNode.lineIndex, endNode);\n\t\t\t\tendRect = endLine.getBoundingClientRect(endOffset, false);\n\t\t\t}\n\t\t\tvar r = endRect.left;\n\t\t\tview._ignoreDOMSelection = false;\n\t\t\tvar sel1Div = this._divs[0];\n\t\t\tvar sel1Left = Math.min(right, Math.max(left, l));\n\t\t\tvar sel1Top = Math.min(bottom, Math.max(top, startRect.top));\n\t\t\tvar sel1Right = right;\n\t\t\tvar sel1Bottom = Math.min(bottom, Math.max(top, startRect.bottom));\n\t\t\tsel1Div.style.left = (sel1Left - hd) + \"px\"; //$NON-NLS-0$\n\t\t\tsel1Div.style.top = (sel1Top - vd) + \"px\"; //$NON-NLS-0$\n\t\t\tsel1Div.style.width = Math.max(0, sel1Right - sel1Left) + \"px\"; //$NON-NLS-0$\n\t\t\tsel1Div.style.height = Math.max(0, sel1Bottom - sel1Top) + \"px\"; //$NON-NLS-0$\n\t\t\tif (startNode.lineIndex === endNode.lineIndex) {\n\t\t\t\tsel1Right = Math.min(r, right);\n\t\t\t\tsel1Div.style.width = Math.max(this.primary ? 0 : 1, sel1Right - sel1Left) + \"px\"; //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tvar sel3Left = left;\n\t\t\t\tvar sel3Top = Math.min(bottom, Math.max(top, endRect.top));\n\t\t\t\tvar sel3Right = Math.min(right, Math.max(left, r));\n\t\t\t\tvar sel3Bottom = Math.min(bottom, Math.max(top, endRect.bottom));\n\t\t\t\tvar sel3Div = this._divs[2];\n\t\t\t\tsel3Div.style.left = (sel3Left - hd) + \"px\"; //$NON-NLS-0$\n\t\t\t\tsel3Div.style.top = (sel3Top - vd) + \"px\"; //$NON-NLS-0$\n\t\t\t\tsel3Div.style.width = Math.max(0, sel3Right - sel3Left) + \"px\"; //$NON-NLS-0$\n\t\t\t\tsel3Div.style.height = Math.max(0, sel3Bottom - sel3Top) + \"px\"; //$NON-NLS-0$\n\t\t\t\tif (Math.abs(startNode.lineIndex - endNode.lineIndex) > 1) {\n\t\t\t\t\tvar sel2Div = this._divs[1];\n\t\t\t\t\tsel2Div.style.left = (left - hd)  + \"px\"; //$NON-NLS-0$\n\t\t\t\t\tsel2Div.style.top = (sel1Bottom - vd) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\tsel2Div.style.width = Math.max(0, right - left) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\tsel2Div.style.height = Math.max(0, sel3Top - sel1Bottom) + \"px\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t/** @private */\n\tfunction TextRect (rect) {\n\t\tthis.left = rect.left;\n\t\tthis.top = rect.top;\n\t\tthis.right = rect.right;\n\t\tthis.bottom = rect.bottom;\n\t}\n\tTextRect.prototype = /** @lends orion.editor.TextRect.prototype */ {\n\t\t/** @private */\n\t\ttoString: function() {\n\t\t\treturn \"{l=\" + this.left + \", t=\" + this.top + \", r=\" + this.right + \", b=\" + this.bottom + \"}\"; //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t}\n\t};\n\t/** \n\t * Constructs a new TextLine object.\n\t * \n\t * @class A TextLine represents a line of text in the view.\n\t * @name orion.editor.TextLine\n\t * @private\n\t */\n\tfunction TextLine (view, lineIndex, lineDiv) {\n\t\t/**\n\t\t * The view.\n\t\t *\n\t\t * @name orion.editor.TextLine#view\n\t\t * @private\n\t\t */\n\t\tthis.view = view;\n\t\t/**\n\t\t * The line index.\n\t\t *\n\t\t * @name orion.editor.TextLine#lineIndex\n\t\t * @private\n\t\t */\n\t\tthis.lineIndex = lineIndex;\n\t\t\n\t\tthis._lineDiv = lineDiv;\n\t}\n\tTextLine.prototype = /** @lends orion.editor.TextLine.prototype */ {\n\t\t/** @private */\n\t\tcreate: function(parent, div) {\n\t\t\tif (this._lineDiv) { return; }\n\t\t\tvar child = this._lineDiv = this._createLine(parent, div, this.lineIndex);\n\t\t\tchild._line = this;\n\t\t\treturn child;\n\t\t},\n\t\t_createLine: function(parent, div, lineIndex) {\n\t\t\tvar view = this.view;\n\t\t\tvar model = view._model;\n\t\t\tvar lineText = model.getLine(lineIndex);\n\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\tvar e = {type:\"LineStyle\", textView: view, lineIndex: lineIndex, lineText: lineText, lineStart: lineStart}; //$NON-NLS-0$\n\t\t\tview.onLineStyle(e);\n\t\t\tvar document = parent.ownerDocument;\n\t\t\tvar lineDiv = div || util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tif (!div || !compare(div.viewStyle, e.style)) {\n\t\t\t\tapplyStyle(e.style, lineDiv, div);\n\t\t\t\tif (div) { div._trim = null; }\n\t\t\t\tlineDiv.viewStyle = e.style;\n\t\t\t\tlineDiv.setAttribute(\"role\", \"presentation\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}\n\t\t\tlineDiv.lineIndex = lineIndex;\n\t\t\t\n\t\t\tif (div && lineDiv.viewLineText === lineText && compare(e.ranges, lineDiv.viewRanges)) {\n\t\t\t\treturn lineDiv;\n\t\t\t}\n\t\t\tlineDiv.viewRanges = e.ranges;\n\t\t\tlineDiv.viewLineText = lineText;\n\t\t\t\n\t\t\tvar ranges = [];\n\t\t\tvar data = {tabOffset: 0, ranges: ranges};\n\t\t\tthis._createRanges(e.ranges, lineText, 0, lineText.length, lineStart, data);\n\t\t\t\n\t\t\t/*\n\t\t\t* A trailing span with a whitespace is added for three different reasons:\n\t\t\t* 1. Make sure the height of each line is the largest of the default font\n\t\t\t* in normal, italic, bold, and italic-bold.\n\t\t\t* 2. When full selection is off, Firefox, Opera and IE9 do not extend the \n\t\t\t* selection at the end of the line when the line is fully selected. \n\t\t\t* 3. The height of a div with only an empty span is zero.\n\t\t\t*/\n\t\t\tvar c = \" \"; //$NON-NLS-0$\n\t\t\tif (!view._fullSelection && util.isIE < 9) {\n\t\t\t\t/* \n\t\t\t\t* IE8 already selects extra space at end of a line fully selected,\n\t\t\t\t* adding another space at the end of the line causes the selection \n\t\t\t\t* to look too big. The fix is to use a zero-width space (\\uFEFF) instead. \n\t\t\t\t*/\n\t\t\t\tc = \"\\uFEFF\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tvar range = {text: c, style: view._metrics.largestFontStyle, ignoreChars: 1};\n\t\t\tif (ranges.length === 0 || !ranges[ranges.length - 1].style || ranges[ranges.length - 1].style.tagName !== \"div\") { //$NON-NLS-0$\n\t\t\t\tranges.push(range);\n\t\t\t} else {\n\t\t\t\tranges.splice(ranges.length - 1, 0, range);\n\t\t\t}\n\t\t\n\t\t\tvar span, style, oldSpan, oldStyle, text, oldText, end = 0, oldEnd = 0, next, i;\n\t\t\tif (util.isFirefox && lineText.length > 2000) {\n\t\t\t\tif (div) {\n\t\t\t\t\tlineDiv.innerHTML = \"\";\n\t\t\t\t\tdiv.lineWidth = undefined;\n\t\t\t\t}\n\t\t\t\tvar frag = document.createDocumentFragment();\n\t\t\t\tfor (i = 0; i < ranges.length; i++) {\n\t\t\t\t\trange = ranges[i];\n\t\t\t\t\ttext = range.text;\n\t\t\t\t\tstyle = range.style;\n\t\t\t\t\tspan = this._createSpan(lineDiv, text, style, range.ignoreChars);\n\t\t\t\t\tfrag.appendChild(span);\n\t\t\t\t}\n\t\t\t\tlineDiv.appendChild(frag);\n\t\t\t} else {\n\t\t\t\tvar changeCount, changeStart;\n\t\t\t\tif (div) {\n\t\t\t\t\tvar modelChangedEvent = div.modelChangedEvent;\n\t\t\t\t\tif (modelChangedEvent) {\n\t\t\t\t\t\tif (modelChangedEvent.removedLineCount === 0 && modelChangedEvent.addedLineCount === 0) {\n\t\t\t\t\t\t\tchangeStart = modelChangedEvent.start - lineStart;\n\t\t\t\t\t\t\tchangeCount = modelChangedEvent.addedCharCount - modelChangedEvent.removedCharCount;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchangeStart = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdiv.modelChangedEvent = undefined;\n\t\t\t\t\t}\n\t\t\t\t\toldSpan = div.firstChild;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < ranges.length; i++) {\n\t\t\t\t\trange = ranges[i];\n\t\t\t\t\ttext = range.text;\n\t\t\t\t\tend += text.length;\n\t\t\t\t\tstyle = range.style;\n\t\t\t\t\tif (oldSpan) {\n\t\t\t\t\t\toldText = oldSpan.firstChild.data;\n\t\t\t\t\t\toldStyle = oldSpan.viewStyle;\n\t\t\t\t\t\tif (oldText === text && compare(style, oldStyle)) {\n\t\t\t\t\t\t\toldEnd += oldText.length;\n\t\t\t\t\t\t\toldSpan._rectsCache = undefined;\n\t\t\t\t\t\t\tspan = oldSpan = oldSpan.nextSibling;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (oldSpan) {\n\t\t\t\t\t\t\t\tif (changeStart !== -1) {\n\t\t\t\t\t\t\t\t\tvar spanEnd = end;\n\t\t\t\t\t\t\t\t\tif (spanEnd >= changeStart) {\n\t\t\t\t\t\t\t\t\t\tspanEnd -= changeCount;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvar t = oldSpan.firstChild.data;\n\t\t\t\t\t\t\t\t\tvar length = t ? t.length : 0;\n\t\t\t\t\t\t\t\t\tif (oldEnd + length > spanEnd) { break; }\n\t\t\t\t\t\t\t\t\toldEnd += length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext = oldSpan.nextSibling;\n\t\t\t\t\t\t\t\tlineDiv.removeChild(oldSpan);\n\t\t\t\t\t\t\t\toldSpan = next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tspan = this._createSpan(lineDiv, text, style, range.ignoreChars);\n\t\t\t\t\tif (oldSpan) {\n\t\t\t\t\t\tlineDiv.insertBefore(span, oldSpan);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlineDiv.appendChild(span);\n\t\t\t\t\t}\n\t\t\t\t\tif (div) {\n\t\t\t\t\t\tdiv.lineWidth = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (div) {\n\t\t\t\t\tvar tmp = span ? span.nextSibling : null;\n\t\t\t\t\twhile (tmp) {\n\t\t\t\t\t\tnext = tmp.nextSibling;\n\t\t\t\t\t\tdiv.removeChild(tmp);\n\t\t\t\t\t\ttmp = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!lineDiv.parentNode) {\n\t\t\t\tparent.appendChild(lineDiv);\n\t\t\t}\n\t\t\treturn lineDiv;\n\t\t},\n\t\t_createRanges: function(ranges, text, start, end, lineStart, data) {\n\t\t\tif (start > end) { return; }\n\t\t\tif (ranges) {\n\t\t\t\tfor (var i = 0; i < ranges.length; i++) {\n\t\t\t\t\tvar range = ranges[i];\n\t\t\t\t\tif (range.end < lineStart + start) { continue; }\n\t\t\t\t\tvar styleStart = Math.max(lineStart + start, range.start) - lineStart;\n\t\t\t\t\tif (styleStart > end) { break; }\n\t\t\t\t\tvar styleEnd = Math.min(lineStart + end, range.end) - lineStart;\n\t\t\t\t\tif (styleStart <= styleEnd) {\n\t\t\t\t\t\tstyleStart = Math.max(start, styleStart);\n\t\t\t\t\t\tstyleEnd = Math.min(end, styleEnd);\n\t\t\t\t\t\tif (start < styleStart) {\n\t\t\t\t\t\t\tthis._createRange(text, start, styleStart, null, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!range.style || !range.style.unmergeable) {\n\t\t\t\t\t\t\twhile (i + 1 < ranges.length && ranges[i + 1].start - lineStart === styleEnd && compare(range.style, ranges[i + 1].style)) {\n\t\t\t\t\t\t\t\trange = ranges[i + 1];\n\t\t\t\t\t\t\t\tstyleEnd = Math.min(lineStart + end, range.end) - lineStart;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._createRange(text, styleStart, styleEnd, range.style, data);\n\t\t\t\t\t\tstart = styleEnd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (start < end) {\n\t\t\t\tthis._createRange(text, start, end, null, data);\n\t\t\t}\n\t\t},\n\t\t_createRange: function(text, start, end, style, data) {\n\t\t\tif (start > end) { return; }\n\t\t\tvar tabSize = this.view._customTabSize, range;\n\t\t\tif (tabSize && tabSize !== 8) {\n\t\t\t\tvar tabIndex = text.indexOf(\"\\t\", start); //$NON-NLS-0$\n\t\t\t\twhile (tabIndex !== -1 && tabIndex < end) {\n\t\t\t\t\tif (start < tabIndex) {\n\t\t\t\t\t\trange = {text: text.substring(start, tabIndex), style: style};\n\t\t\t\t\t\tdata.ranges.push(range);\n\t\t\t\t\t\tdata.tabOffset += range.text.length;\n\t\t\t\t\t}\n\t\t\t\t\tvar spacesCount = tabSize - (data.tabOffset % tabSize);\n\t\t\t\t\tif (spacesCount > 0) {\n\t\t\t\t\t\t//TODO hack to preserve tabs in getDOMText()\n\t\t\t\t\t\tvar spaces = \"\\u00A0\"; //$NON-NLS-0$\n\t\t\t\t\t\tfor (var i = 1; i < spacesCount; i++) {\n\t\t\t\t\t\t\tspaces += \" \"; //$NON-NLS-0$\n\t\t\t\t\t\t}\n\t\t\t\t\t\trange = {text: spaces, style: style, ignoreChars: spacesCount - 1};\n\t\t\t\t\t\tdata.ranges.push(range);\n\t\t\t\t\t\tdata.tabOffset += range.text.length;\n\t\t\t\t\t}\n\t\t\t\t\tstart = tabIndex + 1;\n\t\t\t\t\tif (start === end) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttabIndex = text.indexOf(\"\\t\", start); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (start <= end) {\n\t\t\t\trange = {text: text.substring(start, end), style: style};\n\t\t\t\tdata.ranges.push(range);\n\t\t\t\tdata.tabOffset += range.text.length;\n\t\t\t}\n\t\t},\n\t\t_createSpan: function(parent, text, style, ignoreChars) {\n\t\t\tvar view = this.view;\n\t\t\tvar tagName = \"span\"; //$NON-NLS-0$\n\t\t\tif (style && style.tagName) {\n\t\t\t\ttagName = style.tagName.toLowerCase();\n\t\t\t}\n\t\t\tvar isLink = tagName === \"a\"; //$NON-NLS-0$\n\t\t\tif (isLink) { this.hasLink = true; }\n\t\t\tif (isLink && !view._linksVisible) {\n\t\t\t\ttagName = \"span\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tvar document = parent.ownerDocument;\n\t\t\tvar child = util.createElement(parent.ownerDocument, tagName);\n\t\t\tchild.appendChild(document.createTextNode(style && style.text ? style.text : text));\n\t\t\tif (style && style.html) {\n\t\t\t\tchild.innerHTML = style.html;\n\t\t\t\tchild.ignore = true;\n\t\t\t} else if (style && style.node) {\n\t\t\t\tchild.appendChild(style.node);\n\t\t\t\tchild.ignore = true;\n\t\t\t}\n\t\t\tapplyStyle(style, child);\n\t\t\tif (tagName === \"a\") { //$NON-NLS-0$\n\t\t\t\tvar window = view._getWindow();\n\t\t\t\taddHandler(child, \"click\", function(e) { return view._handleLinkClick(e ? e : window.event); }, false); //$NON-NLS-0$\n\t\t\t}\n\t\t\tchild.viewStyle = style;\n\t\t\tif (ignoreChars) {\n\t\t\t\tchild.ignoreChars = ignoreChars;\n\t\t\t}\n\t\t\treturn child;\n\t\t},\n\t\t_ensureCreated: function() {\n\t\t\tif (this._lineDiv) { return this._lineDiv; }\n\t\t\treturn (this._createdDiv = this.create(this.view._clientDiv, null));\n\t\t},\n\t\t/** @private */\n\t\tgetBoundingClientRect: function(offset, absolute) {\n\t\t\tvar child = this._ensureCreated();\n\t\t\tvar view = this.view;\n\t\t\tif (offset === undefined) {\n\t\t\t\treturn this._getLineBoundingClientRect(child, true);\n\t\t\t}\n\t\t\tvar model = view._model;\n\t\t\tvar document = child.ownerDocument;\n\t\t\tvar lineIndex = this.lineIndex;\n\t\t\tvar result = null;\n\t\t\tif (offset < model.getLineEnd(lineIndex)) {\n\t\t\t\tvar lineOffset = model.getLineStart(lineIndex);\n\t\t\t\tthis.forEach(function(lineChild) {\n\t\t\t\t\tvar textNode = lineChild.firstChild;\n\t\t\t\t\tvar nodeLength = this._nodeLength(lineChild); \n\t\t\t\t\tif (lineOffset + nodeLength > offset) {\n\t\t\t\t\t\tvar index = offset - lineOffset;\n\t\t\t\t\t\tvar range;\n\t\t\t\t\t\tif (textNode.length === 1) {\n\t\t\t\t\t\t\tresult = new TextRect(lineChild.getBoundingClientRect());\n\t\t\t\t\t\t} else if (view._isRangeRects) {\n\t\t\t\t\t\t\trange = document.createRange();\n\t\t\t\t\t\t\trange.setStart(textNode, index);\n\t\t\t\t\t\t\trange.setEnd(textNode, index + 1);\n\t\t\t\t\t\t\tresult = new TextRect(range.getBoundingClientRect());\n\t\t\t\t\t\t} else if (util.isIE) {\n\t\t\t\t\t\t\trange = document.body.createTextRange();\n\t\t\t\t\t\t\trange.moveToElementText(lineChild);\n\t\t\t\t\t\t\trange.collapse();\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t* Bug in IE8. TextRange.getClientRects() and TextRange.getBoundingClientRect() fails\n\t\t\t\t\t\t\t* if the line child is not the first element in the line and if the start offset is 0. \n\t\t\t\t\t\t\t* The fix is to use Node.getClientRects() left edge instead.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tvar fixIE8 = index === 0 && util.isIE === 8;\n\t\t\t\t\t\t\tif (fixIE8) { index = 1; }\n\t\t\t\t\t\t\trange.moveEnd(\"character\", index + 1); //$NON-NLS-0$\n\t\t\t\t\t\t\trange.moveStart(\"character\", index); //$NON-NLS-0$\n\t\t\t\t\t\t\tresult = new TextRect(range.getBoundingClientRect());\n\t\t\t\t\t\t\tif (fixIE8) {\n\t\t\t\t\t\t\t\tresult.left = lineChild.getClientRects()[0].left;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar text = textNode.data;\n\t\t\t\t\t\t\tlineChild.removeChild(textNode);\n\t\t\t\t\t\t\tlineChild.appendChild(document.createTextNode(text.substring(0, index)));\n\t\t\t\t\t\t\tvar span = util.createElement(document, \"span\"); //$NON-NLS-0$\n\t\t\t\t\t\t\tspan.appendChild(document.createTextNode(text.substring(index, index + 1)));\n\t\t\t\t\t\t\tlineChild.appendChild(span);\n\t\t\t\t\t\t\tlineChild.appendChild(document.createTextNode(text.substring(index + 1)));\n\t\t\t\t\t\t\tresult = new TextRect(span.getBoundingClientRect());\n\t\t\t\t\t\t\tlineChild.innerHTML = \"\";\n\t\t\t\t\t\t\tlineChild.appendChild(textNode);\n\t\t\t\t\t\t\tif (!this._createdDiv) {\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * Removing the element node that holds the selection start or end\n\t\t\t\t\t\t\t\t * causes the selection to be lost. The fix is to detect this case\n\t\t\t\t\t\t\t\t * and restore the selection. \n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvar s = view._getSelections()[0];\n\t\t\t\t\t\t\t\tif ((lineOffset <= s.start && s.start < lineOffset + nodeLength) ||  (lineOffset <= s.end && s.end < lineOffset + nodeLength)) {\n\t\t\t\t\t\t\t\t\tview._updateDOMSelection();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (util.isIE < 11) {\n\t\t\t\t\t\t\tvar window = getWindow(child.ownerDocument);\n\t\t\t\t\t\t\tvar xFactor = window.screen.logicalXDPI / window.screen.deviceXDPI;\n\t\t\t\t\t\t\tvar yFactor = window.screen.logicalYDPI / window.screen.deviceYDPI;\n\t\t\t\t\t\t\tresult.left = result.left * xFactor;\n\t\t\t\t\t\t\tresult.right = result.right * xFactor;\n\t\t\t\t\t\t\tresult.top = result.top * yFactor;\n\t\t\t\t\t\t\tresult.bottom = result.bottom * yFactor;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tlineOffset += nodeLength;\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar rect = this.getBoundingClientRect();\n\t\t\tif (!result) {\n\t\t\t\tif (view._wrapMode) {\n\t\t\t\t\tvar rects = this.getClientRects();\n\t\t\t\t\tresult = rects[rects.length - 1];\n\t\t\t\t\tresult.left = result.right;\n\t\t\t\t\tresult.left += rect.left;\n\t\t\t\t\tresult.top += rect.top;\n\t\t\t\t\tresult.right += rect.left;\n\t\t\t\t\tresult.bottom += rect.top;\n\t\t\t\t} else {\n\t\t\t\t\tresult = new TextRect(rect);\n\t\t\t\t\tresult.left = result.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (absolute || absolute === undefined) {\n\t\t\t\tresult.left -= rect.left;\n\t\t\t\tresult.top -= rect.top;\n\t\t\t\tresult.right -= rect.left;\n\t\t\t\tresult.bottom -= rect.top;\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tforEach: function(callback) {\n\t\t\tvar child = this._ensureCreated();\n\t\t\tvar lineChild = child.firstChild;\n\t\t\twhile (lineChild) {\n\t\t\t\tvar next = lineChild.nextSibling;\n\t\t\t\tif (!lineChild.ignore) {\n\t\t\t\t\tif (!callback.call(this, lineChild)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlineChild = next;\n\t\t\t}\n\t\t},\n\t\t/** @private */\n\t\t_getClientRects: function(element, parentRect) {\n\t\t\tvar rects, newRects, rect, i;\n\t\t\tif (!element._rectsCache) {\n\t\t\t\trects = element.getClientRects();\n\t\t\t\tnewRects = newArray(rects.length);\n\t\t\t\tfor (i = 0; i<rects.length; i++) {\n\t\t\t\t\trect = newRects[i] = new TextRect(rects[i]);\n\t\t\t\t\trect.left -= parentRect.left;\n\t\t\t\t\trect.top -= parentRect.top;\n\t\t\t\t\trect.right -= parentRect.left;\n\t\t\t\t\trect.bottom -= parentRect.top;\n\t\t\t\t}\n\t\t\t\telement._rectsCache = newRects;\n\t\t\t}\n\t\t\trects = element._rectsCache;\n\t\t\tnewRects = [rects.length];\n\t\t\tfor (i = 0; i<rects.length; i++) {\n\t\t\t\tnewRects[i] = new TextRect(rects[i]);\n\t\t\t}\n\t\t\treturn newRects;\n\t\t},\n\t\tgetClientRects: function(lineIndex) {\n\t\t\tif (!this.view._wrapMode) { return [this.getBoundingClientRect()]; }\n\t\t\tvar child = this._ensureCreated();\n\t\t\t//TODO [perf] cache rects\n\t\t\tvar result = [];\n\t\t\tvar parentRect = child.getBoundingClientRect();\n\t\t\tthis.forEach(function(lineChild) {\n\t\t\t\tvar rects = this._getClientRects(lineChild, parentRect);\n\t\t\t\tfor (var i = 0; i < rects.length; i++) {\n\t\t\t\t\tvar rect = rects[i], j, r;\n\t\t\t\t\tif (rect.top === rect.bottom) { continue; }\n\t\t\t\t\tvar center = rect.top + (rect.bottom - rect.top) / 2;\n\t\t\t\t\tfor (j = 0; j < result.length; j++) {\n\t\t\t\t\t\tr = result[j];\n\t\t\t\t\t\tif ((r.top <= center && center < r.bottom)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j === result.length) {\n\t\t\t\t\t\tresult.push(rect);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rect.left < r.left) { r.left = rect.left; }\n\t\t\t\t\t\tif (rect.top < r.top) { r.top = rect.top; }\n\t\t\t\t\t\tif (rect.right > r.right) { r.right = rect.right; }\n\t\t\t\t\t\tif (rect.bottom > r.bottom) { r.bottom = rect.bottom; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tif (lineIndex !== undefined) {\n\t\t\t\treturn result[lineIndex];\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t/** @private */\n\t\t_getLineBoundingClientRect: function (child, noTrim) {\n\t\t\tvar rect = new TextRect(child.getBoundingClientRect());\n\t\t\tif (this.view._wrapMode) {\n\t\t\t} else {\n\t\t\t\trect.right = rect.left;\n\t\t\t\tvar lastChild = child.lastChild;\n\t\t\t\t//Remove any artificial trailing whitespace in the line\n\t\t\t\twhile (lastChild && lastChild.ignoreChars === lastChild.firstChild.length) {\n\t\t\t\t\tlastChild = lastChild.previousSibling;\n\t\t\t\t}\n\t\t\t\tif (lastChild) {\n\t\t\t\t\tvar lastRect = lastChild.getBoundingClientRect();\n\t\t\t\t\trect.right = lastRect.right + getLineTrim(child).right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (noTrim) {\n\t\t\t\tvar padding = getLineTrim(child);\n\t\t\t\trect.left = rect.left + padding.left;\n\t\t\t\trect.right = rect.right - padding.right;\n\t\t\t}\n\t\t\treturn rect;\n\t\t},\n\t\t/** @private */\n\t\tgetLineCount: function () {\n\t\t\tif (!this.view._wrapMode) { return 1; }\n\t\t\treturn this.getClientRects().length;\n\t\t},\n\t\t/** @private */\n\t\tgetLineIndex: function(offset) {\n\t\t\tif (!this.view._wrapMode) { return 0; }\n\t\t\tvar rects = this.getClientRects();\n\t\t\tvar rect = this.getBoundingClientRect(offset);\n\t\t\tvar center = rect.top + ((rect.bottom - rect.top) / 2);\n\t\t\tfor (var i = 0; i < rects.length; i++) {\n\t\t\t\tif (rects[i].top <= center && center < rects[i].bottom) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rects.length - 1;\n\t\t},\n\t\t/** @private */\n\t\tgetLineStart: function (lineIndex) {\n\t\t\tif (!this.view._wrapMode || lineIndex === 0) {\n\t\t\t\treturn this.view._model.getLineStart(this.lineIndex);\n\t\t\t}\n\t\t\tvar rects = this.getClientRects();\n\t\t\treturn this.getOffset(rects[lineIndex].left + 1, rects[lineIndex].top + 1);\n\t\t},\n\t\t_nodeLength: function(lineChild) {\n\t\t\tif (!lineChild || lineChild.ignore) return 0;\n\t\t\tvar length = lineChild.firstChild.length; \n\t\t\tif (lineChild.ignoreChars) {\n\t\t\t\tlength -= lineChild.ignoreChars;\n\t\t\t}\n\t\t\treturn length;\n\t\t},\n\t\tgetModelOffset: function(node, offset) {\n\t\t\tif (!node) { return 0; }\n\t\t\tvar lineOffset = 0;\n\t\t\tthis.forEach(function(lineChild) {\n\t\t\t\tvar textNode = lineChild.firstChild;\n\t\t\t\tif (textNode === node) {\n\t\t\t\t\tif (lineChild.ignoreChars) { lineOffset -= lineChild.ignoreChars; }\n\t\t\t\t\tlineOffset += offset;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (lineChild.ignoreChars) { lineOffset -= lineChild.ignoreChars; }\n\t\t\t\tlineOffset += textNode.data.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\treturn Math.max(0, lineOffset) + this.view._model.getLineStart(this.lineIndex);\n\t\t},\n\t\tgetNodeOffset: function(modelOffset) {\n\t\t\tvar offset = 0;\n\t\t\tvar lineNode, lineNodeOffset;\n\t\t\tvar model = this.view._model;\n\t\t\tvar lineStart = model.getLineStart(this.lineIndex);\n\t\t\tvar lineOffset = modelOffset - lineStart;\n\t\t\tvar end = model.getLineEnd(this.lineIndex) - lineStart;\n\t\t\tthis.forEach(function(lineChild) {\n\t\t\t\tvar node = lineChild.firstChild;\n\t\t\t\tvar nodeLength = this._nodeLength(lineChild);\n\t\t\t\tif (nodeLength + offset > lineOffset || offset + nodeLength >= end) {\n\t\t\t\t\tlineNode = node;\n\t\t\t\t\tlineNodeOffset = lineOffset - offset;\n\t\t\t\t\tif (lineChild.ignoreChars && nodeLength > 0 && lineNodeOffset === nodeLength) {\n\t\t\t\t\t\tlineNodeOffset += lineChild.ignoreChars; \n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\toffset += nodeLength;\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\treturn {node: lineNode, offset: lineNodeOffset};\n\t\t},\n\t\tgetText: function(offsetNode) {\n\t\t\tvar text = \"\", offset = 0;\n\t\t\tthis.forEach(function(lineChild) {\n\t\t\t\tvar textNode;\n\t\t\t\tif (lineChild.ignoreChars) {\n\t\t\t\t\ttextNode = lineChild.lastChild;\n\t\t\t\t\tvar ignored = 0, childText = [], childOffset = -1;\n\t\t\t\t\twhile (textNode) {\n\t\t\t\t\t\tvar data = textNode.data;\n\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\tfor (var i = data.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\t\tvar ch = data.substring(i, i + 1);\n\t\t\t\t\t\t\t\tif (ignored < lineChild.ignoreChars && (ch === \" \" || ch === \"\\uFEFF\")) { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\tignored++;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchildText.push(ch === \"\\u00A0\" ? \"\\t\" : ch); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (offsetNode === textNode) {\n\t\t\t\t\t\t\tchildOffset = childText.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttextNode = textNode.previousSibling;\n\t\t\t\t\t}\n\t\t\t\t\tchildText = childText.reverse().join(\"\");\n\t\t\t\t\tif (childOffset !== -1) {\n\t\t\t\t\t\toffset = text.length + childText.length - childOffset;\n\t\t\t\t\t}\n\t\t\t\t\ttext += childText;\n\t\t\t\t} else {\n\t\t\t\t\ttextNode = lineChild.firstChild;\n\t\t\t\t\twhile (textNode) {\n\t\t\t\t\t\tif (offsetNode === textNode) {\n\t\t\t\t\t\t\toffset = text.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttext += textNode.data;\n\t\t\t\t\t\ttextNode = textNode.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\treturn {text: text, offset: offset};\n\t\t},\n\t\t/** @private */\n\t\tgetOffset: function(x, y) {\n\t\t\tvar view = this.view;\n\t\t\tvar model = view._model;\n\t\t\tvar lineIndex = this.lineIndex;\n\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\tvar lineEnd = model.getLineEnd(lineIndex);\n\t\t\tif (lineStart === lineEnd) {\n\t\t\t\treturn lineStart;\n\t\t\t}\n\t\t\tvar child = this._ensureCreated();\n\t\t\tvar lineRect = this.getBoundingClientRect();\n\t\t\t\n\t\t\tvar self = this;\n\t\t\tfunction hitChild(lineChild, offset, rect) {\n\t\t\t\tvar textNode = lineChild.firstChild;\n\t\t\t\tvar nodeLength = self._nodeLength(lineChild);\n\t\t\t\tvar document = child.ownerDocument;\n\t\t\t\tvar window = getWindow(document);\n\t\t\t\tvar xFactor = util.isIE < 11 ? window.screen.logicalXDPI / window.screen.deviceXDPI : 1;\n\t\t\t\tvar yFactor = util.isIE < 11 ? window.screen.logicalYDPI / window.screen.deviceYDPI : 1;\n\t\t\t\tvar rangeLeft, rangeTop, rangeRight, rangeBottom;\n\t\t\t\tvar range, start, end;\n\t\t\t\tvar rl = rect.left + lineRect.left, fixIE8, rects1;\n\t\t\t\tif (util.isIE || view._isRangeRects) {\n\t\t\t\t\trange = view._isRangeRects ? document.createRange() : document.body.createTextRange();\n\t\t\t\t\tvar high = nodeLength;\n\t\t\t\t\tvar low = -1;\n\t\t\t\t\twhile ((high - low) > 1) {\n\t\t\t\t\t\tvar mid = Math.floor((high + low) / 2);\n\t\t\t\t\t\tstart = low + 1;\n\t\t\t\t\t\tend = mid === nodeLength - 1 && lineChild.ignoreChars ? textNode.length : mid + 1;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t* Bug in IE8. TextRange.getClientRects() and TextRange.getBoundingClientRect() fails\n\t\t\t\t\t\t* if the line child is not the first element in the line and if the start offset is 0. \n\t\t\t\t\t\t* The fix is to use Node.getClientRects() left edge instead.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tfixIE8 = start === 0 && util.isIE === 8;\n\t\t\t\t\t\tif (view._isRangeRects) {\n\t\t\t\t\t\t\trange.setStart(textNode, start);\n\t\t\t\t\t\t\trange.setEnd(textNode, end);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fixIE8) { start = 1; } \n\t\t\t\t\t\t\trange.moveToElementText(lineChild);\n\t\t\t\t\t\t\trange.move(\"character\", start); //$NON-NLS-0$\n\t\t\t\t\t\t\trange.moveEnd(\"character\", end - start); //$NON-NLS-0$\n\t\t\t\t\t\t}\n\t\t\t\t\t\trects1 = range.getClientRects();\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor (var k = 0; k < rects1.length; k++) {\n\t\t\t\t\t\t\trect = rects1[k];\n\t\t\t\t\t\t\trangeLeft = (fixIE8 ? rl : rect.left) * xFactor - lineRect.left;\n\t\t\t\t\t\t\trangeRight = rect.right * xFactor - lineRect.left;\n\t\t\t\t\t\t\trangeTop = rect.top * yFactor - lineRect.top;\n\t\t\t\t\t\t\trangeBottom = rect.bottom * yFactor - lineRect.top;\n\t\t\t\t\t\t\tif (rangeLeft <= x && x < rangeRight && (!view._wrapMode || (rangeTop <= y && y <= rangeBottom))) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (found) {\n\t\t\t\t\t\t\thigh = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlow = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toffset += high;\n\t\t\t\t\tstart = high;\n\t\t\t\t\tend = high === nodeLength - 1 && lineChild.ignoreChars ? textNode.length : Math.min(high + 1, textNode.length);\n\t\t\t\t\tif (view._isRangeRects) {\n\t\t\t\t\t\trange.setStart(textNode, start);\n\t\t\t\t\t\trange.setEnd(textNode, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trange.moveToElementText(lineChild);\n\t\t\t\t\t\trange.move(\"character\", start); //$NON-NLS-0$\n\t\t\t\t\t\trange.moveEnd(\"character\", end - start); //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t\trects1 = range.getClientRects();\n\t\t\t\t\tvar trailing = false;\n\t\t\t\t\tif (rects1.length > 0) {\n\t\t\t\t\t\trect = rects1[0];\n\t\t\t\t\t\trangeLeft = (fixIE8 ? rl : rect.left) * xFactor - lineRect.left;\n\t\t\t\t\t\trangeRight = rect.right * xFactor - lineRect.left;\n\t\t\t\t\t\t//TODO test for character trailing (wrong for bidi)\n\t\t\t\t\t\ttrailing = x > (rangeLeft + (rangeRight - rangeLeft) / 2);\n\t\t\t\t\t}\n\t\t\t\t\t// Handle Unicode surrogates\n\t\t\t\t\tvar offsetInLine = offset - lineStart;\n\t\t\t\t\tvar lineText = model.getLine(lineIndex);\n\t\t\t\t\tvar c = lineText.charCodeAt(offsetInLine);\n\t\t\t\t\tif (0xD800 <= c && c <= 0xDBFF && trailing) {\n\t\t\t\t\t\tif (offsetInLine < lineText.length) {\n\t\t\t\t\t\t\tc = lineText.charCodeAt(offsetInLine + 1);\n\t\t\t\t\t\t\tif (0xDC00 <= c && c <= 0xDFFF) {\n\t\t\t\t\t\t\t\toffset += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (0xDC00 <= c && c <= 0xDFFF && !trailing) {\n\t\t\t\t\t\tif (offsetInLine > 0) {\n\t\t\t\t\t\t\tc = lineText.charCodeAt(offsetInLine - 1);\n\t\t\t\t\t\t\tif (0xD800 <= c && c <= 0xDBFF) {\n\t\t\t\t\t\t\t\toffset -= 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (trailing) {\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar newText = [];\n\t\t\t\t\tfor (var q = 0; q < nodeLength; q++) {\n\t\t\t\t\t\tnewText.push(\"<span>\"); //$NON-NLS-0$\n\t\t\t\t\t\tif (q === nodeLength - 1) {\n\t\t\t\t\t\t\tnewText.push(textNode.data.substring(q));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewText.push(textNode.data.substring(q, q + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewText.push(\"</span>\"); //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t\tlineChild.innerHTML = newText.join(\"\");\n\t\t\t\t\tvar rangeChild = lineChild.firstChild;\n\t\t\t\t\twhile (rangeChild) {\n\t\t\t\t\t\trect = rangeChild.getBoundingClientRect();\n\t\t\t\t\t\trangeLeft = rect.left - lineRect.left;\n\t\t\t\t\t\trangeRight = rect.right - lineRect.left;\n\t\t\t\t\t\tif (rangeLeft <= x && x < rangeRight) {\n\t\t\t\t\t\t\t//TODO test for character trailing (wrong for bidi)\n\t\t\t\t\t\t\tif (x > rangeLeft + (rangeRight - rangeLeft) / 2) {\n\t\t\t\t\t\t\t\toffset++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\trangeChild = rangeChild.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t\tif (!self._createdDiv) {\n\t\t\t\t\t\tlineChild.innerHTML = \"\";\n\t\t\t\t\t\tlineChild.appendChild(textNode);\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Removing the element node that holds the selection start or end\n\t\t\t\t\t\t * causes the selection to be lost. The fix is to detect this case\n\t\t\t\t\t\t * and restore the selection. \n\t\t\t\t\t\t */\n\t\t\t\t\t\tvar s = view._getSelections()[0];\n\t\t\t\t\t\tif ((offset <= s.start && s.start < offset + nodeLength) || (offset <= s.end && s.end < offset + nodeLength)) {\n\t\t\t\t\t\t\tview._updateDOMSelection();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t\t\n\t\t\tvar rects, rect;\n\t\t\tif (view._wrapMode) {\n\t\t\t\trects = this.getClientRects();\n\t\t\t\tif (y < rects[0].top) {\n\t\t\t\t\ty = rects[0].top;\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < rects.length; i++) {\n\t\t\t\t\trect = rects[i];\n\t\t\t\t\tif (rect.top <= y && y < rect.bottom) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x < rect.left) { x = rect.left; }\n\t\t\t\tif (x > rect.right) { x = rect.right - 1; }\n\t\t\t} else {\n\t\t\t\tif (x < 0) { x = 0; }\n\t\t\t\tif (x > (lineRect.right - lineRect.left)) { x = lineRect.right - lineRect.left; }\n\t\t\t}\n\t\t\t\n\t\t\tfunction hitRects(child) {\n\t\t\t\tif (child.ignore) return null;\n\t\t\t\tvar rects1 = self._getClientRects(child, lineRect);\n\t\t\t\tfor (var j = 0; j < rects1.length; j++) {\n\t\t\t\t\tvar rect1 = rects1[j];\n\t\t\t\t\tif (rect1.left <= x && x < rect1.right && (!view._wrapMode || (rect1.top <= y && y <= rect1.bottom))) {\n\t\t\t\t\t\treturn rect1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tvar offset, lineChild;\n\t\t\tif (this._lastHitChild && this._lastHitChild.parentNode) {\n\t\t\t\t// Search last hit child first, then search around the last hit child\n\t\t\t\toffset = this._lastHitOffset;\n\t\t\t\tlineChild = this._lastHitChild;\n\t\t\t\trect = hitRects(lineChild);\n\t\t\t\tif (!rect ) {\n\t\t\t\t\tvar previousOffset = offset, nextOffset = offset + this._nodeLength(lineChild);\n\t\t\t\t\tvar previousChild = lineChild.previousSibling, nextChild = lineChild.nextSibling;\n\t\t\t\t\twhile (previousChild || nextChild) {\n\t\t\t\t\t\tif (previousChild) {\n\t\t\t\t\t\t\tpreviousOffset -= this._nodeLength(previousChild);\n\t\t\t\t\t\t\tif (rect = hitRects(previousChild)) {\n\t\t\t\t\t\t\t\tlineChild = previousChild;\n\t\t\t\t\t\t\t\toffset = previousOffset;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpreviousChild = previousChild.previousSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextChild) {\n\t\t\t\t\t\t\tif (rect = hitRects(nextChild)) {\n\t\t\t\t\t\t\t\tlineChild = nextChild;\n\t\t\t\t\t\t\t\toffset = nextOffset;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnextOffset += this._nodeLength(nextChild);\n\t\t\t\t\t\t\tnextChild = nextChild.nextSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Start searching from the beginning of the line\n\t\t\t\toffset = lineStart;\n\t\t\t\tthis.forEach(function(c) {\n\t\t\t\t\tlineChild = c;\n\t\t\t\t\tif (rect = hitRects(lineChild)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\toffset += this._nodeLength(lineChild);\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tif (lineChild && rect) {\n\t\t\t\t// Cache the last hit child\n\t\t\t\tthis._lastHitChild = lineChild;\n\t\t\t\tthis._lastHitOffset = offset;\n\n\t\t\t\toffset = hitChild(lineChild, offset, rect);\n\t\t\t}\n\n\t\t\treturn Math.min(lineEnd, Math.max(lineStart, offset));\n\t\t},\n\t\t/** @private */\n\t\tgetNextOffset: function (offset, data) {\n\t\t\tif (data.unit === \"line\") { //$NON-NLS-0$\n\t\t\t\tvar view = this.view;\n\t\t\t\tvar model = view._model;\n\t\t\t\tvar lineIndex = model.getLineAtOffset(offset);\n\t\t\t\tif (data.count > 0) {\n\t\t\t\t\tdata.count--;\n\t\t\t\t\treturn model.getLineEnd(lineIndex);\n\t\t\t\t}\n\t\t\t\tdata.count++;\n\t\t\t\treturn model.getLineStart(lineIndex);\n\t\t\t}\n\t\t\tif (data.unit === \"wordend\" || data.unit === \"wordWS\" || data.unit === \"wordendWS\") { //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\treturn this._getNextOffset_W3C(offset, data);\n\t\t\t}\n\t\t\treturn util.isIE ? this._getNextOffset_IE(offset, data) : this._getNextOffset_W3C(offset, data);\n\t\t},\n\t\t/** @private */\n\t\t_getNextOffset_W3C: function (offset, data) {\n\t\t\tfunction _isPunctuation(c) {\n\t\t\t\treturn (33 <= c && c <= 47) || (58 <= c && c <= 64) || (91 <= c && c <= 94) || c === 96 || (123 <= c && c <= 126);\n\t\t\t}\n\t\t\tfunction _isWhitespace(c) {\n\t\t\t\treturn c === 32 || c === 9;\n\t\t\t}\n\t\t\tvar view = this.view;\n\t\t\tvar model = view._model;\n\t\t\tvar lineIndex = model.getLineAtOffset(offset);\n\t\t\tvar lineText = model.getLine(lineIndex);\n\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\tvar lineEnd = model.getLineEnd(lineIndex);\n\t\t\tvar lineLength = lineText.length;\n\t\t\tvar offsetInLine = offset - lineStart;\n\t\t\tvar c;\n\t\t\tvar step = data.count < 0 ? -1 : 1;\n\t\t\tif (data.unit === \"word\" || data.unit === \"wordend\" || data.unit === \"wordWS\" || data.unit === \"wordendWS\") { //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tvar previousPunctuation, previousLetterOrDigit, punctuation, letterOrDigit;\n\t\t\t\twhile (data.count !== 0) {\n\t\t\t\t\tif (data.count > 0) {\n\t\t\t\t\t\tif (offsetInLine === lineLength) { return lineEnd; }\n\t\t\t\t\t\tc = lineText.charCodeAt(offsetInLine);\n\t\t\t\t\t\tpreviousPunctuation = _isPunctuation(c); \n\t\t\t\t\t\tpreviousLetterOrDigit = !previousPunctuation && !_isWhitespace(c);\n\t\t\t\t\t\toffsetInLine++;\n\t\t\t\t\t\twhile (offsetInLine < lineLength) {\n\t\t\t\t\t\t\tc = lineText.charCodeAt(offsetInLine);\n\t\t\t\t\t\t\tif (data.unit !== \"wordWS\" && data.unit !== \"wordendWS\") { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\t\tpunctuation = _isPunctuation(c);\n\t\t\t\t\t\t\t\tif (data.unit === \"wordend\") { //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\tif (!punctuation && previousPunctuation) { break; }\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (punctuation && !previousPunctuation) { break; }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tletterOrDigit  = !punctuation && !_isWhitespace(c);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tletterOrDigit  = !_isWhitespace(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (data.unit === \"wordend\" || data.unit === \"wordendWS\") { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\t\tif (!letterOrDigit && previousLetterOrDigit) { break; }\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (letterOrDigit && !previousLetterOrDigit) { break; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpreviousLetterOrDigit = letterOrDigit;\n\t\t\t\t\t\t\tpreviousPunctuation = punctuation;\n\t\t\t\t\t\t\toffsetInLine++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (offsetInLine === 0) { return lineStart; }\n\t\t\t\t\t\toffsetInLine--;\n\t\t\t\t\t\tc = lineText.charCodeAt(offsetInLine);\n\t\t\t\t\t\tpreviousPunctuation = _isPunctuation(c); \n\t\t\t\t\t\tpreviousLetterOrDigit = !previousPunctuation && !_isWhitespace(c);\n\t\t\t\t\t\twhile (0 < offsetInLine) {\n\t\t\t\t\t\t\tc = lineText.charCodeAt(offsetInLine - 1);\n\t\t\t\t\t\t\tif (data.unit !== \"wordWS\" && data.unit !== \"wordendWS\") { //$NON-NLS-1$ //$NON-NLS-0$ \n\t\t\t\t\t\t\t\tpunctuation = _isPunctuation(c);\n\t\t\t\t\t\t\t\tif (data.unit === \"wordend\") { //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\tif (punctuation && !previousPunctuation) { break; }\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (!punctuation && previousPunctuation) { break; }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tletterOrDigit  = !punctuation && !_isWhitespace(c);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tletterOrDigit  = !_isWhitespace(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (data.unit === \"wordend\" || data.unit === \"wordendWS\") { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\t\tif (letterOrDigit && !previousLetterOrDigit) { break; }\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!letterOrDigit && previousLetterOrDigit) { break; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpreviousLetterOrDigit = letterOrDigit;\n\t\t\t\t\t\t\tpreviousPunctuation = punctuation;\n\t\t\t\t\t\t\toffsetInLine--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (offsetInLine === 0) {\n\t\t\t\t\t\t\t//get previous line\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata.count -= step;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (data.count !== 0 && (0 <= offsetInLine + step && offsetInLine + step <= lineLength)) {\n\t\t\t\t\toffsetInLine += step;\n\t\t\t\t\tc = lineText.charCodeAt(offsetInLine);\n\t\t\t\t\t// Handle Unicode surrogates\n\t\t\t\t\tif (0xDC00 <= c && c <= 0xDFFF) {\n\t\t\t\t\t\tif (offsetInLine > 0) {\n\t\t\t\t\t\t\tc = lineText.charCodeAt(offsetInLine - 1);\n\t\t\t\t\t\t\tif (0xD800 <= c && c <= 0xDBFF) {\n\t\t\t\t\t\t\t\toffsetInLine += step;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata.count -= step;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lineStart + offsetInLine;\n\t\t},\n\t\t/** @private */\n\t\t_getNextOffset_IE: function (offset, data) {\n\t\t\tvar child = this._ensureCreated();\n\t\t\tvar view = this.view;\n\t\t\tvar model = view._model;\n\t\t\tvar lineIndex = this.lineIndex;\n\t\t\tvar result = 0, range, length;\n\t\t\tvar lineOffset = model.getLineStart(lineIndex);\n\t\t\tvar lineText = model.getLine(lineIndex);\n\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\tvar document = child.ownerDocument;\n\t\t\tvar lineChild;\n\t\t\tvar step = data.count < 0 ? -1 : 1;\n\t\t\tif (offset === model.getLineEnd(lineIndex)) {\n\t\t\t\tlineChild = child.lastChild;\n\t\t\t\twhile (lineChild && lineChild.ignoreChars === lineChild.firstChild.length) {\n\t\t\t\t\tlineChild = lineChild.previousSibling;\n\t\t\t\t}\n\t\t\t\tif (!lineChild) {\n\t\t\t\t\treturn lineOffset;\n\t\t\t\t}\n\t\t\t\trange = document.body.createTextRange();\n\t\t\t\trange.moveToElementText(lineChild);\n\t\t\t\tlength = range.text.length;\n\t\t\t\trange.moveEnd(data.unit, step);\n\t\t\t\tresult = offset + range.text.length - length;\n\t\t\t} else if (offset === lineOffset && data.count < 0) {\n\t\t\t\tresult = lineOffset;\n\t\t\t} else {\n\t\t\t\tlineChild = child.firstChild;\n\t\t\t\twhile (lineChild) {\n\t\t\t\t\tvar nodeLength = this._nodeLength(lineChild);\n\t\t\t\t\tif (lineOffset + nodeLength > offset) {\n\t\t\t\t\t\trange = document.body.createTextRange();\n\t\t\t\t\t\tif (offset === lineOffset && data.count < 0) {\n\t\t\t\t\t\t\tvar temp = lineChild.previousSibling;\n\t\t\t\t\t\t\t// skip empty nodes\n\t\t\t\t\t\t\twhile (temp) {\n\t\t\t\t\t\t\t\tif (temp.firstChild && temp.firstChild.length) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttemp = temp.previousSibling;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trange.moveToElementText(temp ? temp : lineChild.previousSibling);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trange.moveToElementText(lineChild);\n\t\t\t\t\t\t\trange.collapse();\n\t\t\t\t\t\t\trange.moveEnd(\"character\", offset - lineOffset); //$NON-NLS-0$\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = range.text.length;\n\t\t\t\t\t\trange.moveEnd(data.unit, step);\n\t\t\t\t\t\tresult = offset + range.text.length - length;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlineOffset = nodeLength + lineOffset;\n\t\t\t\t\tlineChild = lineChild.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar offsetInLine = result - lineStart;\n\t\t\tvar c = lineText.charCodeAt(offsetInLine);\n\t\t\t// Handle Unicode surrogates\n\t\t\tif (0xDC00 <= c && c <= 0xDFFF) {\n\t\t\t\tif (offsetInLine > 0) {\n\t\t\t\t\tc = lineText.charCodeAt(offsetInLine - 1);\n\t\t\t\t\tif (0xD800 <= c && c <= 0xDBFF) {\n\t\t\t\t\t\toffsetInLine += step;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = offsetInLine + lineStart;\n\t\t\tdata.count -= step;\n\t\t\treturn result;\n\t\t},\n\t\tupdateLinks: function() {\n\t\t\tvar child = this._ensureCreated();\n\t\t\tif (!this.hasLink) { return; }\n\t\t\tvar self = this;\n\t\t\tthis.forEach(function(span) {\n\t\t\t\tvar style = span.viewStyle;\n\t\t\t\tif (style && style.tagName && style.tagName.toLowerCase() === \"a\") { //$NON-NLS-0$\n\t\t\t\t\tchild.replaceChild(self._createSpan(child, span.firstChild.data, style), span);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t},\n\t\t/** @private */\n\t\tdestroy: function() {\n\t\t\tvar div = this._createdDiv;\n\t\t\tif (div) {\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t\tthis._createdDiv = null;\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/**\n\t * @class This object describes the options for the text view.\n\t * <p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.TextView}<br/>\n\t * {@link orion.editor.TextView#setOptions}\n\t * {@link orion.editor.TextView#getOptions}\t \n\t * </p>\t\t \n\t * @name orion.editor.TextViewOptions\n\t *\n\t * @property {String|DOMElement} parent the parent element for the view, it can be either a DOM element or an ID for a DOM element.\n\t * @property {orion.editor.TextModel} [model] the text model for the view. If it is not set the view creates an empty {@link orion.editor.TextModel}.\n\t * @property {Boolean} [readonly=false] whether or not the view is read-only.\n\t * @property {Boolean} [fullSelection=true] whether or not the view is in full selection mode.\n\t * @property {Boolean} [tabMode=true] whether or not the tab keypress is consumed by the view or is used for focus traversal.\n\t * @property {Boolean} [expandTab=false] whether or not the tab key inserts white spaces.\n\t * @property {orion.editor.TextTheme} [theme=orion.editor.TextTheme.getTheme()] the TextTheme manager. TODO more info on this\n\t * @property {orion.editor.UndoStack} [undoStack] the Undo Stack.\n\t * @property {String} [themeClass] the CSS class for the view theming.\n\t * @property {Number} [tabSize=8] The number of spaces in a tab.\n\t * @property {Boolean} [overwriteMode=false] whether or not the view is in insert/overwrite mode.\n\t * @property {Boolean} [singleMode=false] whether or not the editor is in single line mode.\n\t * @property {Number} [marginOffset=0] the offset in a line where the print margin should be displayed. <code>0</code> means no print margin.\n\t * @property {Number} [wrapOffset=0] the offset in a line where text should wrap. <code>0</code> means wrap at the client area right edge.\n\t * @property {Boolean} [wrapMode=false] whether or not the view wraps lines.\n\t * @property {Boolean} [wrapable=false] whether or not the view is wrappable.\n\t * @property {Number} [scrollAnimation=0] the time duration in miliseconds for scrolling animation. <code>0</code> means no animation.\n\t * @property {Boolean} [blockCursorVisible=false] whether or not to show the block cursor.\n\t */\n\t/**\n\t * Constructs a new text view.\n\t * \n\t * @param {orion.editor.TextViewOptions} options the view options.\n\t * \n\t * @class A TextView is a user interface for editing text.\n\t * @name orion.editor.TextView\n\t * @borrows orion.editor.EventTarget#addEventListener as #addEventListener\n\t * @borrows orion.editor.EventTarget#removeEventListener as #removeEventListener\n\t * @borrows orion.editor.EventTarget#dispatchEvent as #dispatchEvent\n\t */\n\tfunction TextView (options) {\n\t\tthis._init(options || {});\n\t}\n\t\n\tTextView.prototype = /** @lends orion.editor.TextView.prototype */ {\n\t\t/**\n\t\t * Adds a keyMode to the text view at the specified position.\n\t\t *\n\t\t * @param {orion.editor.KeyMode} mode the editor keyMode.\n\t\t * @param {Number} [index=length] the index.\n\t\t */\n\t\taddKeyMode: function(mode, index) {\n\t\t\tvar keyModes = this._keyModes;\n\t\t\tif (index !== undefined) {\n\t\t\t\tkeyModes.splice(index, 0, mode);\n\t\t\t} else {\n\t\t\t\tkeyModes.push(mode);\n\t\t\t}\n\t\t\t//TODO: API needed for this\n\t\t\tif (mode._modeAdded) {\n\t\t\t\tmode._modeAdded();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Adds a ruler to the text view at the specified position.\n\t\t * <p>\n\t\t * The position is relative to the ruler location.\n\t\t * </p>\n\t\t *\n\t\t * @param {orion.editor.Ruler} ruler the ruler.\n\t\t * @param {Number} [index=length] the ruler index.\n\t\t */\n\t\taddRuler: function (ruler, index) {\n\t\t\tvar rulers = this._rulers;\n\t\t\tif (index !== undefined) {\n\t\t\t\tvar i, sideIndex;\n\t\t\t\tfor (i = 0, sideIndex=0; i < rulers.length && sideIndex < index; i++) {\n\t\t\t\t\tif (ruler.getLocation() === rulers[i].getLocation()) {\n\t\t\t\t\t\tsideIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trulers.splice(sideIndex, 0, ruler);\n\t\t\t\tindex = sideIndex;\n\t\t\t} else {\n\t\t\t\trulers.push(ruler);\n\t\t\t}\n\t\t\tthis._createRuler(ruler, index);\n\t\t\truler.setView(this);\n\t\t\tthis._update();\n\t\t},\n\t\tcomputeSize: function() {\n\t\t\tvar w = 0, h = 0;\n\t\t\tvar model = this._model, clientDiv = this._clientDiv;\n\t\t\tif (!clientDiv) { return {width: w, height: h}; }\n\t\t\tvar clientWidth = clientDiv.style.width;\n\t\t\t/*\n\t\t\t* Feature in WekKit. Webkit limits the width of the lines\n\t\t\t* computed below to the width of the client div.  This causes\n\t\t\t* the lines to be wrapped even though \"pre\" is set.  The fix\n\t\t\t* is to set the width of the client div to a \"0x7fffffffpx\"\n\t\t\t* before computing the lines width.  Note that this value is\n\t\t\t* reset to the appropriate value further down.\n\t\t\t*/\n\t\t\tif (util.isWebkit) {\n\t\t\t\tclientDiv.style.width = \"0x7fffffffpx\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tvar lineCount = model.getLineCount();\n\t\t\tfor (var lineIndex=0; lineIndex<lineCount; lineIndex++) {\n\t\t\t\tvar line = this._getLine(lineIndex);\n\t\t\t\tvar rect = line.getBoundingClientRect();\n\t\t\t\tw = Math.max(w, rect.right - rect.left);\n\t\t\t\th += rect.bottom - rect.top;\n\t\t\t\tline.destroy();\n\t\t\t}\n\t\t\tif (util.isWebkit) {\n\t\t\t\tclientDiv.style.width = clientWidth;\n\t\t\t}\n\t\t\tvar viewPadding = this._getViewPadding();\n\t\t\tw += viewPadding.right + viewPadding.left + this._metrics.scrollWidth;\n\t\t\th += viewPadding.bottom + viewPadding.top + this._metrics.scrollWidth;\n\t\t\treturn {width: w, height: h};\n\t\t},\n\t\t/**\n\t\t * Converts the given rectangle from one coordinate spaces to another.\n\t\t * <p>The supported coordinate spaces are:\n\t\t * <ul>\n\t\t *   <li>\"document\" - relative to document, the origin is the top-left corner of first line</li>\n\t\t *   <li>\"page\" - relative to html page that contains the text view</li>\n\t\t * </ul>\n\t\t * </p>\n\t\t * <p>All methods in the view that take or return a position are in the document coordinate space.</p>\n\t\t *\n\t\t * @param rect the rectangle to convert.\n\t\t * @param rect.x the x of the rectangle.\n\t\t * @param rect.y the y of the rectangle.\n\t\t * @param rect.width the width of the rectangle.\n\t\t * @param rect.height the height of the rectangle.\n\t\t * @param {String} from the source coordinate space.\n\t\t * @param {String} to the destination coordinate space.\n\t\t *\n\t\t * @see orion.editor.TextView#getLocationAtOffset\n\t\t * @see orion.editor.TextView#getOffsetAtLocation\n\t\t * @see orion.editor.TextView#getTopPixel\n\t\t * @see orion.editor.TextView#setTopPixel\n\t\t */\n\t\tconvert: function(rect, from, to) {\n\t\t\tif (!this._clientDiv) { return rect; }\n\t\t\tvar scroll = this._getScroll();\n\t\t\tvar viewPad = this._getViewPadding();\n\t\t\tvar viewRect = this._viewDiv.getBoundingClientRect();\n\t\t\tif (from === \"document\") { //$NON-NLS-0$\n\t\t\t\tif (rect.x !== undefined) {\n\t\t\t\t\trect.x += - scroll.x + viewRect.left + viewPad.left;\n\t\t\t\t}\n\t\t\t\tif (rect.y !== undefined) {\n\t\t\t\t\trect.y += - scroll.y + viewRect.top + viewPad.top;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//At this point rect is in the widget coordinate space\n\t\t\tif (to === \"document\") { //$NON-NLS-0$\n\t\t\t\tif (rect.x !== undefined) {\n\t\t\t\t\trect.x += scroll.x - viewRect.left - viewPad.left;\n\t\t\t\t}\n\t\t\t\tif (rect.y !== undefined) {\n\t\t\t\t\trect.y += scroll.y - viewRect.top - viewPad.top;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rect;\n\t\t},\n\t\t/**\n\t\t * Destroys the text view. \n\t\t * <p>\n\t\t * Removes the view from the page and frees all resources created by the view.\n\t\t * Calling this function causes the \"Destroy\" event to be fire so that all components\n\t\t * attached to view can release their references.\n\t\t * </p>\n\t\t *\n\t\t * @see orion.editor.TextView#onDestroy\n\t\t */\n\t\tdestroy: function() {\n\t\t\t/* Destroy rulers*/\n\t\t\tfor (var i=0; i< this._rulers.length; i++) {\n\t\t\t\tthis._rulers[i].setView(null);\n\t\t\t}\n\t\t\tthis.rulers = null;\n\t\t\t\n\t\t\tthis._destroyView();\n\n\t\t\tvar e = {type: \"Destroy\"}; //$NON-NLS-0$\n\t\t\tthis.onDestroy(e);\n\n\t\t\tthis._parent = null;\n\t\t\tif (this._model && this._model.destroy) {\n\t\t\t\tthis._model.destroy();\n\t\t\t}\n\t\t\tthis._model = null;\n\t\t\tthis._theme = null;\n\t\t\tthis._selection = null;\n\t\t\tthis._doubleClickSelection = null;\n\t\t\tthis._keyModes = null;\n\t\t\tthis._actions = null;\n\t\t},\n\t\t/**\n\t\t * Gives focus to the text view.\n\t\t */\n\t\tfocus: function() {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\t/*\n\t\t\t* Feature in Chrome. When focus is called in the clientDiv without\n\t\t\t* setting selection the browser will set the selection to the first dom \n\t\t\t* element, which can be above the client area. When this happen the \n\t\t\t* browser also scrolls the window to show that element.\n\t\t\t* The fix is to call _updateDOMSelection() before calling focus().\n\t\t\t*/\n\t\t\tthis._updateDOMSelection();\n\t\t\tthis._clientDiv.focus();\n\t\t\t/*\n\t\t\t* Feature in Safari. When focus is called the browser selects the clientDiv\n\t\t\t* itself. The fix is to call _updateDOMSelection() after calling focus().\n\t\t\t*/\n\t\t\tthis._updateDOMSelection();\n\t\t},\n\t\t/**\n\t\t * Check if the text view has focus.\n\t\t *\n\t\t * @returns {Boolean} <code>true</code> if the text view has focus, otherwise <code>false</code>.\n\t\t */\n\t\thasFocus: function() {\n\t\t\treturn this._hasFocus;\n\t\t},\n\t\t/**\n\t\t * Returns the action description for a given action ID.\n\t\t *\n\t\t * @returns {orion.editor.ActionDescrition} the action description\n\t\t */\n\t\tgetActionDescription: function(actionID) {\n\t\t\tvar action = this._actions[actionID];\n\t\t\tif (action) {\n\t\t\t\treturn action.actionDescription;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\t/**\n\t\t * Returns all action IDs defined in the text view.\n\t\t * <p>\n\t\t * There are two types of actions, the predefined actions of the view \n\t\t * and the actions added by application code.\n\t\t * </p>\n\t\t * <p>\n\t\t * The predefined actions are:\n\t\t * <ul>\n\t\t *   <li>Navigation actions. These actions move the caret collapsing the selection.</li>\n\t\t *     <ul>\n\t\t *       <li>\"lineUp\" - moves the caret up by one line</li>\n\t\t *       <li>\"lineDown\" - moves the caret down by one line</li>\n\t\t *       <li>\"lineStart\" - moves the caret to beginning of the current line</li>\n\t\t *       <li>\"lineEnd\" - moves the caret to end of the current line </li>\n\t\t *       <li>\"charPrevious\" - moves the caret to the previous character</li>\n\t\t *       <li>\"charNext\" - moves the caret to the next character</li>\n\t\t *       <li>\"pageUp\" - moves the caret up by one page</li>\n\t\t *       <li>\"pageDown\" - moves the caret down by one page</li>\n\t\t *       <li>\"wordPrevious\" - moves the caret to the previous word</li>\n\t\t *       <li>\"wordNext\" - moves the caret to the next word</li>\n\t\t *       <li>\"textStart\" - moves the caret to the beginning of the document</li>\n\t\t *       <li>\"textEnd\" - moves the caret to the end of the document</li>\n\t\t *     </ul>\n\t\t *   <li>Selection actions. These actions move the caret extending the selection.</li>\n\t\t *     <ul>\n\t\t *       <li>\"selectLineUp\" - moves the caret up by one line</li>\n\t\t *       <li>\"selectLineDown\" - moves the caret down by one line</li>\n\t\t *       <li>\"selectLineStart\" - moves the caret to beginning of the current line</li>\n\t\t *       <li>\"selectLineEnd\" - moves the caret to end of the current line </li>\n\t\t *       <li>\"selectCharPrevious\" - moves the caret to the previous character</li>\n\t\t *       <li>\"selectCharNext\" - moves the caret to the next character</li>\n\t\t *       <li>\"selectPageUp\" - moves the caret up by one page</li>\n\t\t *       <li>\"selectPageDown\" - moves the caret down by one page</li>\n\t\t *       <li>\"selectWordPrevious\" - moves the caret to the previous word</li>\n\t\t *       <li>\"selectWordNext\" - moves the caret to the next word</li>\n\t\t *       <li>\"selectTextStart\" - moves the caret to the beginning of the document</li>\n\t\t *       <li>\"selectTextEnd\" - moves the caret to the end of the document</li>\n\t\t *       <li>\"selectAll\" - selects the entire document</li>\n\t\t *     </ul>\n\t\t *   <li>Edit actions. These actions modify the text view text</li>\n\t\t *     <ul>\n\t\t *       <li>\"deletePrevious\" - deletes the character preceding the caret</li>\n\t\t *       <li>\"deleteNext\" - deletes the charecter following the caret</li>\n\t\t *       <li>\"deleteWordPrevious\" - deletes the word preceding the caret</li>\n\t\t *       <li>\"deleteWordNext\" - deletes the word following the caret</li>\n\t\t *       <li>\"deleteLineStart\" - deletes characteres to the beginning of the line</li>\n\t\t *       <li>\"deleteLineEnd\" - deletes characteres to the end of the line</li>\n\t\t *       <li>\"tab\" - inserts a tab character at the caret</li>\n\t\t *       <li>\"shiftTab\" - noop</li>\n\t\t *       <li>\"enter\" - inserts a line delimiter at the caret</li>\n\t\t *       <li>\"uppercase\" - upper case the text at the caret</li>\n\t\t *       <li>\"lowercase\" - lower case the text at the caret</li>\n\t\t *       <li>\"capitalize\" - capitilize case the text at the caret</li>\n\t\t *       <li>\"reversecase\" - reverse the case the text at the caret</li>\n\t\t *     </ul>\n\t\t *   <li>Clipboard actions. These actions modify the view text as well</li>\n\t\t *     <ul>\n\t\t *       <li>\"copy\" - copies the selected text to the clipboard</li>\n\t\t *       <li>\"cut\" - copies the selected text to the clipboard and deletes the selection</li>\n\t\t *       <li>\"paste\" - replaces the selected text with the clipboard contents</li>\n\t\t *     </ul>\n\t\t *   <li>Scrolling actions.</li>\n\t\t *     <ul>\n\t\t *       <li>\"scrollLineUp\" - scrolls the view up by one line</li>\n\t\t *       <li>\"scrollLineDown\" - scrolls the view down by one line</li>\n\t\t *       <li>\"scrollPageUp\" - scrolls the view up by one page</li>\n\t\t *       <li>\"scrollPageDown\" - scrolls the view down by one page</li>\n\t\t *       <li>\"scrollTextStart\" - scrolls the view to the beginning of the document</li>\n\t\t *       <li>\"scrollTextEnd\" - scrolls the view to the end of the document</li>\n\t\t *     </ul>\n\t\t *   <li>Mode actions.</li>\n\t\t *     <ul>\n\t\t *       <li>\"toggleTabMode\" - toggles tab mode.</li>\n\t\t *       <li>\"toggleWrapMode\" - toggles wrap mode.</li>\n\t\t *       <li>\"toggleOverwriteMode\" - toggles overwrite mode.</li>\n\t\t *     </ul>\n\t\t * </ul>\n\t\t * </p>\n\t\t * \n\t\t * @param {Boolean} [defaultAction=false] whether or not the predefined actions are included.\n\t\t * @returns {String[]} an array of action IDs defined in the text view.\n\t\t *\n\t\t * @see orion.editor.TextView#invokeAction\n\t\t * @see orion.editor.TextView#setAction\n\t\t * @see orion.editor.TextView#setKeyBinding\n\t\t * @see orion.editor.TextView#getKeyBindings\n\t\t */\n\t\tgetActions: function (defaultAction) {\n\t\t\tvar result = [];\n\t\t\tvar actions = this._actions;\n\t\t\tfor (var i in actions) {\n\t\t\t\tif (actions.hasOwnProperty(i)) {\n\t\t\t\t\tif (!defaultAction && actions[i].defaultHandler) { continue; }\n\t\t\t\t\tresult.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * Returns the bottom index.\n\t\t * <p>\n\t\t * The bottom index is the line that is currently at the bottom of the view.  This\n\t\t * line may be partially visible depending on the vertical scroll of the view. The parameter\n\t\t * <code>fullyVisible</code> determines whether to return only fully visible lines. \n\t\t * </p>\n\t\t *\n\t\t * @param {Boolean} [fullyVisible=false] if <code>true</code>, returns the index of the last fully visible line. This\n\t\t *    parameter is ignored if the view is not big enough to show one line.\n\t\t * @returns {Number} the index of the bottom line.\n\t\t *\n\t\t * @see orion.editor.TextView#getTopIndex\n\t\t * @see orion.editor.TextView#setTopIndex\n\t\t */\n\t\tgetBottomIndex: function(fullyVisible) {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getBottomIndex(fullyVisible);\n\t\t},\n\t\t/**\n\t\t * Returns the bottom pixel.\n\t\t * <p>\n\t\t * The bottom pixel is the pixel position that is currently at\n\t\t * the bottom edge of the view.  This position is relative to the\n\t\t * beginning of the document.\n\t\t * </p>\n\t\t *\n\t\t * @returns {Number} the bottom pixel.\n\t\t *\n\t\t * @see orion.editor.TextView#getTopPixel\n\t\t * @see orion.editor.TextView#setTopPixel\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tgetBottomPixel: function() {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getScroll().y + this._getClientHeight();\n\t\t},\n\t\t/**\n\t\t * Returns the caret offset relative to the start of the document.\n\t\t *\n\t\t * @returns {Number} the caret offset relative to the start of the document.\n\t\t *\n\t\t * @see orion.editor.TextView#setCaretOffset\n\t\t * @see orion.editor.TextView#setSelection\n\t\t * @see orion.editor.TextView#getSelection\n\t\t */\n\t\tgetCaretOffset: function () {\n\t\t\tvar s = this._getSelection();\n\t\t\treturn s.getCaret();\n\t\t},\n\t\t/**\n\t\t * Returns the client area.\n\t\t * <p>\n\t\t * The client area is the portion in pixels of the document that is visible. The\n\t\t * client area position is relative to the beginning of the document.\n\t\t * </p>\n\t\t *\n\t\t * @returns {Object} the client area rectangle {x, y, width, height}.\n\t\t *\n\t\t * @see orion.editor.TextView#getTopPixel\n\t\t * @see orion.editor.TextView#getBottomPixel\n\t\t * @see orion.editor.TextView#getHorizontalPixel\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tgetClientArea: function() {\n\t\t\tif (!this._clientDiv) { return {x: 0, y: 0, width: 0, height: 0}; }\n\t\t\tvar scroll = this._getScroll();\n\t\t\treturn {x: scroll.x, y: scroll.y, width: this._getClientWidth(), height: this._getClientHeight()};\n\t\t},\n\t\t/**\n\t\t * Returns the horizontal pixel.\n\t\t * <p>\n\t\t * The horizontal pixel is the pixel position that is currently at\n\t\t * the left edge of the view.  This position is relative to the\n\t\t * beginning of the document.\n\t\t * </p>\n\t\t *\n\t\t * @returns {Number} the horizontal pixel.\n\t\t *\n\t\t * @see orion.editor.TextView#setHorizontalPixel\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tgetHorizontalPixel: function() {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getScroll().x;\n\t\t},\n\t\t/**\n\t\t * Returns all the key bindings associated to the given action ID.\n\t\t *\n\t\t * @param {String} actionID the action ID.\n\t\t * @returns {orion.KeyBinding[]} the array of key bindings associated to the given action ID.\n\t\t *\n\t\t * @see orion.editor.TextView#setKeyBinding\n\t\t * @see orion.editor.TextView#setAction\n\t\t */\n\t\tgetKeyBindings: function (actionID) {\n\t\t\tvar result = [];\n\t\t\tvar keyModes = this._keyModes;\n\t\t\tfor (var i = 0; i < keyModes.length; i++) {\n\t\t\t\tresult = result.concat(keyModes[i].getKeyBindings(actionID));\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * Returns all the key modes added to text view.\n\t\t *\n\t\t * @returns {orion.editor.KeyMode[]} the array of key modes.\n\t\t *\n\t\t * @see orion.editor.TextView#addKeyMode\n\t\t * @see orion.editor.TextView#removeKeyMode\n\t\t */\n\t\tgetKeyModes: function() {\n\t\t\treturn this._keyModes.slice(0);\n\t\t},\n\t\t/**\n\t\t * Returns the line height for a given line index.  Returns the default line\n\t\t * height if the line index is not specified.\n\t\t *\n\t\t * @param {Number} [lineIndex] the line index.\n\t\t * @returns {Number} the height of the line in pixels.\n\t\t *\n\t\t * @see orion.editor.TextView#getLinePixel\n\t\t */\n\t\tgetLineHeight: function(lineIndex) {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getLineHeight(lineIndex);\n\t\t},\n\t\t/**\n\t\t * Returns the line index for a given line pixel position relative to the document.\n\t\t *\n\t\t * @param {Number} [y] the line pixel.\n\t\t * @returns {Number} the line index for the specified pixel position.\n\t\t *\n\t\t * @see orion.editor.TextView#getLinePixel\n\t\t */\n\t\tgetLineIndex: function(y) {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getLineIndex(y);\n\t\t},\n\t\t/**\n\t\t * @name isValidTextPosition\n\t\t * @description Return whether the given x/y pixel position, relative to the document, is inside of document text. \n\t\t * \t\t\t\tThis tests both whether the y position is below the text lines of the document as we as whether the\n\t\t * \t\t\t\tx position is within the text of the line.\n\t\t * @function\n\t\t * @param x {Number} [x] the x pixel position\n\t\t * @param y {Number} [y] the line pixel position\n\t\t * @returns returns {Boolean} true if the pixel position is over text content\n\t\t */\n\t\tisValidTextPosition: function(x, y){\n\t\t\tif (!this._clientDiv) { return false; }\n\t\t\t// Check if we are within a valid line\n\t\t\tvar lineIndex = this._getLineIndex(y, true);\n\t\t\tif (lineIndex < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Get the closest offset to the position\n\t\t\tvar line = this._getLine(lineIndex);\n\t\t\tvar offset = this.getOffsetAtLocation(x, y);\n\t\t\t// If the closest offset is to the left of the character's bounds then position is outside the text on the line\n\t\t\tvar bounds = line.getBoundingClientRect(offset);\n\t\t\tline.destroy();\n\t\t\tif (x > bounds.right){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * Returns the top pixel position of a given line index relative to the beginning\n\t\t * of the document.\n\t\t * <p>\n\t\t * Clamps out of range indices.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} lineIndex the line index.\n\t\t * @returns {Number} the pixel position of the line.\n\t\t *\n\t\t * @see orion.editor.TextView#setTopPixel\n\t\t * @see orion.editor.TextView#getLineIndex\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tgetLinePixel: function(lineIndex) {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getLinePixel(lineIndex);\n\t\t},\n\t\t/**\n\t\t * Returns the {x, y} pixel location of the top-left corner of the character\n\t\t * bounding box at the specified offset in the document.  The pixel location\n\t\t * is relative to the document.\n\t\t * <p>\n\t\t * Clamps out of range offsets.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} offset the character offset\n\t\t * @returns {Object} the {x, y} pixel location of the given offset.\n\t\t *\n\t\t * @see orion.editor.TextView#getOffsetAtLocation\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tgetLocationAtOffset: function(offset) {\n\t\t\tif (!this._clientDiv) { return {x: 0, y: 0}; }\n\t\t\tvar model = this._model;\n\t\t\toffset = Math.min(Math.max(0, offset), model.getCharCount());\n\t\t\tvar lineIndex = model.getLineAtOffset(offset);\n\t\t\tvar line = this._getLine(lineIndex);\n\t\t\tvar rect = line.getBoundingClientRect(offset);\n\t\t\tline.destroy();\n\t\t\tvar x = rect.left;\n\t\t\tvar y = this._getLinePixel(lineIndex) + rect.top;\n\t\t\treturn {x: x, y: y};\n\t\t},\n\t\t/**\n\t\t * Returns the next character offset after the given offset and options\n\t\t *\n\t\t * @param {Number} offset the offset to start from\n\t\t * @param {Object} options\n\t\t *   { unit: the type of unit to advance to (eg \"character\", \"word\", \"wordend\", \"wordWS\", \"wordendWS\"),\n\t\t *    count: the number of units to advance (negative to advance backwards) }\n\t\t * @returns {Number} the next character offset\n\t\t */\n\t\tgetNextOffset: function(offset, options) {\n\t\t\tvar selection = new Selection(offset, offset, false);\n\t\t\tthis._doMove(options, selection);\n\t\t\treturn selection.getCaret();\n\t\t},\n\t\t/**\n\t\t * Returns the specified view options.\n\t\t * <p>\n\t\t * The returned value is either a <code>orion.editor.TextViewOptions</code> or an option value. An option value is returned when only one string parameter\n\t\t * is specified. A <code>orion.editor.TextViewOptions</code> is returned when there are no paremeters, or the parameters are a list of options names or a\n\t\t * <code>orion.editor.TextViewOptions</code>. All view options are returned when there no paremeters.\n\t\t * </p>\n\t\t *\n\t\t * @param {String|orion.editor.TextViewOptions} [options] The options to return.\n\t\t * @return {Object|orion.editor.TextViewOptions} The requested options or an option value.\n\t\t *\n\t\t * @see orion.editor.TextView#setOptions\n\t\t */\n\t\tgetOptions: function() {\n\t\t\tvar options;\n\t\t\tif (arguments.length === 0) {\n\t\t\t\toptions = this._defaultOptions();\n\t\t\t} else if (arguments.length === 1) {\n\t\t\t\tvar arg = arguments[0];\n\t\t\t\tif (typeof arg === \"string\") { //$NON-NLS-0$\n\t\t\t\t\treturn clone(this[\"_\" + arg]); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\toptions = arg;\n\t\t\t} else {\n\t\t\t\toptions = {};\n\t\t\t\tfor (var index in arguments) {\n\t\t\t\t\tif (arguments.hasOwnProperty(index)) {\n\t\t\t\t\t\toptions[arguments[index]] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var option in options) {\n\t\t\t\tif (options.hasOwnProperty(option)) {\n\t\t\t\t\toptions[option] = clone(this[\"_\" + option]); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options;\n\t\t},\n\t\t/**\n\t\t * Returns the text model of the text view.\n\t\t *\n\t\t * @returns {orion.editor.TextModel} the text model of the view.\n\t\t */\n\t\tgetModel: function() {\n\t\t\treturn this._model;\n\t\t},\n\t\t/**\n\t\t * Returns the character offset nearest to the given pixel location.  The\n\t\t * pixel location is relative to the document.\n\t\t *\n\t\t * @param x the x of the location\n\t\t * @param y the y of the location\n\t\t * @returns {Number} the character offset at the given location.\n\t\t *\n\t\t * @see orion.editor.TextView#getLocationAtOffset\n\t\t */\n\t\tgetOffsetAtLocation: function(x, y) {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\tvar lineIndex = this._getLineIndex(y);\n\t\t\tvar line = this._getLine(lineIndex);\n\t\t\tvar offset = line.getOffset(x, y - this._getLinePixel(lineIndex));\n\t\t\tline.destroy();\n\t\t\treturn offset;\n\t\t},\n\t\t/**\n\t\t * @name getLineAtOffset\n\t\t * @description Compute the editor line number for the given offset\n\t\t * @function\n\t\t * @public\n\t\t * @memberof orion.editor.TextView\n\t\t * @param {Number} offset The offset into the editor\n\t\t * @returns {Number} Returns the line number in the editor corresponding to the given offset or <code>-1</code> if the offset is \n\t\t * out of range\n\t\t * @since 5.0\n\t\t */\n\t\tgetLineAtOffset: function(offset) {\n\t\t\treturn this.getModel().getLineAtOffset(offset);\n\t\t},\n\t\t/**\n\t\t * @name getLineStart\n\t\t * @description Compute the editor start offset of the given line number\n\t\t * @function\n\t\t * @public\n\t\t * @memberof orion.editor.TextView\n\t\t * @param {Number} line The line number in the editor\n\t\t * @returns {Number} Returns the start offset of the given line number in the editor.\n\t\t * @since 5.0\n\t\t */\n\t\tgetLineStart: function(line) {\n\t\t\treturn this.getModel().getLineStart(line);\n\t\t},\n\t\t/**\n\t\t * Get the view rulers.\n\t\t *\n\t\t * @returns {orion.editor.Ruler[]} the view rulers\n\t\t *\n\t\t * @see orion.editor.TextView#addRuler\n\t\t */\n\t\tgetRulers: function() {\n\t\t\treturn this._rulers.slice(0);\n\t\t},\n\t\t/**\n\t\t * Returns the text view selection.\n\t\t * <p>\n\t\t * The selection is defined by a start and end character offset relative to the\n\t\t * document. The character at end offset is not included in the selection.\n\t\t * </p>\n\t\t * \n\t\t * @returns {orion.editor.Selection} the view selection\n\t\t *\n\t\t * @see orion.editor.TextView#setSelection\n\t\t */\n\t\tgetSelection: function () {\n\t\t\treturn this._getSelection();\n\t\t},\n\t\tgetSelections: function () {\n\t\t\treturn this._getSelections();\n\t\t},\n\t\tgetSelectionText: function(delimiter) {\n\t\t\tvar text = [];\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (!selection.isEmpty()) {\n\t\t\t\t\ttext.push(self._getBaseText(selection.start, selection.end));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn text.join(delimiter !== undefined ? delimiter : this._model.getLineDelimiter());\n\t\t},\n\t\t/**\n\t\t * Returns the text for the given range.\n\t\t * <p>\n\t\t * The text does not include the character at the end offset.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} [start=0] the start offset of text range.\n\t\t * @param {Number} [end=char count] the end offset of text range.\n\t\t *\n\t\t * @see orion.editor.TextView#setText \t\n\t\t */\n\t\tgetText: function(start, end) {\n\t\t\tvar model = this._model;\n\t\t\treturn model.getText(start, end);\n\t\t},\n\t\t/**\n\t\t * Returns the top index.\n\t\t * <p>\n\t\t * The top index is the line that is currently at the top of the view.  This\n\t\t * line may be partially visible depending on the vertical scroll of the view. The parameter\n\t\t * <code>fullyVisible</code> determines whether to return only fully visible lines. \n\t\t * </p>\n\t\t *\n\t\t * @param {Boolean} [fullyVisible=false] if <code>true</code>, returns the index of the first fully visible line. This\n\t\t *    parameter is ignored if the view is not big enough to show one line.\n\t\t * @returns {Number} the index of the top line.\n\t\t *\n\t\t * @see orion.editor.TextView#getBottomIndex\n\t\t * @see orion.editor.TextView#setTopIndex\n\t\t */\n\t\tgetTopIndex: function(fullyVisible) {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getTopIndex(fullyVisible);\n\t\t},\n\t\t/**\n\t\t * Returns the top pixel.\n\t\t * <p>\n\t\t * The top pixel is the pixel position that is currently at\n\t\t * the top edge of the view.  This position is relative to the\n\t\t * beginning of the document.\n\t\t * </p>\n\t\t *\n\t\t * @returns {Number} the top pixel.\n\t\t *\n\t\t * @see orion.editor.TextView#getBottomPixel\n\t\t * @see orion.editor.TextView#setTopPixel\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tgetTopPixel: function() {\n\t\t\tif (!this._clientDiv) { return 0; }\n\t\t\treturn this._getScroll().y;\n\t\t},\n\t\t/**\n\t\t * Executes the action handler associated with the given action ID.\n\t\t * <p>\n\t\t * The application defined action takes precedence over predefined actions unless\n\t\t * the <code>defaultAction</code> paramater is <code>true</code>.\n\t\t * </p>\n\t\t * <p>\n\t\t * If the application defined action returns <code>false</code>, the text view predefined\n\t\t * action is executed if present.\n\t\t * </p>\n\t\t *\n\t\t * @param {String} actionID the action ID.\n\t\t * @param {Boolean} [defaultAction] whether to always execute the predefined action only.\n\t\t * @param {Object} [actionOptions] action specific options to be passed to the action handlers.\n\t\t * @returns {Boolean} <code>true</code> if the action was executed.\n\t\t *\n\t\t * @see orion.editor.TextView#setAction\n\t\t * @see orion.editor.TextView#getActions\n\t\t */\n\t\tinvokeAction: function (actionID, defaultAction, actionOptions) {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tvar action = this._actions[actionID];\n\t\t\tif (action) {\n\t\t\t\tif (action.actionDescription && action.actionDescription.id) {\n\t\t\t\t\tmMetrics.logEvent(\"editor\", \"action\", action.actionDescription.id); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (!defaultAction && action.handler) {\n\t\t\t\t\tif (action.handler(actionOptions)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (action.defaultHandler) {\n\t\t\t\t\treturn typeof action.defaultHandler(actionOptions) === \"boolean\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t/**\n\t\t* Returns if the view is destroyed.\n\t\t* @returns {Boolean} <code>true</code> if the view is destroyed.\n\t\t*/\n\t\tisDestroyed: function () {\n\t\t\treturn !this._clientDiv;\n\t\t},\n\t\t/** \n\t\t * @class This is the event sent when the user right clicks or otherwise invokes the context menu of the view. \n\t\t * <p> \n\t\t * <b>See:</b><br/> \n\t\t * {@link orion.editor.TextView}<br/> \n\t\t * {@link orion.editor.TextView#event:onContextMenu} \n\t\t * </p> \n\t\t * \n\t\t * @name orion.editor.ContextMenuEvent \n\t\t * \n\t\t * @property {Number} x The pointer location on the x axis, relative to the document the user is editing. \n\t\t * @property {Number} y The pointer location on the y axis, relative to the document the user is editing. \n\t\t * @property {Number} screenX The pointer location on the x axis, relative to the screen. This is copied from the DOM contextmenu event.screenX property. \n\t\t * @property {Number} screenY The pointer location on the y axis, relative to the screen. This is copied from the DOM contextmenu event.screenY property. \n\t\t * @property {Boolean} defaultPrevented Determines whether the user agent context menu should be shown. It is shown by default.\n\t\t * @property {Function} preventDefault If called prevents the user agent context menu from showing.\n\t\t */ \n\t\t/** \n\t\t * This event is sent when the user invokes the view context menu. \n\t\t * \n\t\t * @event \n\t\t * @param {orion.editor.ContextMenuEvent} contextMenuEvent the event \n\t\t */ \n\t\tonContextMenu: function(contextMenuEvent) {\n\t\t\treturn this.dispatchEvent(contextMenuEvent); \n\t\t}, \n\t\tonDragStart: function(dragEvent) {\n\t\t\treturn this.dispatchEvent(dragEvent);\n\t\t},\n\t\tonDrag: function(dragEvent) {\n\t\t\treturn this.dispatchEvent(dragEvent);\n\t\t},\n\t\tonDragEnd: function(dragEvent) {\n\t\t\treturn this.dispatchEvent(dragEvent);\n\t\t},\n\t\tonDragEnter: function(dragEvent) {\n\t\t\treturn this.dispatchEvent(dragEvent);\n\t\t},\n\t\tonDragOver: function(dragEvent) {\n\t\t\treturn this.dispatchEvent(dragEvent);\n\t\t},\n\t\tonDragLeave: function(dragEvent) {\n\t\t\treturn this.dispatchEvent(dragEvent);\n\t\t},\n\t\tonDrop: function(dragEvent) {\n\t\t\treturn this.dispatchEvent(dragEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text view is destroyed.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onDestroy}\n\t\t * </p>\n\t\t * @name orion.editor.DestroyEvent\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view has been destroyed.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.DestroyEvent} destroyEvent the event\n\t\t *\n\t\t * @see orion.editor.TextView#destroy\n\t\t */\n\t\tonDestroy: function(destroyEvent) {\n\t\t\treturn this.dispatchEvent(destroyEvent);\n\t\t},\n\t\t/**\n\t\t * @description This event is sent when the file is being saved\n\t\t * @function\n\t\t * @param {Object} savingEvent the event\n\t\t * @since 8.0\n\t\t */\n\t\tonSaving: function onSaving(savingEvent) {\n\t\t    return this.dispatchEvent(savingEvent);\n\t\t},\n\t\t/**\n\t\t * @description This event is sent when the file has been saved\n\t\t * @function\n\t\t * @param {Object} inputChangedEvent the event\n\t\t * @since 8.0\n\t\t */\n\t\tonInputChanged: function onInputChanged(inputChangedEvent) {\n\t\t    return this.dispatchEvent(inputChangedEvent);\n\t\t},\n\t\t/**\n\t\t * @class This object is used to define style information for the text view.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onLineStyle}\n\t\t * </p>\t\t \n\t\t * @name orion.editor.Style\n\t\t * \n\t\t * @property {String} styleClass A CSS class name.\n\t\t * @property {Object} style An object with CSS properties.\n\t\t * @property {String} tagName A DOM tag name.\n\t\t * @property {Object} attributes An object with DOM attributes.\n\t\t */\n\t\t/**\n\t\t * @class This object is used to style range.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onLineStyle}\n\t\t * </p>\t\t \n\t\t * @name orion.editor.StyleRange\n\t\t * \n\t\t * @property {Number} start The start character offset, relative to the document, where the style should be applied.\n\t\t * @property {Number} end The end character offset (exclusive), relative to the document, where the style should be applied.\n\t\t * @property {orion.editor.Style} style The style for the range.\n\t\t */\n\t\t/**\n\t\t * @class This is the event sent when the text view needs the style information for a line.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onLineStyle}\n\t\t * </p>\t\t \n\t\t * @name orion.editor.LineStyleEvent\n\t\t * \n\t\t * @property {orion.editor.TextView} textView The text view.\t\t \n\t\t * @property {Number} lineIndex The line index.\n\t\t * @property {String} lineText The line text.\n\t\t * @property {Number} lineStart The character offset, relative to document, of the first character in the line.\n\t\t * @property {orion.editor.Style} style The style for the entire line (output argument).\n\t\t * @property {orion.editor.StyleRange[]} ranges An array of style ranges for the line (output argument).\t\t \n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view needs the style information for a line.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.LineStyleEvent} lineStyleEvent the event\n\t\t */\n\t\tonLineStyle: function(lineStyleEvent) {\n\t\t\treturn this.dispatchEvent(lineStyleEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent for all keyboard events.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onKeyDown}<br/>\n\t\t * {@link orion.editor.TextView#event:onKeyPress}<br/>\n\t\t * {@link orion.editor.TextView#event:onKeyUp}<br/>\n\t\t * </p>\n\t\t * @name orion.editor.KeyEvent\n\t\t * \n\t\t * @property {String} type The type of event.\n\t\t * @property {DOMEvent} event The key DOM event.\n\t\t * @property {Boolean} defaultPrevented Determines whether the user agent context menu should be shown. It is shown by default.\n\t\t * @property {Function} preventDefault If called prevents the user agent context menu from showing.\n\t\t */\n\t\t/**\n\t\t * This event is sent for key down events.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.KeyEvent} keyEvent the event\n\t\t */\n\t\tonKeyDown: function(keyEvent) {\n\t\t\treturn this.dispatchEvent(keyEvent);\n\t\t},\n\t\t/**\n\t\t * This event is sent for key press events. Key press events are only sent\n\t\t * for printable characters.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.KeyEvent} keyEvent the event\n\t\t */\n\t\tonKeyPress: function(keyEvent) {\n\t\t\treturn this.dispatchEvent(keyEvent);\n\t\t},\n\t\t/**\n\t\t * This event is sent for key up events.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.KeyEvent} keyEvent the event\n\t\t */\n\t\tonKeyUp: function(keyEvent) {\n\t\t\treturn this.dispatchEvent(keyEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text in the model has changed.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onModelChanged}<br/>\n\t\t * {@link orion.editor.TextModel#onChanged}\n\t\t * </p>\n\t\t * @name orion.editor.ModelChangedEvent\n\t\t * \n\t\t * @property {Number} start The character offset in the model where the change has occurred.\n\t\t * @property {Number} removedCharCount The number of characters removed from the model.\n\t\t * @property {Number} addedCharCount The number of characters added to the model.\n\t\t * @property {Number} removedLineCount The number of lines removed from the model.\n\t\t * @property {Number} addedLineCount The number of lines added to the model.\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text in the model has changed.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.ModelChangedEvent} modelChangedEvent the event\n\t\t */\n\t\tonModelChanged: function(modelChangedEvent) {\n\t\t\treturn this.dispatchEvent(modelChangedEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text in the model is about to change.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onModelChanging}<br/>\n\t\t * {@link orion.editor.TextModel#onChanging}\n\t\t * </p>\n\t\t * @name orion.editor.ModelChangingEvent\n\t\t * \n\t\t * @property {String} text The text that is about to be inserted in the model.\n\t\t * @property {Number} start The character offset in the model where the change will occur.\n\t\t * @property {Number} removedCharCount The number of characters being removed from the model.\n\t\t * @property {Number} addedCharCount The number of characters being added to the model.\n\t\t * @property {Number} removedLineCount The number of lines being removed from the model.\n\t\t * @property {Number} addedLineCount The number of lines being added to the model.\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text in the model is about to change.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.ModelChangingEvent} modelChangingEvent the event\n\t\t */\n\t\tonModelChanging: function(modelChangingEvent) {\n\t\t\treturn this.dispatchEvent(modelChangingEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text is modified by the text view.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onModify}\n\t\t * </p>\n\t\t * @name orion.editor.ModifyEvent\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view has changed text in the model.\n\t\t * <p>\n\t\t * If the text is changed directly through the model API, this event\n\t\t * is not sent.\n\t\t * </p>\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.ModifyEvent} modifyEvent the event\n\t\t */\n\t\tonModify: function(modifyEvent) {\n\t\t\treturn this.dispatchEvent(modifyEvent);\n\t\t},\n\t\tonMouseDown: function(mouseEvent) {\n\t\t\treturn this.dispatchEvent(mouseEvent);\n\t\t},\n\t\tonMouseUp: function(mouseEvent) {\n\t\t\treturn this.dispatchEvent(mouseEvent);\n\t\t},\n\t\tonMouseMove: function(mouseEvent) {\n\t\t\treturn this.dispatchEvent(mouseEvent);\n\t\t},\n\t\tonMouseOver: function(mouseEvent) {\n\t\t\treturn this.dispatchEvent(mouseEvent);\n\t\t},\n\t\tonMouseOut: function(mouseEvent) {\n\t\t\treturn this.dispatchEvent(mouseEvent);\n\t\t},\n\t\tonTouchStart: function(touchEvent) {\n\t\t\treturn this.dispatchEvent(touchEvent);\n\t\t},\n\t\tonTouchMove: function(touchEvent) {\n\t\t\treturn this.dispatchEvent(touchEvent);\n\t\t},\n\t\tonTouchEnd: function(touchEvent) {\n\t\t\treturn this.dispatchEvent(touchEvent);\n\t\t},\n\t\tonOptions: function(optionsEvent) {\n\t\t\treturn this.dispatchEvent(optionsEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the selection changes in the text view.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onSelection}\n\t\t * </p>\t\t \n\t\t * @name orion.editor.SelectionEvent\n\t\t * \n\t\t * @property {orion.editor.Selection} oldValue The old selection.\n\t\t * @property {orion.editor.Selection} newValue The new selection.\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view selection has changed.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.SelectionEvent} selectionEvent the event\n\t\t */\n\t\tonSelection: function(selectionEvent) {\n\t\t\treturn this.dispatchEvent(selectionEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text view scrolls.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onScroll}\n\t\t * </p>\t\t \n\t\t * @name orion.editor.ScrollEvent\n\t\t * \n\t\t * @property {Object} oldValue The old scroll {x,y}.\n\t\t * @property {Object} newValue The new scroll {x,y}.\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view scrolls vertically or horizontally.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.ScrollEvent} scrollEvent the event\n\t\t */\n\t\tonScroll: function(scrollEvent) {\n\t\t\treturn this.dispatchEvent(scrollEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text is about to be modified by the text view.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onVerify}\n\t\t * </p>\n\t\t * @name orion.editor.VerifyEvent\n\t\t * \n\t\t * @property {String} text The text being inserted.\n\t\t * @property {Number} start The start offset of the text range to be replaced.\n\t\t * @property {Number} end The end offset (exclusive) of the text range to be replaced.\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view is about to change text in the model.\n\t\t * <p>\n\t\t * If the text is changed directly through the model API, this event\n\t\t * is not sent.\n\t\t * </p>\n\t\t * <p>\n\t\t * Listeners are allowed to change these parameters. Setting text to null\n\t\t * or undefined stops the change.\n\t\t * </p>\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.VerifyEvent} verifyEvent the event\n\t\t */\n\t\tonVerify: function(verifyEvent) {\n\t\t\treturn this.dispatchEvent(verifyEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text view is focused.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onFocus}<br/>\n\t\t * </p>\n\t\t * @name orion.editor.FocusEvent\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view is focused.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.FocusEvent} focusEvent the event\n\t\t */\n\t\tonFocus: function(focusEvent) {\n\t\t\treturn this.dispatchEvent(focusEvent);\n\t\t},\n\t\t/**\n\t\t * @class This is the event sent when the text view goes out of focus.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#event:onBlur}<br/>\n\t\t * </p>\n\t\t * @name orion.editor.BlurEvent\n\t\t */\n\t\t/**\n\t\t * This event is sent when the text view goes out of focus.\n\t\t *\n\t\t * @event\n\t\t * @param {orion.editor.BlurEvent} blurEvent the event\n\t\t */\n\t\tonBlur: function(blurEvent) {\n\t\t\treturn this.dispatchEvent(blurEvent);\n\t\t},\n\t\t/**\n\t\t * Redraws the entire view, including rulers.\n\t\t *\n\t\t * @see orion.editor.TextView#redrawLines\n\t\t * @see orion.editor.TextView#redrawRange\n\t\t * @see orion.editor.TextView#setRedraw\n\t\t */\n\t\tredraw: function() {\n\t\t\tif (this._redrawCount > 0) { return; }\n\t\t\tvar lineCount = this._model.getLineCount();\n\t\t\tthis.redrawRulers(0, lineCount);\n\t\t\tthis.redrawLines(0, lineCount); \n\t\t},\n\t\tredrawRulers: function(startLine, endLine) {\n\t\t\tif (this._redrawCount > 0) { return; }\n\t\t\tvar rulers = this.getRulers();\n\t\t\tfor (var i = 0; i < rulers.length; i++) {\n\t\t\t\tthis.redrawLines(startLine, endLine, rulers[i]);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Redraws the text in the given line range.\n\t\t * <p>\n\t\t * The line at the end index is not redrawn.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} [startLine=0] the start line\n\t\t * @param {Number} [endLine=line count] the end line\n\t\t *\n\t\t * @see orion.editor.TextView#redraw\n\t\t * @see orion.editor.TextView#redrawRange\n\t\t * @see orion.editor.TextView#setRedraw\n\t\t */\n\t\tredrawLines: function(startLine, endLine, ruler) {\n\t\t\tif (this._redrawCount > 0) { return; }\n\t\t\tif (startLine === undefined) { startLine = 0; }\n\t\t\tif (endLine === undefined) { endLine = this._model.getLineCount(); }\n\t\t\tif (startLine === endLine) { return; }\n\t\t\tvar div = this._clientDiv;\n\t\t\tif (!div) { return; }\n\t\t\tif (ruler) {\n\t\t\t\tvar divRuler = this._getRulerParent(ruler);\n\t\t\t\tdiv = divRuler.firstChild;\n\t\t\t\twhile (div) {\n\t\t\t\t\tif (div._ruler === ruler) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdiv = div.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ruler) {\n\t\t\t\tdiv.rulerChanged = true;\n\t\t\t} else {\n\t\t\t\tif (this._lineHeight) {\n\t\t\t\t\tthis._resetLineHeight(startLine, endLine);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar imeLineIndex = -1;\n\t\t\tif (!ruler && this._imeOffset !== -1) {\n\t\t\t\timeLineIndex = this._model.getLineAtOffset(this._imeOffset);\n\t\t\t}\n\t\t\tif (!ruler || ruler.getOverview() === \"page\") { //$NON-NLS-0$\n\t\t\t\tvar child = div.firstChild;\n\t\t\t\twhile (child) {\n\t\t\t\t\tvar lineIndex = child.lineIndex;\n\t\t\t\t\tif (startLine <= lineIndex && lineIndex < endLine && lineIndex !== imeLineIndex) {\n\t\t\t\t\t\tchild.lineChanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ruler) {\n\t\t\t\tif (!this._wrapMode) {\n\t\t\t\t\tif (startLine <= this._maxLineIndex && this._maxLineIndex < endLine) {\n\t\t\t\t\t\tthis._checkMaxLineIndex = this._maxLineIndex;\n\t\t\t\t\t\tthis._maxLineIndex = -1;\n\t\t\t\t\t\tthis._maxLineWidth = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.dispatchEvent({type: \"Redraw\", startLine: startLine, endLine: endLine, ruler: ruler}); //$NON-NLS-0$\n\t\t\tthis._queueUpdate();\n\t\t},\n\t\t/**\n\t\t * Redraws the text in the given range.\n\t\t * <p>\n\t\t * The character at the end offset is not redrawn.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} [start=0] the start offset of text range\n\t\t * @param {Number} [end=char count] the end offset of text range\n\t\t *\n\t\t * @see orion.editor.TextView#redraw\n\t\t * @see orion.editor.TextView#redrawLines\n\t\t * @see orion.editor.TextView#setRedraw\n\t\t */\n\t\tredrawRange: function(start, end) {\n\t\t\tif (this._redrawCount > 0) { return; }\n\t\t\tvar model = this._model;\n\t\t\tif (start === undefined) { start = 0; }\n\t\t\tif (end === undefined) { end = model.getCharCount(); }\n\t\t\tvar startLine = model.getLineAtOffset(start);\n\t\t\tvar endLine = model.getLineAtOffset(Math.max(start, end - 1)) + 1;\n\t\t\tthis.redrawLines(startLine, endLine);\n\t\t},\t\n\t\t/**\n\t\t * Removes a key mode from the text view.\n\t\t *\n\t\t * @param {orion.editor.KeyMode} mode the key mode.\n\t\t */\n\t\tremoveKeyMode: function (mode) {\n\t\t\tvar keyModes = this._keyModes;\n\t\t\tfor (var i=0; i<keyModes.length; i++) {\n\t\t\t\tif (keyModes[i] === mode) {\n\t\t\t\t\tkeyModes.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//TODO: API needed for this\n\t\t\tif (mode._modeRemoved) {\n\t\t\t\tmode._modeRemoved();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Removes a ruler from the text view.\n\t\t *\n\t\t * @param {orion.editor.Ruler} ruler the ruler.\n\t\t */\n\t\tremoveRuler: function (ruler) {\n\t\t\tvar rulers = this._rulers;\n\t\t\tfor (var i=0; i<rulers.length; i++) {\n\t\t\t\tif (rulers[i] === ruler) {\n\t\t\t\t\trulers.splice(i, 1);\n\t\t\t\t\truler.setView(null);\n\t\t\t\t\tthis._destroyRuler(ruler);\n\t\t\t\t\tthis._update();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tresize: function() {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tthis._handleResize(null);\n\t\t},\n\t\t/**\n\t\t * @class This object describes an action for the text view.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView}<br/>\n\t\t * {@link orion.editor.TextView#setAction}\n\t\t * </p>\t\t \n\t\t * @name orion.editor.ActionDescription\n\t\t *\n\t\t * @property {String} [name] the name to be used when showing the action as text.\n\t\t */\n\t\t/**\n\t\t * Associates an application defined handler to an action ID.\n\t\t * <p>\n\t\t * If the action ID is a predefined action, the given handler executes before\n\t\t * the default action handler.  If the given handler returns <code>true</code>, the\n\t\t * default action handler is not called.\n\t\t * </p>\n\t\t *\n\t\t * @param {String} actionID the action ID.\n\t\t * @param {Function} handler the action handler.\n\t\t * @param {orion.editor.ActionDescription} [actionDescription=undefined] the action description.\n\t\t *\n\t\t * @see orion.editor.TextView#getActions\n\t\t * @see orion.editor.TextView#invokeAction\n\t\t */\n\t\tsetAction: function(actionID, handler, actionDescription) {\n\t\t\tif (!actionID) { return; }\n\t\t\tvar actions = this._actions;\n\t\t\tvar action = actions[actionID];\n\t\t\tif (!action) { \n\t\t\t\taction = actions[actionID] = {};\n\t\t\t}\n\t\t\taction.handler = handler;\n\t\t\tif (actionDescription !== undefined) {\n\t\t\t\taction.actionDescription = actionDescription;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Associates a key binding with the given action ID. Any previous\n\t\t * association with the specified key binding is overwriten. If the\n\t\t * action ID is <code>null</code>, the association is removed.\n\t\t * \n\t\t * @param {orion.KeyBinding} keyBinding the key binding\n\t\t * @param {String} actionID the action ID\n\t\t */\n\t\tsetKeyBinding: function(keyBinding, actionID) {\n\t\t\tthis._keyModes[0].setKeyBinding(keyBinding, actionID);\n\t\t},\n\t\t/**\n\t\t * Sets the caret offset relative to the start of the document.\n\t\t *\n\t\t * @param {Number} caret the caret offset relative to the start of the document.\n\t\t * @param {Boolean|Number|orion.editor.TextViewShowOptions} [show=true]\n\t\t * \t\t\t\t\tif <code>true</code>, the view will scroll the minimum amount necessary to show the caret location. If\n\t\t *\t\t\t\t\t<code>show</code> is a <code>Number</code>, the view will scroll the minimum amount necessary to show the caret location plus a\n\t\t *\t\t\t\t\tpercentage of the client area height. The parameter is clamped to the [0,1] range.  In either case, the view will only scroll\n\t\t *\t\t\t\t\tif the new caret location is not visible already.  The <code>show</code> parameter can also be a <code>orion.editor.TextViewShowOptions</code> object. See\n\t\t * \t\t\t\t\t{@link orion.editor.TextViewShowOptions} for further information in how the options can be used to control the scrolling behavior.\n\t\t * @param {Function} [callback] if callback is specified and <code>scrollAnimation</code> is not zero, view scrolling is animated and\n\t\t *\t\t\t\t\tthe callback is called when the animation is done. Otherwise, callback is callback right away.\n\t\t *\n\t\t * @see orion.editor.TextView#getCaretOffset\n\t\t * @see orion.editor.TextView#setSelection\n\t\t * @see orion.editor.TextView#getSelection\n\t\t */\n\t\tsetCaretOffset: function(offset, show, callback) {\n\t\t\tvar charCount = this._model.getCharCount();\n\t\t\toffset = Math.max(0, Math.min (offset, charCount));\n\t\t\tvar selection = new Selection(offset, offset, false);\n\t\t\tthis._setSelection (selection, show === undefined || show, true, callback);\n\t\t},\n\t\t/**\n\t\t * Sets the horizontal pixel.\n\t\t * <p>\n\t\t * The horizontal pixel is the pixel position that is currently at\n\t\t * the left edge of the view.  This position is relative to the\n\t\t * beginning of the document.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} pixel the horizontal pixel.\n\t\t *\n\t\t * @see orion.editor.TextView#getHorizontalPixel\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tsetHorizontalPixel: function(pixel) {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tpixel = Math.max(0, pixel);\n\t\t\tthis._scrollView(pixel - this._getScroll().x, 0);\n\t\t},\n\t\t/**\n\t\t * Sets whether the view should update the DOM.\n\t\t * <p>\n\t\t * This can be used to improve the performance.\n\t\t * </p><p>\n\t\t * When the flag is set to <code>true</code>,\n\t\t * the entire view is marked as needing to be redrawn. \n\t\t * Nested calls to this method are stacked.\n\t\t * </p>\n\t\t *\n\t\t * @param {Boolean} redraw the new redraw state\n\t\t * \n\t\t * @see orion.editor.TextView#redraw\n\t\t */\n\t\tsetRedraw: function(redraw) {\n\t\t\tif (redraw) {\n\t\t\t\tif (--this._redrawCount === 0) {\n\t\t\t\t\tthis.redraw();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._redrawCount++;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets the text model of the text view.\n\t\t *\n\t\t * @param {orion.editor.TextModel} model the text model of the view.\n\t\t */\n\t\tsetModel: function(model) {\n\t\t\tif (model === this._model) { return; }\n\t\t\tmodel = model || new mTextModel.TextModel();\n\t\t\tthis._model.removeEventListener(\"preChanging\", this._modelListener.onChanging); //$NON-NLS-0$\n\t\t\tthis._model.removeEventListener(\"postChanged\", this._modelListener.onChanged); //$NON-NLS-0$\n\t\t\tvar oldLineCount = this._model.getLineCount();\n\t\t\tvar oldCharCount = this._model.getCharCount();\n\t\t\tvar newLineCount = model.getLineCount();\n\t\t\tvar newCharCount = model.getCharCount();\n\t\t\tvar newText = model.getText();\n\t\t\tvar e = {\n\t\t\t\ttype: \"ModelChanging\", //$NON-NLS-0$\n\t\t\t\ttext: newText,\n\t\t\t\tstart: 0,\n\t\t\t\tremovedCharCount: oldCharCount,\n\t\t\t\taddedCharCount: newCharCount,\n\t\t\t\tremovedLineCount: oldLineCount,\n\t\t\t\taddedLineCount: newLineCount\n\t\t\t};\n\t\t\tthis.onModelChanging(e);\n\t\t\tthis._model = model;\n\t\t\te = {\n\t\t\t\ttype: \"ModelChanged\", //$NON-NLS-0$\n\t\t\t\tstart: 0,\n\t\t\t\tremovedCharCount: oldCharCount,\n\t\t\t\taddedCharCount: newCharCount,\n\t\t\t\tremovedLineCount: oldLineCount,\n\t\t\t\taddedLineCount: newLineCount\n\t\t\t};\n\t\t\tthis.onModelChanged(e); \n\t\t\tthis._model.addEventListener(\"preChanging\", this._modelListener.onChanging); //$NON-NLS-0$\n\t\t\tthis._model.addEventListener(\"postChanged\", this._modelListener.onChanged); //$NON-NLS-0$\n\t\t\tthis._reset();\n\t\t\tthis._update();\n\t\t},\n\t\t/**\n\t\t * Sets the view options for the view.\n\t\t *\n\t\t * @param {orion.editor.TextViewOptions} options the view options.\n\t\t * \n\t\t * @see orion.editor.TextView#getOptions\n\t\t */\n\t\tsetOptions: function (options) {\n\t\t\tvar defaultOptions = this._defaultOptions();\n\t\t\tfor (var option in options) {\n\t\t\t\tif (options.hasOwnProperty(option)) {\n\t\t\t\t\tvar newValue = options[option], oldValue = this[\"_\" + option]; //$NON-NLS-0$\n\t\t\t\t\tif (compare(oldValue, newValue)) { continue; }\n\t\t\t\t\tvar update = defaultOptions[option] ? defaultOptions[option].update : null;\n\t\t\t\t\tif (update) {\n\t\t\t\t\t\tupdate.call(this, newValue);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis[\"_\" + option] = clone(newValue); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.onOptions({type: \"Options\", options: options}); //$NON-NLS-0$\n\t\t},\n\t\t/**\n\t\t * @class This object describes the selection show options.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.TextView#setSelection}\n\t\t * {@link orion.editor.TextView#setCaretOffset}\t \n\t\t * {@link orion.editor.TextView#showSelection}\t \n\t\t * </p>\t\t \n\t\t * @name orion.editor.TextViewShowOptions\n\t\t *\n\t\t * @property {String} viewAnchor the view anchor.  The view anchor can be one of these values:\n\t\t * <p>\n\t\t * <ul>\n\t\t *   <li>\"top\" - align the selection to the top of the view client area.</li>\n\t\t *   <li>\"bottom\" - align the selection to the bottom of the view client area.</li>\n\t\t *   <li>\"center\" - align the selection to the center of the view client area.</li>\n\t\t *   <li> by default - align the selection to the top or bottom of the client area depending on whether the caret is above or below the client area respectively. </li>\n\t\t * </ul>\n\t\t * </p>\n\t\t * @property {Number} [viewAnchorOffset=0] an offset from the view anchor. The offset is a percentage of the client area height and it is clamped to [0-1] range.\n\t\t * @property {String} [selectionAnchor=caret] the selection anchor. The seleciton anchor can be one of these values:\n\t\t * <p>\n\t\t * <ul>\n\t\t *   <li>\"top\" - align the top of the selection to the view anchor.</li>\n\t\t *   <li>\"bottom\" - align the bottom of the selection to the view anchor.</li>\n\t\t *   <li>\"center\" - align the center of the selection to the view anchor.</li>\n\t\t *   <li> by default - align the top or bottom of the selection to the view anchor depending on whether the caret is at the start or end of the selection. </li>\n\t\t * </ul>\n\t\t * </p>\n\t\t * @property {String} [scrollPolicy] the scroll policy. The scroll policy can be one of these values:\n\t\t * <p>\n\t\t * <ul>\n\t\t *   <li>\"always\" - always scroll vertically to the desired pixel offset even if the caret is already visible.</li>\n\t\t *   <li> by default - only scroll if the caret is not visible. </li>\n\t\t * </ul>\n\t\t * </p>\n\t\t */\n\t\t/**\n\t\t * Sets the text view selection.\n\t\t * <p>\n\t\t * The selection is defined by a start and end character offset relative to the\n\t\t * document. The character at end offset is not included in the selection.\n\t\t * </p>\n\t\t * <p>\n\t\t * The caret is always placed at the end offset. The start offset can be\n\t\t * greater than the end offset to place the caret at the beginning of the\n\t\t * selection.\n\t\t * </p>\n\t\t * <p>\n\t\t * Clamps out of range offsets.\n\t\t * </p>\n\t\t * \n\t\t * @param {Number} start the start offset of the selection\n\t\t * @param {Number} end the end offset of the selection\n\t\t * @param {Boolean|Number|orion.editor.TextViewShowOptions} [show=true]\n\t\t * \t\t\t\t\tif <code>true</code>, the view will scroll the minimum amount necessary to show the caret location. If\n\t\t *\t\t\t\t\t<code>show</code> is a <code>Number</code>, the view will scroll the minimum amount necessary to show the caret location plus a\n\t\t *\t\t\t\t\tpercentage of the client area height. The parameter is clamped to the [0,1] range.  In either case, the view will only scroll\n\t\t *\t\t\t\t\tif the new caret location is not visible already.  The <code>show</code> parameter can also be a <code>orion.editor.TextViewShowOptions</code> object. See\n\t\t * \t\t\t\t\t{@link orion.editor.TextViewShowOptions} for further information in how the options can be used to control the scrolling behavior.\n\t\t * @param {Function} [callback] if callback is specified and <code>scrollAnimation</code> is not zero, view scrolling is animated and\n\t\t *\t\t\t\t\tthe callback is called when the animation is done. Otherwise, callback is callback right away.\n\t\t *\n\t\t * @see orion.editor.TextView#getSelection\n\t\t */\n\t\tsetSelection: function (start, end, show, callback) {\n\t\t\tvar caret = start > end;\n\t\t\tif (caret) {\n\t\t\t\tvar tmp = start;\n\t\t\t\tstart = end;\n\t\t\t\tend = tmp;\n\t\t\t}\n\t\t\tvar charCount = this._model.getCharCount();\n\t\t\tstart = Math.max(0, Math.min (start, charCount));\n\t\t\tend = Math.max(0, Math.min (end, charCount));\n\t\t\tvar selection = new Selection(start, end, caret);\n\t\t\tthis._setSelection(selection, show === undefined || show, true, callback);\n\t\t},\n\t\tsetSelections: function (ranges, show, callback) {\n\t\t\tvar selections = this._rangesToSelections(ranges);\n\t\t\tthis._setSelection(selections, show === undefined || show, true, callback);\n\t\t},\n\t\t/**\n\t\t * Replaces the text in the given range with the given text.\n\t\t * <p>\n\t\t * The character at the end offset is not replaced.\n\t\t * </p>\n\t\t * <p>\n\t\t * When both <code>start</code> and <code>end</code> parameters\n\t\t * are not specified, the text view places the caret at the beginning\n\t\t * of the document and scrolls to make it visible.\n\t\t * </p>\n\t\t *\n\t\t * @param {String} text the new text.\n\t\t * @param {Number} [start=0] the start offset of text range.\n\t\t * @param {Number} [end=char count] the end offset of text range.\n\t\t * @param {Boolean|Number|orion.editor.TextViewShowOptions} [show=true]\n\t\t * \t\t\t\t\tif <code>true</code>, the view will scroll the minimum amount necessary to show the caret location. If\n\t\t *\t\t\t\t\t<code>show</code> is a <code>Number</code>, the view will scroll the minimum amount necessary to show the caret location plus a\n\t\t *\t\t\t\t\tpercentage of the client area height. The parameter is clamped to the [0,1] range.  In either case, the view will only scroll\n\t\t *\t\t\t\t\tif the new caret location is not visible already.  The <code>show</code> parameter can also be a <code>orion.editor.TextViewShowOptions</code> object. See\n\t\t * \t\t\t\t\t{@link orion.editor.TextViewShowOptions} for further information in how the options can be used to control the scrolling behavior.\n\t\t * @param {Function} [callback] if callback is specified and <code>scrollAnimation</code> is not zero, view scrolling is animated and\n\t\t *\t\t\t\t\tthe callback is called when the animation is done. Otherwise, callback is callback right away.\n\t\t *\n\t\t * @see orion.editor.TextView#getText\n\t\t */\n\t\tsetText: function (text, start, end, show, callback) {\n\t\t\tvar isSingle = typeof text === \"string\"; //$NON-NLS-0$\n\t\t\tvar reset = start === undefined && end === undefined && isSingle;\n\t\t\tvar edit;\n\t\t\tif (isSingle) {\n\t\t\t\tif (start === undefined) { start = 0; }\n\t\t\t\tif (end === undefined) { end = this._model.getCharCount(); }\n\t\t\t\tedit = {text: text, selection: [new Selection(start, end, false)]};\n\t\t\t} else {\n\t\t\t\tedit = text;\n\t\t\t\tedit.selection = this._rangesToSelections(edit.selection);\n\t\t\t}\n\t\t\tedit._code = true;\n\t\t\tif (reset) {\n\t\t\t\tthis._variableLineHeight = false;\n\t\t\t}\n\t\t\tthis._modifyContent(edit, !reset, show === undefined || show, callback);\n\t\t\tif (reset) {\n\t\t\t\t/*\n\t\t\t\t* Bug in Firefox.  For some reason, the caret does not show after the\n\t\t\t\t* view is refreshed.  The fix is to toggle the contentEditable state and\n\t\t\t\t* force the clientDiv to loose and receive focus if it is focused.\n\t\t\t\t*/\n\t\t\t\tif (util.isFirefox < 13) {\n\t\t\t\t\tthis._fixCaret();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets the top index.\n\t\t * <p>\n\t\t * The top index is the line that is currently at the top of the text view.  This\n\t\t * line may be partially visible depending on the vertical scroll of the view.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} topIndex the index of the top line.\n\t\t * @param {Function} [callback] if callback is specified and <code>scrollAnimation</code> is not zero, view scrolling is animated and\n\t\t *\t\t\t\t\tthe callback is called when the animation is done. Otherwise, callback is callback right away.\n\t\t *\n\t\t * @see orion.editor.TextView#getBottomIndex\n\t\t * @see orion.editor.TextView#getTopIndex\n\t\t */\n\t\tsetTopIndex: function(topIndex, callback) {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tthis._scrollViewAnimated(0, this._getLinePixel(Math.max(0, topIndex)) - this._getScroll().y, callback);\n\t\t},\n\t\t/**\n\t\t * Sets the top pixel.\n\t\t * <p>\n\t\t * The top pixel is the pixel position that is currently at\n\t\t * the top edge of the view.  This position is relative to the\n\t\t * beginning of the document.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} pixel the top pixel.\n\t\t * @param {Function} [callback] if callback is specified and <code>scrollAnimation</code> is not zero, view scrolling is animated and\n\t\t *\t\t\t\t\tthe callback is called when the animation is done. Otherwise, callback is callback right away.\n\t\t *\n\t\t * @see orion.editor.TextView#getBottomPixel\n\t\t * @see orion.editor.TextView#getTopPixel\n\t\t * @see orion.editor.TextView#convert\n\t\t */\n\t\tsetTopPixel: function(pixel, callback) {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tthis._scrollViewAnimated(0, Math.max(0, pixel) - this._getScroll().y, callback);\n\t\t},\n\t\t/**\n\t\t * Scrolls the selection into view if needed.\n\t\t *\n \t\t * @param {Number|orion.editor.TextViewShowOptions} [show=0]\n\t\t * \t\t\t\t\tIf <code>show</code> is a <code>Number</code>, the view will scroll the minimum amount necessary to show the caret location plus a\n\t\t *\t\t\t\t\tpercentage of the client area height. The parameter is clamped to the [0,1] range.  The view will only scroll\n\t\t *\t\t\t\t\tif the new caret location is not visible already.  The <code>show</code> parameter can also be a <code>orion.editor.TextViewShowOptions</code> object. See\n\t\t * \t\t\t\t\t{@link orion.editor.TextViewShowOptions} for further information in how the options can be used to control the scrolling behavior.\n\t\t * @param {Function} [callback] if callback is specified and <code>scrollAnimation</code> is not zero, view scrolling is animated and\n\t\t *\t\t\t\t\tthe callback is called when the animation is done. Otherwise, callback is callback right away.\n\t\t *\n\t\t * @returns {Boolean} true if the view was scrolled.\n\t\t *\n\t\t * @see orion.editor.TextView#getSelection\n\t\t * @see orion.editor.TextView#setSelection\n\t\t * @see orion.editor.TextView#setCaretOffset\n\t\t */\n\t\tshowSelection: function(show, callback) {\n\t\t\treturn this._showCaret(show ? false : true, callback, show);\n\t\t},\n\t\tupdate: function(styleChanged, sync) {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tif (styleChanged || this._metrics.invalid) {\n\t\t\t\tthis._updateStyle();\n\t\t\t}\n\t\t\tif (sync === undefined || sync) {\n\t\t\t\tthis._update();\n\t\t\t} else {\n\t\t\t\tthis._queueUpdate();\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**************************************** Event handlers *********************************/\n\t\t_handleRootMouseDown: function (e) {\n\t\t\tthis._cancelCheckSelection();\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (util.isFirefox < 13 && e.which === 1) {\n\t\t\t\tthis._clientDiv.contentEditable = false;\n\t\t\t\t(this._overlayDiv || this._clientDiv).draggable = true;\n\t\t\t\tthis._ignoreBlur = true;\n\t\t\t}\n\t\t\t\n\t\t\t/* Prevent clicks outside of the client div from taking focus away. */\n\t\t\tvar topNode = this._overlayDiv || this._clientDiv;\n\t\t\t/* Use view div on IE 8 otherwise it is not possible to scroll. */\n\t\t\tif (util.isIE < 9) { topNode = this._viewDiv; }\n\t\t\tvar temp = e.target ? e.target : e.srcElement;\n\t\t\twhile (temp) {\n\t\t\t\tif (topNode === temp) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (temp.className && temp.className.indexOf(\"textViewFind\") !== -1) { //$NON-NLS-0$\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttemp = temp.parentNode;\n\t\t\t}\n\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\tif (e.stopPropagation){ e.stopPropagation(); }\n\t\t\tif (!this._isW3CEvents) {\n\t\t\t\t/*\n\t\t\t\t* In IE 8 is not possible to prevent the default handler from running\n\t\t\t\t* during mouse down event using usual API. The workaround is to give\n\t\t\t\t* focus back to the client div.\n\t\t\t\t*/ \n\t\t\t\tvar self = this;\n\t\t\t\tvar window = this._getWindow();\n\t\t\t\twindow.setTimeout(function() {\n\t\t\t\t\tself._clientDiv.focus();\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t},\n\t\t_handleRootMouseUp: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (util.isFirefox < 13 && e.which === 1) {\n\t\t\t\tthis._clientDiv.contentEditable = true;\n\t\t\t\t(this._overlayDiv || this._clientDiv).draggable = false;\n\t\t\t}\n\t\t\tif (util.isFirefox && e.which === 1) {\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t* Bug in Firefox.  For some reason, Firefox stops showing the caret\n\t\t\t\t* in some cases. For example when the user cancels a drag operation \n\t\t\t\t* by pressing ESC.  The fix is to detect that the drag operation was\n\t\t\t\t* cancelled,  toggle the contentEditable state and force the clientDiv\n\t\t\t\t* to loose and receive focus if it is focused.\n\t\t\t\t*/\n\t\t\t\tthis._fixCaret();\n\t\t\t\tthis._ignoreBlur = false;\n\t\t\t}\n\t\t},\n\t\t_handleBlur: function () {\n\t\t\tthis._cancelCheckSelection();\n\t\t\tif (this._ignoreBlur) { return; }\n\t\t\tthis._commitIME();\n\t\t\tthis._hasFocus = false;\n\t\t\t/*\n\t\t\t* Bug in IE 8 and earlier. For some reason when text is deselected\n\t\t\t* the overflow selection at the end of some lines does not get redrawn.\n\t\t\t* The fix is to create a DOM element in the body to force a redraw.\n\t\t\t*/\n\t\t\tif (util.isIE < 9) {\n\t\t\t\tif (!this._getSelections()[0].isEmpty()) {\n\t\t\t\t\tvar rootDiv = this._rootDiv;\n\t\t\t\t\tvar child = util.createElement(rootDiv.ownerDocument, \"div\"); //$NON-NLS-0$\n\t\t\t\t\trootDiv.appendChild(child);\n\t\t\t\t\trootDiv.removeChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._cursorDiv) {\n\t\t\t\tthis._cursorDiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tif (this._domSelection) {\n\t\t\t\tthis._domSelection.forEach(function(domSelection) { domSelection.update(); });\n\t\t\t\t/* Clear browser selection if selection is within clientDiv */\n\t\t\t\tvar temp;\n\t\t\t\tvar window = this._getWindow();\n\t\t\t\tvar document = this._parent.ownerDocument;\n\t\t\t\tif (window.getSelection) {\n\t\t\t\t\tvar sel = window.getSelection();\n\t\t\t\t\ttemp = sel.anchorNode;\n\t\t\t\t\twhile (temp) {\n\t\t\t\t\t\tif (temp === this._clientDiv) {\n\t\t\t\t\t\t\tif (sel.rangeCount > 0) { sel.removeAllRanges(); }\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = temp.parentNode;\n\t\t\t\t\t}\n\t\t\t\t} else if (document.selection) {\n\t\t\t\t\tthis._ignoreSelect = false;\n\t\t\t\t\ttemp = document.selection.createRange().parentElement();\n\t\t\t\t\twhile (temp) {\n\t\t\t\t\t\tif (temp === this._clientDiv) {\n\t\t\t\t\t\t\tdocument.selection.empty();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp = temp.parentNode;\n\t\t\t\t\t}\n\t\t\t\t\tthis._ignoreSelect = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!this._ignoreFocus) {\n\t\t\t\tthis.onBlur({type: \"Blur\"}); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleCompositionStart: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._imeTimeout) {\n\t\t\t\tvar window = this._getWindow();\n\t\t\t\twindow.clearTimeout(this._imeTimeout);\n\t\t\t\tthis._imeTimeout = null;\n\t\t\t}\n\t\t\tif (this._imeText) {\n\t\t\t\tthis._commitIME(this._imeText);\n\t\t\t\tthis._imeText = null;\n\t\t\t}\n\t\t\tthis._startIME();\n\t\t\tif (this._mutationObserver) {\n\t\t\t\tthis._mutationObserver.disconnect();\n\t\t\t\tthis._mutationObserver = null;\n\t\t\t}\n\t\t},\n\t\t_handleCompositionUpdate: function(e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tthis._imeText = e.data;\n\t\t},\n\t\t_handleCompositionEnd: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tthis._imeText = e.data;\n\t\t\tvar window = this._getWindow();\n\t\t\tthis._imeTimeout = window.setTimeout(function() {\n\t\t\t\tthis._commitIME(this._imeText);\n\t\t\t\tthis._imeText = this._imeTimeout = null;\n\t\t\t}.bind(this), 0);\n\t\t},\n\t\t_handleContextMenu: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (util.isIE && this._lastMouseButton === 3) {\n\t\t\t\t// We need to update the DOM selection, because on\n\t\t\t\t// right-click the caret moves to the mouse location.\n\t\t\t\t// See bug 366312 and 376508.\n\t\t\t\tthis._updateDOMSelection();\n\t\t\t}\n\t\t\tvar preventDefault = false;\n\t\t\tif (this.isListening(\"ContextMenu\")) { //$NON-NLS-0$\n\t\t\t\tvar evt = this._createMouseEvent(\"ContextMenu\", e); //$NON-NLS-0$\n\t\t\t\tevt.screenX = e.screenX;\n\t\t\t\tevt.screenY = e.screenY;\n\t\t\t\tthis.onContextMenu(evt);\n\t\t\t\tpreventDefault = evt.defaultPrevented;\n\t\t\t} else if (util.isMac && util.isFirefox && e.button === 0) {\n\t\t\t\t// hack to prevent CTRL+Space from showing the browser context menu\n\t\t\t\tpreventDefault = true;\n\t\t\t}\n\t\t\tif (preventDefault) {\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthis._contextMenuOpen = true;\n\t\t\t\tif (util.isFirefox) {\n\t\t\t\t\tthis._checkSelectionChange = true;\n\t\t\t\t\tthis._pollSelectionChange(true);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_handleCopy: function (e) {\n\t\t\tthis._cancelCheckSelection();\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._ignoreCopy) { return; }\n\t\t\tif (this._doCopy(e)) {\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleCut: function (e) {\n\t\t\tthis._cancelCheckSelection();\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._doCut(e)) {\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleDataModified: function(e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tthis._startIME();\n\t\t},\n\t\t_handleDblclick: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tvar time = e.timeStamp ? e.timeStamp : new Date().getTime();\n\t\t\tthis._lastMouseTime = time;\n\t\t\tif (this._clickCount !== 2) {\n\t\t\t\tthis._clickCount = 2;\n\t\t\t\tthis._handleMouse(e);\n\t\t\t}\n\t\t},\n\t\t_handleDragStart: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (util.isFirefox < 13) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar window = this._getWindow();\n\t\t\t\twindow.setTimeout(function() {\n\t\t\t\t\tself._clientDiv.contentEditable = true;\n\t\t\t\t\tself._clientDiv.draggable = false;\n\t\t\t\t\tself._ignoreBlur = false;\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t\tif (this.isListening(\"DragStart\") && this._dragOffset !== -1) { //$NON-NLS-0$\n\t\t\t\tthis._isMouseDown = false;\n\t\t\t\tthis.onDragStart(this._createMouseEvent(\"DragStart\", e)); //$NON-NLS-0$\n\t\t\t\tthis._dragOffset = -1;\n\t\t\t} else {\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleDrag: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this.isListening(\"Drag\")) { //$NON-NLS-0$\n\t\t\t\tthis.onDrag(this._createMouseEvent(\"Drag\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleDragEnd: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tthis._dropTarget = false;\n\t\t\tthis._dragOffset = -1;\n\t\t\tif (this.isListening(\"DragEnd\")) { //$NON-NLS-0$\n\t\t\t\tthis.onDragEnd(this._createMouseEvent(\"DragEnd\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t\tif (util.isFirefox < 13) {\n\t\t\t\tthis._fixCaret();\n\t\t\t\t/*\n\t\t\t\t* Bug in Firefox.  For some reason, Firefox stops showing the caret when the \n\t\t\t\t* selection is dropped onto itself. The fix is to detected the case and \n\t\t\t\t* call fixCaret() a second time.\n\t\t\t\t*/\n\t\t\t\tif (e.dataTransfer.dropEffect === \"none\" && !e.dataTransfer.mozUserCancelled) { //$NON-NLS-0$\n\t\t\t\t\tthis._fixCaret();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_handleDragEnter: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tvar prevent = true;\n\t\t\tthis._dropTarget = true;\n\t\t\tif (this.isListening(\"DragEnter\")) { //$NON-NLS-0$\n\t\t\t\tprevent = false;\n\t\t\t\tthis.onDragEnter(this._createMouseEvent(\"DragEnter\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t\t/*\n\t\t\t* Webkit will not send drop events if this event is not prevented, as spec in HTML5.\n\t\t\t* Firefox and IE do not follow this spec for contentEditable. Note that preventing this \n\t\t\t* event will result is loss of functionality (insertion mark, etc).\n\t\t\t*/\n\t\t\tif (util.isWebkit || prevent) {\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleDragOver: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tvar prevent = true;\n\t\t\tif (this.isListening(\"DragOver\")) { //$NON-NLS-0$\n\t\t\t\tprevent = false;\n\t\t\t\tthis.onDragOver(this._createMouseEvent(\"DragOver\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t\t/*\n\t\t\t* Webkit will not send drop events if this event is not prevented, as spec in HTML5.\n\t\t\t* Firefox and IE do not follow this spec for contentEditable. Note that preventing this \n\t\t\t* event will result is loss of functionality (insertion mark, etc).\n\t\t\t*/\n\t\t\tif (util.isWebkit || prevent) {\n\t\t\t\tif (prevent) { e.dataTransfer.dropEffect = \"none\"; } //$NON-NLS-0$\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleDragLeave: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tthis._dropTarget = false;\n\t\t\tif (this.isListening(\"DragLeave\")) { //$NON-NLS-0$\n\t\t\t\tthis.onDragLeave(this._createMouseEvent(\"DragLeave\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleDrop: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tthis._dropTarget = false;\n\t\t\tif (this.isListening(\"Drop\")) { //$NON-NLS-0$\n\t\t\t\tthis.onDrop(this._createMouseEvent(\"Drop\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t\t/*\n\t\t\t* This event must be prevented otherwise the user agent will modify\n\t\t\t* the DOM. Note that preventing the event on some user agents (i.e. IE)\n\t\t\t* indicates that the operation is cancelled. This causes the dropEffect to \n\t\t\t* be set to none  in the dragend event causing the implementor to not execute\n\t\t\t* the code responsible by the move effect.\n\t\t\t*/\n\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\treturn false;\n\t\t},\n\t\t_handleFocus: function () {\n\t\t\tthis._hasFocus = true;\n\t\t\tif (util.isIOS && this._lastTouchOffset !== undefined) {\n\t\t\t\tthis.setCaretOffset(this._lastTouchOffset, true);\n\t\t\t\tthis._lastTouchOffset = undefined;\n\t\t\t} else {\n\t\t\t\tthis._updateDOMSelection();\n\t\t\t}\n\t\t\tif (this._cursorDiv) {\n\t\t\t\tthis._cursorDiv.style.display = \"block\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tif (this._domSelection) {\n\t\t\t\tthis._domSelection.forEach(function(domSelection) { domSelection.update(); });\n\t\t\t}\n\t\t\tif (!this._ignoreFocus) {\n\t\t\t\tthis.onFocus({type: \"Focus\"}); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleKeyDown: function (e) {\n\t\t\tthis._cancelCheckSelection();\n\t\t\tif (this._ignoreEvent(e)) {\treturn;\t}\n\t\t\tif (this.isListening(\"KeyDown\")) { //$NON-NLS-0$\n\t\t\t\tvar keyEvent = this._createKeyEvent(\"KeyDown\", e); //$NON-NLS-0$\n\t\t\t\tthis.onKeyDown(keyEvent); //$NON-NLS-0$\n\t\t\t\tif (keyEvent.defaultPrevented) {\n\t\t\t\t\t/*\n\t\t\t\t\t* Feature in Firefox. Keypress events still happen even if the keydown event\n\t\t\t\t\t* was prevented. The fix is to remember that keydown was prevented and prevent\n\t\t\t\t\t* the keypress ourselves.\n\t\t\t\t\t*/\n\t\t\t\t\tif (util.isFirefox) {\n\t\t\t\t\t\tthis._keyDownPrevented = true;\n\t\t\t\t\t}\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar modifier = false;\n\t\t\tswitch (e.keyCode) {\n\t\t\t\tcase 16: /* Shift */\n\t\t\t\tcase 17: /* Control */\n\t\t\t\tcase 18: /* Alt */\n\t\t\t\tcase 91: /* Command */\n\t\t\t\t\tmodifier = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis._setLinksVisible(false);\n\t\t\t}\n\t\t\tif (e.keyCode === 229) {\n\t\t\t\tif (this._readonly) {\n\t\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar startIME = true;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t* Bug in Safari. Some Control+key combinations send key events\n\t\t\t\t* with keyCode equals to 229. This is unexpected and causes the\n\t\t\t\t* view to start an IME composition. The fix is to ignore these\n\t\t\t\t* events.\n\t\t\t\t*/\n\t\t\t\tif (util.isSafari && util.isMac) {\n\t\t\t\t\tif (e.ctrlKey) {\n\t\t\t\t\t\tstartIME = false;\n\t\t\t\t\t\te.keyCode = 0x81;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (startIME) {\n\t\t\t\t\tthis._startIME();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!modifier) {\n\t\t\t\t\tthis._commitIME();\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t* Feature in Firefox. When a key is held down the browser sends \n\t\t\t* right number of keypress events but only one keydown. This is\n\t\t\t* unexpected and causes the view to only execute an action\n\t\t\t* just one time. The fix is to ignore the keydown event and \n\t\t\t* execute the actions from the keypress handler.\n\t\t\t* Note: This only happens on the Mac and Linux (Firefox 3.6).\n\t\t\t*\n\t\t\t* Feature in Opera < 12.16.  Opera sends keypress events even for non-printable\n\t\t\t* keys.  The fix is to handle actions in keypress instead of keydown.\n\t\t\t*/\n\t\t\tif (((util.isMac || util.isLinux) && util.isFirefox < 4) || util.isOpera < 12.16) {\n\t\t\t\tthis._keyDownEvent = e;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif (this._doAction(e)) {\n\t\t\t\tif (e.preventDefault) {\n\t\t\t\t\te.preventDefault(); \n\t\t\t\t\te.stopPropagation(); \n\t\t\t\t} else {\n\t\t\t\t\te.cancelBubble = true;\n\t\t\t\t\te.returnValue = false;\n\t\t\t\t\te.keyCode = 0;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleKeyPress: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\t/*\n\t\t\t* Feature in Firefox. Keypress events still happen even if the keydown event\n\t\t\t* was prevented. The fix is to remember that keydown was prevented and prevent\n\t\t\t* the keypress ourselves.\n\t\t\t*/\n\t\t\tif (this._keyDownPrevented) { \n\t\t\t\tif (e.preventDefault) {\n\t\t\t\t\te.preventDefault(); \n\t\t\t\t\te.stopPropagation(); \n\t\t\t\t} \n\t\t\t\tthis._keyDownPrevented = undefined;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t* Feature in Embedded WebKit.  Embedded WekKit on Mac runs in compatibility mode and\n\t\t\t* generates key press events for these Unicode values (Function keys).  This does not\n\t\t\t* happen in Safari or Chrome.  The fix is to ignore these key events.\n\t\t\t*/\n\t\t\tif (util.isMac && util.isWebkit) {\n\t\t\t\tif ((0xF700 <= e.keyCode && e.keyCode <= 0xF7FF) || e.keyCode === 13 || e.keyCode === 8) {\n\t\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (((util.isMac || util.isLinux) && util.isFirefox < 4) || util.isOpera < 12.16) {\n\t\t\t\tif (this._doAction(this._keyDownEvent)) {\n\t\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ctrlKey = util.isMac ? e.metaKey : e.ctrlKey;\n\t\t\tif (e.charCode !== undefined) {\n\t\t\t\tif (ctrlKey) {\n\t\t\t\t\tswitch (e.charCode) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t* In Firefox and Safari if ctrl+v, ctrl+c ctrl+x is canceled\n\t\t\t\t\t\t* the clipboard events are not sent. The fix to allow\n\t\t\t\t\t\t* the browser to handles these key events.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tcase 99://c\n\t\t\t\t\t\tcase 118://v\n\t\t\t\t\t\tcase 120://x\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.isListening(\"KeyPress\")) { //$NON-NLS-0$\n\t\t\t\tvar keyEvent = this._createKeyEvent(\"KeyPress\", e); //$NON-NLS-0$\n\t\t\t\tthis.onKeyPress(keyEvent); //$NON-NLS-0$\n\t\t\t\tif (keyEvent.defaultPrevented) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._doAction(e)) {\n\t\t\t\tif (e.preventDefault) {\n\t\t\t\t\te.preventDefault(); \n\t\t\t\t\te.stopPropagation(); \n\t\t\t\t} else {\n\t\t\t\t\te.cancelBubble = true;\n\t\t\t\t\te.returnValue = false;\n\t\t\t\t\te.keyCode = 0;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar ignore = false;\n\t\t\tif (util.isMac) {\n\t\t\t\tif (e.ctrlKey || e.metaKey) { ignore = true; }\n\t\t\t} else {\n\t\t\t\tif (util.isFirefox) {\n\t\t\t\t\t//Firefox clears the state mask when ALT GR generates input\n\t\t\t\t\tif (e.ctrlKey || e.altKey) { ignore = true; }\n\t\t\t\t} else {\n\t\t\t\t\t//IE and Chrome only send ALT GR when input is generated\n\t\t\t\t\tif (e.ctrlKey ^ e.altKey) { ignore = true; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ignore) {\n\t\t\t\tvar key = util.isOpera ? e.which : (e.charCode !== undefined ? e.charCode : e.keyCode);\n\t\t\t\tif (key > 31) {\n\t\t\t\t\tthis._doContent(String.fromCharCode (key));\n\t\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_handleDocKeyUp: function (e) {\n\t\t\tvar ctrlKey = util.isMac ? e.metaKey : e.ctrlKey;\n\t\t\tif (!ctrlKey) {\n\t\t\t\tthis._setLinksVisible(false);\n\t\t\t}\n\t\t},\n\t\t_handleKeyUp: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this.isListening(\"KeyUp\")) { //$NON-NLS-0$\n\t\t\t\tvar keyEvent = this._createKeyEvent(\"KeyUp\", e); //$NON-NLS-0$\n\t\t\t\tthis.onKeyUp(keyEvent); //$NON-NLS-0$\n\t\t\t\tif (keyEvent.defaultPrevented) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._handleDocKeyUp(e);\n\t\t\t// don't commit for space (it happens during JP composition)  \n\t\t\tif (e.keyCode === 13) {\n\t\t\t\tthis._commitIME();\n\t\t\t}\n\t\t},\n\t\t_handleLinkClick: function (e) {\n\t\t\tvar ctrlKey = util.isMac ? e.metaKey : e.ctrlKey;\n\t\t\tif (!ctrlKey) {\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleMouse: function (e) {\n\t\t\tvar window = this._getWindow();\n\t\t\tvar result = true;\n\t\t\tvar target = window;\n\t\t\tif (util.isIE || (util.isFirefox && !this._overlayDiv)) { target = this._clientDiv; }\n\t\t\tif (this._overlayDiv) {\n\t\t\t\tif (this._hasFocus) {\n\t\t\t\t\tthis._ignoreFocus = true;\n\t\t\t\t}\n\t\t\t\tvar self = this;\n\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\tself.focus();\n\t\t\t\t\tself._ignoreFocus = false;\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t\tvar extend = e.shiftKey;\n\t\t\tvar block = e.altKey;\n\t\t\tvar add = util.isMac ? e.metaKey : e.ctrlKey;\n\t\t\tthis._blockSelection = this._doubleClickSelection = null;\n\t\t\tif (this._clickCount === 1) {\n\t\t\t\tvar drag = (!util.isOpera || util.isOpera >= 12.16) && this._hasFocus && this.isListening(\"DragStart\"); //$NON-NLS-0$\n\t\t\t\tresult = this._setSelectionTo(e.clientX, e.clientY, true, extend, add, drag);\n\t\t\t\tif (result) { this._setGrab(target); }\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* Feature in IE8 and older, the sequence of events in the IE8 event model\n\t\t\t\t* for a doule-click is:\n\t\t\t\t*\n\t\t\t\t*\tdown\n\t\t\t\t*\tup\n\t\t\t\t*\tup\n\t\t\t\t*\tdblclick\n\t\t\t\t*\n\t\t\t\t* Given that the mouse down/up events are not balanced, it is not possible to\n\t\t\t\t* grab on mouse down and ungrab on mouse up.  The fix is to grab on the first\n\t\t\t\t* mouse down and ungrab on mouse move when the button 1 is not set.\n\t\t\t\t*/\n\t\t\t\tif (this._isW3CEvents) { this._setGrab(target); }\n\t\t\t\t\n\t\t\t\tthis._setSelectionTo(e.clientX, e.clientY, true, extend, add, false);\n\t\t\t\tthis._doubleClickSelection = Selection.editing(this._getSelections());\n\t\t\t}\n\t\t\tif (block) {\n\t\t\t\tthis._blockSelection = Selection.editing(this._getSelections());\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t_handleMouseDown: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._linksVisible) {\n\t\t\t\tvar target = e.target || e.srcElement;\n\t\t\t\tif (target.tagName !== \"A\") { //$NON-NLS-0$\n\t\t\t\t\tthis._setLinksVisible(false);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._commitIME();\n\n\t\t\tvar button = e.which; // 1 - left, 2 - middle, 3 - right\n\t\t\tif (!button) { \n\t\t\t\t// if IE 8 or older\n\t\t\t\tif (e.button === 4) { button = 2; }\n\t\t\t\tif (e.button === 2) { button = 3; }\n\t\t\t\tif (e.button === 1) { button = 1; }\n\t\t\t}\n\n\t\t\t// For middle click we always need getTime(). See _getClipboardText().\n\t\t\tvar time = button !== 2 && e.timeStamp ? e.timeStamp : new Date().getTime();\n\t\t\tvar timeDiff = time - this._lastMouseTime;\n\t\t\tvar deltaX = Math.abs(this._lastMouseX - e.clientX);\n\t\t\tvar deltaY = Math.abs(this._lastMouseY - e.clientY);\n\t\t\tvar sameButton = this._lastMouseButton === button;\n\t\t\tthis._lastMouseX = e.clientX;\n\t\t\tthis._lastMouseY = e.clientY;\n\t\t\tthis._lastMouseTime = time;\n\t\t\tthis._lastMouseButton = button;\n\n\t\t\tif (button === 1) {\n\t\t\t\tthis._isMouseDown = true;\n\t\t\t\tif (sameButton && timeDiff <= this._clickTime && deltaX <= this._clickDist && deltaY <= this._clickDist) {\n\t\t\t\t\tthis._clickCount++;\n\t\t\t\t} else {\n\t\t\t\t\tthis._clickCount = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.isListening(\"MouseDown\")) { //$NON-NLS-0$\n\t\t\t\tvar mouseEvent = this._createMouseEvent(\"MouseDown\", e); //$NON-NLS-0$\n\t\t\t\tthis.onMouseDown(mouseEvent);\n\t\t\t\tif (mouseEvent.defaultPrevented) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (button === 1) {\n\t\t\t\tif (this._handleMouse(e) && (util.isIE >= 9 || util.isOpera || util.isChrome || util.isSafari || (util.isFirefox && !this._overlayDiv))) {\n\t\t\t\t\tif (!this._hasFocus) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t}\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (util.isFirefox && this._lastMouseButton === 3) {\n\t\t\t\t// We need to update the DOM selection, because on\n\t\t\t\t// right-click the caret moves to the mouse location.\n\t\t\t\t// See bug 366312 and 376508.\n\t\t\t\tthis._updateDOMSelection();\n\t\t\t}\n\t\t},\n\t\t_handleMouseOver: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._animation) { return; }\n\t\t\tif (this.isListening(\"MouseOver\")) { //$NON-NLS-0$\n\t\t\t\tthis.onMouseOver(this._createMouseEvent(\"MouseOver\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleMouseOut: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._animation) { return; }\n\t\t\tif (this.isListening(\"MouseOut\")) { //$NON-NLS-0$\n\t\t\t\tthis.onMouseOut(this._createMouseEvent(\"MouseOut\", e)); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleMouseMove: function (e) {\n\t\t\tif (this._animation) { return; }\n\t\t\tvar inClient = this._isClientDiv(e);\n\t\t\tif (this.isListening(\"MouseMove\")) { //$NON-NLS-0$\n\t\t\t\tif (inClient || this._isMouseDown){\n\t\t\t\t\tvar mouseEvent = this._createMouseEvent(\"MouseMove\", e); //$NON-NLS-0$\n\t\t\t\t\tthis.onMouseMove(mouseEvent);\n\t\t\t\t\tif (mouseEvent.defaultPrevented) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._dropTarget) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t* Bug in IE9. IE sends one mouse event when the user changes the text by\n\t\t\t* pasting or undo.  These operations usually happen with the Ctrl key\n\t\t\t* down which causes the view to enter link mode.  Link mode does not end\n\t\t\t* because there are no further events.  The fix is to only enter link\n\t\t\t* mode when the coordinates of the mouse move event have changed.\n\t\t\t*/\n\t\t\tvar changed = this._linksVisible || this._lastMouseMoveX !== e.clientX || this._lastMouseMoveY !== e.clientY;\n\t\t\tthis._lastMouseMoveX = e.clientX;\n\t\t\tthis._lastMouseMoveY = e.clientY;\n\t\t\tthis._setLinksVisible(changed && !this._isMouseDown && e.altKey && (util.isMac ? e.metaKey : e.ctrlKey));\n\n\t\t\tthis._checkOverlayScroll();\n\n\t\t\t/*\n\t\t\t* Feature in IE8 and older, the sequence of events in the IE8 event model\n\t\t\t* for a doule-click is:\n\t\t\t*\n\t\t\t*\tdown\n\t\t\t*\tup\n\t\t\t*\tup\n\t\t\t*\tdblclick\n\t\t\t*\n\t\t\t* Given that the mouse down/up events are not balanced, it is not possible to\n\t\t\t* grab on mouse down and ungrab on mouse up.  The fix is to grab on the first\n\t\t\t* mouse down and ungrab on mouse move when the button 1 is not set.\n\t\t\t*\n\t\t\t* In order to detect double-click and drag gestures, it is necessary to send\n\t\t\t* a mouse down event from mouse move when the button is still down and isMouseDown\n\t\t\t* flag is not set.\n\t\t\t*/\n\t\t\tif (!this._isW3CEvents) {\n\t\t\t\tif (e.button === 0) {\n\t\t\t\t\tthis._setGrab(null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!this._isMouseDown && e.button === 1 && (this._clickCount & 1) !== 0 && inClient) {\n\t\t\t\t\tthis._clickCount = 2;\n\t\t\t\t\treturn this._handleMouse(e, this._clickCount);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!this._isMouseDown || this._dragOffset !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar x = e.clientX;\n\t\t\tvar y = e.clientY;\n\t\t\tvar viewPad = this._getViewPadding();\n\t\t\tvar viewRect = this._viewDiv.getBoundingClientRect();\n\t\t\tvar width = this._getClientWidth (), height = this._getClientHeight();\n\t\t\tvar leftEdge = viewRect.left + viewPad.left;\n\t\t\tvar topEdge = viewRect.top + viewPad.top;\n\t\t\tvar rightEdge = viewRect.left + viewPad.left + width;\n\t\t\tvar bottomEdge = viewRect.top + viewPad.top + height;\n\t\t\tif (y < topEdge) {\n\t\t\t\tthis._doAutoScroll(\"up\", x, y - topEdge); //$NON-NLS-0$\n\t\t\t} else if (y > bottomEdge) {\n\t\t\t\tthis._doAutoScroll(\"down\", x, y - bottomEdge); //$NON-NLS-0$\n\t\t\t} else if (x < leftEdge && !this._wrapMode) {\n\t\t\t\tthis._doAutoScroll(\"left\", x - leftEdge, y); //$NON-NLS-0$\n\t\t\t} else if (x > rightEdge && !this._wrapMode) {\n\t\t\t\tthis._doAutoScroll(\"right\", x - rightEdge, y); //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tthis._endAutoScroll();\n\t\t\t\tthis._setSelectionTo(x, y, false, true);\n\t\t\t}\n\t\t},\n\t\t_isClientDiv: function(e) {\n\t\t\tvar topNode = this._overlayDiv || this._clientDiv;\n\t\t\tvar temp = e.target ? e.target : e.srcElement;\n\t\t\twhile (temp) {\n\t\t\t\tif (topNode === temp) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttemp = temp.parentNode;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t_createKeyEvent: function(type, e) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tevent: e,\n\t\t\t\tpreventDefault: function() {\n\t\t\t\t\tthis.defaultPrevented = true;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t_createMouseEvent: function(type, e) {\n\t\t\tvar pt = this.convert({x: e.clientX, y: e.clientY}, \"page\", \"document\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tevent: e,\n\t\t\t\tclickCount: this._clickCount,\n\t\t\t\tx: pt.x,\n\t\t\t\ty: pt.y,\n\t\t\t\tpreventDefault: function() {\n\t\t\t\t\tthis.defaultPrevented = true;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t_createTouchEvent: function(type, e) {\n\t\t\tvar pt = e.touches.length ? this.convert({x: e.touches[0].clientX, y: e.touches[0].clientY}, \"page\", \"document\") : {}; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tevent: e,\n\t\t\t\ttouchCount: e.touches.length,\n\t\t\t\tx: pt.x,\n\t\t\t\ty: pt.y,\n\t\t\t\tpreventDefault: function() {\n\t\t\t\t\tthis.defaultPrevented = true;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t_handleMouseUp: function (e) {\n\t\t\tvar left = e.which ? e.button === 0 : e.button === 1;\n\t\t\tif (this.isListening(\"MouseUp\")) { //$NON-NLS-0$\n\t\t\t\tif (this._isClientDiv(e) || (left && this._isMouseDown)) {\n\t\t\t\t\tvar mouseEvent = this._createMouseEvent(\"MouseUp\", e); //$NON-NLS-0$\n\t\t\t\t\tthis.onMouseUp(mouseEvent);\n\t\t\t\t\tif (mouseEvent.defaultPrevented) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tthis._isMouseDown = false;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._linksVisible) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (left && this._isMouseDown) {\n\t\t\t\tvar selections = this._getSelections();\n\t\t\t\tvar selection = Selection.editing(selections);\n\t\t\t\tselections.forEach(function(sel) {\n\t\t\t\t\tsel._editing = false;\n\t\t\t\t});\n\t\t\t\tif (this._dragOffset !== -1) {\n\t\t\t\t\tselection.extend(this._dragOffset);\n\t\t\t\t\tselection.collapse();\n\t\t\t\t\tselections = selection;\n\t\t\t\t\tthis._dragOffset = -1;\n\t\t\t\t}\n\t\t\t\tthis._setSelection(selections, false);\n\t\t\t\tthis._isMouseDown = false;\n\t\t\t\tthis._endAutoScroll();\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t* Feature in IE8 and older, the sequence of events in the IE8 event model\n\t\t\t\t* for a doule-click is:\n\t\t\t\t*\n\t\t\t\t*\tdown\n\t\t\t\t*\tup\n\t\t\t\t*\tup\n\t\t\t\t*\tdblclick\n\t\t\t\t*\n\t\t\t\t* Given that the mouse down/up events are not balanced, it is not possible to\n\t\t\t\t* grab on mouse down and ungrab on mouse up.  The fix is to grab on the first\n\t\t\t\t* mouse down and ungrab on mouse move when the button 1 is not set.\n\t\t\t\t*/\n\t\t\t\tif (this._isW3CEvents) { this._setGrab(null); }\n\t\t\t}\n\t\t\t/*\n\t\t\t* Note that there cases when Firefox sets the DOM selection in mouse up.\n\t\t\t* This happens for example after a cancelled drag operation.\n\t\t\t*\n\t\t\t* Note that on Chrome and IE, the caret stops blicking if mouse up is\n\t\t\t* prevented.\n\t\t\t*/\n\t\t\tif (left && util.isFirefox) {\n\t\t\t\tthis._updateDOMSelection();\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\t_handleMouseWheel: function (e) {\n\t\t\tif (this._noScroll) return;\n\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\tvar pixelX = 0, pixelY = 0;\n\t\t\t// Note: On the Mac the correct behaviour is to scroll by pixel.\n\t\t\tif (util.isIE || util.isOpera) {\n\t\t\t\tpixelY = (-e.wheelDelta / 40) * lineHeight;\n\t\t\t} else if (util.isFirefox) {\n\t\t\t\tvar limit = 256;\n\t\t\t\tif (e.type === \"wheel\") { //$NON-NLS-0$\n\t\t\t\t\tif (e.deltaMode) { // page or line\n\t\t\t\t\t\tpixelX = Math.max(-limit, Math.min(limit, e.deltaX)) * lineHeight;\n\t\t\t\t\t\tpixelY = Math.max(-limit, Math.min(limit, e.deltaY)) * lineHeight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixelX = e.deltaX;\n\t\t\t\t\t\tpixelY = e.deltaY;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar pixel;\n\t\t\t\t\tif (util.isMac) {\n\t\t\t\t\t\tpixel = e.detail * 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = Math.max(-limit, Math.min(limit, e.detail)) * lineHeight;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.axis === e.HORIZONTAL_AXIS) {\n\t\t\t\t\t\tpixelX = pixel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixelY = pixel;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Webkit\n\t\t\t\tif (util.isMac) {\n\t\t\t\t\t/*\n\t\t\t\t\t* In Safari, the wheel delta is a multiple of 120. In order to\n\t\t\t\t\t* convert delta to pixel values, it is necessary to divide delta\n\t\t\t\t\t* by 40.\n\t\t\t\t\t*\n\t\t\t\t\t* In Chrome and Safari 5, the wheel delta depends on the type of the\n\t\t\t\t\t* mouse. In general, it is the pixel value for Mac mice and track pads,\n\t\t\t\t\t* but it is a multiple of 120 for other mice. There is no presise\n\t\t\t\t\t* way to determine if it is pixel value or a multiple of 120.\n\t\t\t\t\t* \n\t\t\t\t\t* Note that the current approach does not calculate the correct\n\t\t\t\t\t* pixel value for Mac mice when the delta is a multiple of 120.\n\t\t\t\t\t*\n\t\t\t\t\t* For values that are multiples of 120, the denominator varies on\n\t\t\t\t\t* the time between events.\n\t\t\t\t\t*/\n\t\t\t\t\tvar denominatorX, denominatorY;\n\t\t\t\t\tvar deltaTime = e.timeStamp - this._wheelTimeStamp;\n\t\t\t\t\tthis._wheelTimeStamp = e.timeStamp;\n\t\t\t\t\tif (e.wheelDeltaX % 120 !== 0) { \n\t\t\t\t\t\tdenominatorX = 1; \n\t\t\t\t\t} else {\n\t\t\t\t\t\tdenominatorX = deltaTime < 40 ? 40/(40-deltaTime) : 40;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.wheelDeltaY % 120 !== 0) { \n\t\t\t\t\t\tdenominatorY = 1; \n\t\t\t\t\t} else {\n\t\t\t\t\t\tdenominatorY = deltaTime < 40 ? 40/(40-deltaTime) : 40; \n\t\t\t\t\t}\n\t\t\t\t\tpixelX = Math.ceil(-e.wheelDeltaX / denominatorX);\n\t\t\t\t\tif (-1 < pixelX && pixelX < 0) { pixelX = -1; }\n\t\t\t\t\tif (0 < pixelX && pixelX < 1) { pixelX = 1; }\n\t\t\t\t\tpixelY = Math.ceil(-e.wheelDeltaY / denominatorY);\n\t\t\t\t\tif (-1 < pixelY && pixelY < 0) { pixelY = -1; }\n\t\t\t\t\tif (0 < pixelY && pixelY < 1) { pixelY = 1; }\n\t\t\t\t} else {\n\t\t\t\t\tpixelX = -e.wheelDeltaX;\n\t\t\t\t\tvar linesToScroll = 8;\n\t\t\t\t\tpixelY = (-e.wheelDeltaY / 120 * linesToScroll) * lineHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* \n\t\t\t* Feature in Safari. If the event target is removed from the DOM \n\t\t\t* safari stops smooth scrolling. The fix is keep the element target\n\t\t\t* in the DOM and remove it on a later time. \n\t\t\t*\n\t\t\t* Note: Using a timer is not a solution, because the timeout needs to\n\t\t\t* be at least as long as the gesture (which is too long).\n\t\t\t*/\n\t\t\tif (util.isSafari || (util.isChrome && util.isMac)) {\n\t\t\t\tvar lineDiv = e.target;\n\t\t\t\twhile (lineDiv && lineDiv.lineIndex === undefined) {\n\t\t\t\t\tlineDiv = lineDiv.parentNode;\n\t\t\t\t}\n\t\t\t\tthis._mouseWheelLine = lineDiv;\n\t\t\t}\n\t\t\tvar oldScroll = this._getScroll();\n\t\t\tthis._scrollView(pixelX, pixelY);\n\t\t\tvar newScroll = this._getScroll();\n\t\t\tif (oldScroll.x !== newScroll.x || oldScroll.y !== newScroll.y) {\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handlePaste: function (e) {\n\t\t\tthis._cancelCheckSelection();\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._ignorePaste) { return; }\n\t\t\tif (this._doPaste(e)) {\n\t\t\t\tif (util.isIE) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Bug in IE,  \n\t\t\t\t\t */\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tthis._ignoreFocus = true;\n\t\t\t\t\tvar window = this._getWindow();\n\t\t\t\t\twindow.setTimeout(function() {\n\t\t\t\t\t\tself._updateDOMSelection();\n\t\t\t\t\t\tself._ignoreFocus = false;\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t\tif (e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_handleResize: function () {\n\t\t\tvar newWidth = this._rootDiv.clientWidth;\n\t\t\tvar newHeight = this._rootDiv.clientHeight;\n\t\t\tif (this._rootWidth !== newWidth || this._rootHeight !== newHeight) {\n\t\t\t\tif (this._rootWidth !== newWidth && this._wrapMode) {\n\t\t\t\t\tthis._resetLineHeight();\n\t\t\t\t}\n\t\t\t\tthis._rootWidth = newWidth;\n\t\t\t\tthis._rootHeight = newHeight;\n\t\t\t\t/*\n\t\t\t\t* Feature in IE7. For some reason, sometimes Internet Explorer 7 \n\t\t\t\t* returns incorrect values for element.getBoundingClientRect() when \n\t\t\t\t* inside a resize handler. The fix is to queue the work.\n\t\t\t\t*/\t\t\t\n\t\t\t\tvar queue = util.isIE < 9;\n\n\t\t\t\t/*\n\t\t\t\t* The calculated metrics may be out of date when the zoom level changes.\n\t\t\t\t*/\n\t\t\t\tvar metrics = this._calculateMetrics();\n\t\t\t\tif (!compare(metrics, this._metrics)) {\n\t\t\t\t\tif (this._metrics.invalid && !metrics.invalid) {\n\t\t\t\t\t\tthis._updateStyle(false, metrics);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this._variableLineHeight) {\n\t\t\t\t\t\t\tthis._variableLineHeight = false;\n\t\t\t\t\t\t\tthis._resetLineHeight();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._metrics = metrics;\n\t\t\t\t\t}\n\t\t\t\t\tqueue = true;\n\t\t\t\t}\n\n\t\t\t\tif (queue) {\n\t\t\t\t\tthis._queueUpdate();\n\t\t\t\t} else {\n\t\t\t\t\tthis._update();\n\t\t\t\t}\n\t\t\t\tthis.dispatchEvent({type: \"Resize\"}); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleRulerEvent: function (e) {\n\t\t\tvar target = e.target ? e.target : e.srcElement;\n\t\t\tvar lineIndex = target.lineIndex;\n\t\t\tvar element = target;\n\t\t\twhile (element && !element._ruler) {\n\t\t\t\tif (lineIndex === undefined && element.lineIndex !== undefined) {\n\t\t\t\t\tlineIndex = element.lineIndex;\n\t\t\t\t}\n\t\t\t\telement = element.parentNode;\n\t\t\t}\n\t\t\tvar ruler = element ? element._ruler : null;\n\t\t\tif (lineIndex === undefined && ruler && ruler.getOverview() === \"document\") { //$NON-NLS-0$\n\t\t\t\tvar clientHeight = this._getClientHeight ();\n\t\t\t\tvar lineCount = this._model.getLineCount ();\n\t\t\t\tvar viewPad = this._getViewPadding();\n\t\t\t\tvar viewRect = this._viewDiv.getBoundingClientRect();\n\t\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\t\tvar contentHeight = lineHeight * lineCount;\n\t\t\t\tvar trackHeight = clientHeight + viewPad.top + viewPad.bottom - 2 * this._metrics.scrollWidth;\n\t\t\t\tvar divHeight, arrowWidth;\n\t\t\t\tif (contentHeight < trackHeight) {\n\t\t\t\t\tdivHeight = lineHeight;\n\t\t\t\t\tarrowWidth = viewPad.top;\n\t\t\t\t} else {\n\t\t\t\t\tdivHeight = trackHeight / lineCount;\n\t\t\t\t\tarrowWidth = this._metrics.scrollWidth;\n\t\t\t\t}\n\t\t\t\tlineIndex = Math.floor(((e.clientY - viewRect.top) - arrowWidth) / divHeight);\n\t\t\t\tif (!(0 <= lineIndex && lineIndex < lineCount)) {\n\t\t\t\t\tlineIndex = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ruler) {\n\t\t\t\tswitch (e.type) {\n\t\t\t\t\tcase \"click\": //$NON-NLS-0$\n\t\t\t\t\t\tif (ruler.onClick) { ruler.onClick(lineIndex, e); }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"dblclick\": //$NON-NLS-0$\n\t\t\t\t\t\tif (ruler.onDblClick) { ruler.onDblClick(lineIndex, e); }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"mousemove\": //$NON-NLS-0$\n\t\t\t\t\t\tif (ruler.onMouseMove) { ruler.onMouseMove(lineIndex, e); }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"mouseover\": //$NON-NLS-0$\n\t\t\t\t\t\tif (ruler.onMouseOver) { ruler.onMouseOver(lineIndex, e); }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"mouseout\": //$NON-NLS-0$\n\t\t\t\t\t\tif (ruler.onMouseOut) { \n\t\t\t\t\t\t\tvar tmp = e.relatedTarget;\n\t\t\t\t\t\t\twhile (tmp && tmp !== this._rootDiv) {\n\t\t\t\t\t\t\t\tif (tmp === element) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmp = tmp.parentNode;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\truler.onMouseOut(lineIndex, e); \n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_handleScroll: function () {\n\t\t\tthis._lastScrollTime = new Date().getTime();\n\t\t\tvar scroll = this._getScroll(false);\n\t\t\tvar oldX = this._hScroll;\n\t\t\tvar oldY = this._vScroll;\n\t\t\tif (oldX !== scroll.x || oldY !== scroll.y) {\n\t\t\t\tthis._hScroll = scroll.x;\n\t\t\t\tthis._vScroll = scroll.y;\n\t\t\t\tthis._commitIME();\n\t\t\t\tthis._update(oldY === scroll.y);\n\t\t\t\tvar e = {\n\t\t\t\t\ttype: \"Scroll\", //$NON-NLS-0$\n\t\t\t\t\toldValue: {x: oldX, y: oldY},\n\t\t\t\t\tnewValue: scroll\n\t\t\t\t};\n\t\t\t\tthis.onScroll(e);\n\t\t\t}\n\t\t},\n\t\t_handleSelectStart: function (e) {\n\t\t\tvar menuOpen = this._contextMenuOpen;\n\t\t\tthis._contextMenuOpen = false;\n\t\t\tif (menuOpen) {\n\t\t\t\tthis._checkSelectionChange = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._ignoreSelect) {\n\t\t\t\tif (e && e.preventDefault) { e.preventDefault(); }\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t_getModelOffset: function(node, offset) {\n\t\t\tif (!node) { return; }\n\t\t\tvar lineNode;\n\t\t\tif (node.tagName === \"DIV\") { //$NON-NLS-0$\n\t\t\t\tlineNode = node;\n\t\t\t} else {\n\t\t\t\tlineNode = node.parentNode.parentNode;\n\t\t\t}\n\t\t\tif (!lineNode._line) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn lineNode._line.getModelOffset (node, offset);\n\t\t},\n\t\t_updateSelectionFromDOM: function() {\n\t\t\tif (!(util.isIOS || util.isAndroid || this._checkSelectionChange)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar window = this._getWindow();\n\t\t\tvar selection = window.getSelection();\n\t\t\tvar start = this._getModelOffset(selection.anchorNode, selection.anchorOffset);\n\t\t\tvar end = this._getModelOffset(selection.focusNode, selection.focusOffset);\n\t\t\tvar sel = this._getSelections()[0];\n\t\t\tif (start === undefined || end === undefined || (sel.start === start && sel.end === end)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (this._checkSelectionChange) {\n\t\t\t\tvar firstLine = this._getLineNext();\n\t\t\t\tvar lastLine = this._getLinePrevious();\n\t\t\t\t\n\t\t\t\t// Selection is unchanged and bigger than the visible buffer region\n\t\t\t\tif (selection.anchorNode === firstLine.firstChild.firstChild && selection.anchorOffset === 0 &&\n\t\t\t\t\tselection.focusNode === lastLine.firstChild.firstChild && selection.focusOffset === 0)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Detect select all\n\t\t\t\tif (\n\t\t\t\t(selection.anchorNode === firstLine.firstChild.firstChild && selection.anchorOffset === 0 && selection.focusNode === lastLine.lastChild.firstChild)\n\t\t\t\t|| (selection.anchorNode === this._clientDiv && selection.focusNode === this._clientDiv)\n\t\t\t\t) {\n\t\t\t\t\tstart = 0;\n\t\t\t\t\tend = this.getModel().getCharCount();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis._setSelection(new Selection(start, end), false, false);\n\t\t\tthis._checkSelectionChange = false;\n\t\t\treturn true;\n\t\t},\n\t\t_cancelCheckSelection: function() {\n\t\t\tif (this._checkSelectionChange) {\n\t\t\t\tthis._checkSelectionChange = false;\n\t\t\t\tthis._cancelPollSelectionChange();\n\t\t\t}\n\t\t},\n\t\t_cancelPollSelectionChange: function() {\n\t\t\tif (this._selPollTimer) {\n\t\t\t\tvar window = this._getWindow();\n\t\t\t\twindow.clearTimeout(this._selPollTimer);\n\t\t\t\tthis._selPollTimer = null; \n\t\t\t}\n\t\t},\n\t\t_pollSelectionChange: function(retryPoll) {\n\t\t\tvar that = this;\n\t\t\tvar window = this._getWindow();\n\t\t\tthis._cancelPollSelectionChange();\n\t\t\tthis._selPollTimer = window.setTimeout(function() {\n\t\t\t\tthat._selPollTimer = null; \n\t\t\t\tif (!that._clientDiv) { return; }\n\t\t\t\tvar changed = that._updateSelectionFromDOM();\n\t\t\t\tif (!changed && retryPoll) {\n\t\t\t\t\tthat._pollSelectionChange(retryPoll);\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t},\n\t\t_handleSelectionChange: function () {\n\t\t\tif (this._imeOffset !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Feature in Android. The selection handles are hidden when the DOM changes. Sending\n\t\t\t * selection events to the application while the user is moving the selection handles\n\t\t\t * may hide the handles unexpectedly.  The fix is to delay updating the selection and\n\t\t\t * sending the event to the application.\n\t\t\t */\n\t\t\tif (util.isAndroid) {\n\t\t\t\tthis._pollSelectionChange();\n\t\t\t} else {\n\t\t\t\tthis._updateSelectionFromDOM();\n\t\t\t}\n\t\t},\n\t\t_handleTextInput: function (e) {\n\t\t\tif (this._ignoreEvent(e)) { return; }\n\t\t\tif (this._imeOffset !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar selection = this._getWindow().getSelection();\n\t\t\tif (\n\t\t\t\tselection.anchorNode !== this._anchorNode || selection.focusNode !== this._focusNode ||\n\t\t\t\tselection.anchorOffset !== this._anchorOffset || selection.focusOffset !== this._focusOffset\n\t\t\t) {\n\t\t\t\tvar temp = selection.anchorNode;\n\t\t\t\twhile (temp) {\n\t\t\t\t\tif (temp.lineIndex !== undefined) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttemp = temp.parentNode;\n\t\t\t\t}\n\t\t\t\tif (temp) {\n\t\t\t\t\tvar model = this._model;\n\t\t\t\t\tvar lineIndex = temp.lineIndex;\n\t\t\t\t\tvar oldText = model.getLine(lineIndex), text = oldText;\n\t\t\t\t\tvar offset = 0;\n\t\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\t\tif (selection.rangeCount > 0) {\n\t\t\t\t\t\tselection.getRangeAt(0).deleteContents();\n\t\t\t\t\t\tvar node = temp.ownerDocument.createTextNode(e.data);\n\t\t\t\t\t\tselection.getRangeAt(0).insertNode(node);\n\t\t\t\t\t\tvar nodeText = this._getDOMText(temp, node);\n\t\t\t\t\t\ttext = nodeText.text;\n\t\t\t\t\t\toffset = nodeText.offset;\n\t\t\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t\t\t}\n\t\t\t\t\ttemp.lineRemoved = true;\n\t\t\t\t\t\n\t\t\t\t\tvar start = 0;\n\t\t\t\t\twhile (oldText.charCodeAt(start) === text.charCodeAt(start) && start < offset) {\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t}\n\t\t\n\t\t\t\t\tvar end = oldText.length - 1, delta = text.length - oldText.length;\n\t\t\t\t\twhile (oldText.charCodeAt(end) === text.charCodeAt(end + delta) && end + delta >= offset + e.data.length) {\n\t\t\t\t\t\tend--;\n\t\t\t\t\t}\n\t\t\t\t\tend++;\n\t\t\t\t\t\n\t\t\t\t\tvar deltaText = text.substring(start, end + delta);\n\t\t\t\t\tstart += lineStart;\n\t\t\t\t\tend += lineStart;\n\t\t\t\t\t\n\t\t\t\t\tvar selections = this._getSelections();\n\t\t\t\t\tvar deltaStart = selections[0].start - start;\n\t\t\t\t\tvar deltaEnd = selections[0].end - end;\n\t\t\t\t\tselections[0].start = start;\n\t\t\t\t\tselections[0].end = end;\n\t\t\t\t\tfor (var i=1; i<selections.length; i++) {\n\t\t\t\t\t\tselections[i].start -= deltaStart;\n\t\t\t\t\t\tselections[i].end -= deltaEnd;\n\t\t\t\t\t}\n\t\t\t\t\tthis._modifyContent({text: deltaText, selection: selections, _ignoreDOMSelection: true}, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._doContent(e.data);\n\t\t\t}\n\t\t\te.preventDefault();\n\t\t},\n\t\t_handleTouchStart: function (e) {\n\t\t\tif (this.isListening(\"TouchStart\")) { //$NON-NLS-0$\n\t\t\t\tvar touchEvent = this._createTouchEvent(\"TouchStart\", e); //$NON-NLS-0$\n\t\t\t\tthis.onTouchStart(touchEvent);\n\t\t\t\tif (touchEvent.defaultPrevented) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (this._noScroll) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._commitIME();\n\t\t\tvar window = this._getWindow();\n\t\t\tif (this._touchScrollTimer) {\n\t\t\t\tthis._vScrollDiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\tthis._hScrollDiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\twindow.clearInterval(this._touchScrollTimer);\n\t\t\t\tthis._touchScrollTimer = null;\n\t\t\t}\n\t\t\tvar touches = e.touches;\n\t\t\tif (touches.length === 1) {\n\t\t\t\tvar touch = touches[0];\n\t\t\t\tvar x = touch.clientX, y = touch.clientY;\n\t\t\t\tthis._touchStartX = x;\n\t\t\t\tthis._touchStartY = y;\n\t\t\t\tif (util.isAndroid) {\n\t\t\t\t\t/*\n\t\t\t\t\t* Bug in Android 4.  The clientX/Y coordinates of the touch events\n\t\t\t\t\t* include the page scrolling offsets.\n\t\t\t\t\t*/\n\t\t\t\t    if (y < (touch.pageY - window.pageYOffset) || x < (touch.pageX - window.pageXOffset) ) {\n\t\t\t\t\t\tx = touch.pageX - window.pageXOffset;\n\t\t\t\t\t\ty = touch.pageY - window.pageYOffset;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tvar pt = this.convert({x: x, y: y}, \"page\", \"document\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tthis._lastTouchOffset = this.getOffsetAtLocation(pt.x, pt.y);\n\t\t\t\tthis._touchStartTime = e.timeStamp;\n\t\t\t\tthis._touching = true;\n\t\t\t}\n\t\t},\n\t\t_handleTouchMove: function (e) {\n\t\t\tif (this.isListening(\"TouchMove\")) { //$NON-NLS-0$\n\t\t\t\tvar touchEvent = this._createTouchEvent(\"TouchMove\", e); //$NON-NLS-0$\n\t\t\t\tthis.onTouchMove(touchEvent);\n\t\t\t\tif (touchEvent.defaultPrevented) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (this._noScroll) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar touches = e.touches;\n\t\t\tif (touches.length === 1) {\n\t\t\t\tvar touch = touches[0];\n\t\t\t\tthis._touchCurrentX = touch.clientX;\n\t\t\t\tthis._touchCurrentY = touch.clientY;\n\t\t\t\tvar interval = 10;\n\t\t\t\tif (!this._touchScrollTimer && (e.timeStamp - this._touchStartTime) < (interval*20)) {\n\t\t\t\t\tthis._vScrollDiv.style.display = \"block\"; //$NON-NLS-0$\n\t\t\t\t\tif (!this._wrapMode) {\n\t\t\t\t\t\tthis._hScrollDiv.style.display = \"block\"; //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tvar window = this._getWindow();\n\t\t\t\t\tthis._touchScrollTimer = window.setInterval(function() {\n\t\t\t\t\t\tvar deltaX = 0, deltaY = 0;\n\t\t\t\t\t\tif (self._touching) {\n\t\t\t\t\t\t\tdeltaX = self._touchStartX - self._touchCurrentX;\n\t\t\t\t\t\t\tdeltaY = self._touchStartY - self._touchCurrentY;\n\t\t\t\t\t\t\tself._touchSpeedX = deltaX / interval;\n\t\t\t\t\t\t\tself._touchSpeedY = deltaY / interval;\n\t\t\t\t\t\t\tself._touchStartX = self._touchCurrentX;\n\t\t\t\t\t\t\tself._touchStartY = self._touchCurrentY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (Math.abs(self._touchSpeedX) < 0.1 && Math.abs(self._touchSpeedY) < 0.1) {\n\t\t\t\t\t\t\t\tself._vScrollDiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\t\t\t\t\tself._hScrollDiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\t\t\t\t\twindow.clearInterval(self._touchScrollTimer);\n\t\t\t\t\t\t\t\tself._touchScrollTimer = null;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdeltaX = self._touchSpeedX * interval;\n\t\t\t\t\t\t\t\tdeltaY = self._touchSpeedY * interval;\n\t\t\t\t\t\t\t\tself._touchSpeedX *= 0.95;\n\t\t\t\t\t\t\t\tself._touchSpeedY *= 0.95;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself._scrollView(deltaX, deltaY);\n\t\t\t\t\t}, interval);\n\t\t\t\t}\n\t\t\t\tif (this._touchScrollTimer) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_handleTouchEnd: function (e) {\n\t\t\tif (this.isListening(\"TouchEnd\")) { //$NON-NLS-0$\n\t\t\t\tvar touchEvent = this._createTouchEvent(\"TouchEnd\", e); //$NON-NLS-0$\n\t\t\t\tthis.onTouchEnd(touchEvent);\n\t\t\t\tif (touchEvent.defaultPrevented) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (this._noScroll) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar touches = e.touches;\n\t\t\tif (touches.length === 0) {\n\t\t\t\tthis._touching = false;\n\t\t\t}\n\t\t},\n\n\t\t/************************************ Actions ******************************************/\n\t\t_doAction: function (e) {\n\t\t\tvar mode, i;\n\t\t\tvar keyModes = this._keyModes;\n\t\t\tfor (i = keyModes.length - 1 ; i >= 0; i--) {\n\t\t\t\tmode = keyModes[i];\n\t\t\t\tif (typeof mode.match === \"function\") { //$NON-NLS-0$\n\t\t\t\t\tvar actionID = mode.match(e);\n\t\t\t\t\tif (actionID !== undefined) {\n\t\t\t\t\t\treturn this.invokeAction(actionID);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t_doMove: function(args, selection) {\n\t\t\tvar model = this._model;\n\t\t\tvar caret = selection.getCaret();\n\t\t\tvar lineIndex = model.getLineAtOffset(caret);\n\t\t\tif (!args.count) {\n\t\t\t\targs.count = 1;\n\t\t\t}\n\t\t\twhile (args.count !== 0) {\n\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\tif (args.count < 0 && caret === lineStart) {\n\t\t\t\t\tif (lineIndex > 0) {\n\t\t\t\t\t\tif (args.unit === \"character\") { //$NON-NLS-0$\n\t\t\t\t\t\t\targs.count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlineIndex--;\n\t\t\t\t\t\tselection.extend(model.getLineEnd(lineIndex));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (args.count > 0 && caret === model.getLineEnd(lineIndex)) {\n\t\t\t\t\tif (lineIndex + 1 < model.getLineCount()) {\n\t\t\t\t\t\tif (args.unit === \"character\") { //$NON-NLS-0$\n\t\t\t\t\t\t\targs.count--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlineIndex++;\n\t\t\t\t\t\tselection.extend(model.getLineStart(lineIndex));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar removeTab = false;\n\t\t\t\t\tif (args.expandTab && args.unit === \"character\" && (caret - lineStart) % this._tabSize === 0) { //$NON-NLS-0$\n\t\t\t\t\t\tvar lineText = model.getText(lineStart, caret);\n\t\t\t\t\t\tremoveTab = !/[^ ]/.test(lineText); // Only spaces between line start and caret.\n\t\t\t\t\t}\n\t\t\t\t\tif (removeTab) {\n\t\t\t\t\t\tselection.extend(caret - this._tabSize);\n\t\t\t\t\t\targs.count += args.count < 0 ? 1 : -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar line = this._getLine(lineIndex);\n\t\t\t\t\t\tselection.extend(line.getNextOffset(caret, args));\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcaret = selection.getCaret();\n\t\t\t}\n\t\t\treturn selection;\n\t\t},\n\t\t_doBackspace: function (args) {\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (selection.isEmpty()) {\n\t\t\t\t\tif (!args.count) {\n\t\t\t\t\t\targs.count = 1;\n\t\t\t\t\t}\n\t\t\t\t\targs.count *= -1;\n\t\t\t\t\targs.expandTab = self._expandTab;\n\t\t\t\t\tself._doMove(args, selection);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._modifyContent({text: \"\", selection: selections}, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doCase: function (args) {\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tvar changes = [];\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tself._doMove(args, selection);\n\t\t\t\tvar text = self.getText(selection.start, selection.end);\n\t\t\t\tswitch (args.type) {\n\t\t\t\t\tcase \"lower\": text = text.toLowerCase(); break; //$NON-NLS-0$\n\t\t\t\t\tcase \"capitalize\": text = text.replace(/(?:^|\\s)\\S/g, function(a) { return a.toUpperCase(); }); break; //$NON-NLS-0$\n\t\t\t\t\tcase \"reverse\":  //$NON-NLS-0$\n\t\t\t\t\t\tvar newText = \"\";\n\t\t\t\t\t\tfor (var i=0; i<text.length; i++) {\n\t\t\t\t\t\t\tvar s = text[i];\n\t\t\t\t\t\t\tvar l = s.toLowerCase();\n\t\t\t\t\t\t\tif (l !== s) {\n\t\t\t\t\t\t\t\ts = l;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts = s.toUpperCase();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewText += s;\n\t\t\t\t\t\t} \n\t\t\t\t\t\ttext = newText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: text = text.toUpperCase(); break;\n\t\t\t\t}\n\t\t\t\tchanges.push(text);\n\t\t\t});\n\t\t\treturn this._modifyContent({text: changes, selection: selections, _ignoreDOMSelection: true}, true);\n\t\t},\n\t\t_doContent: function (text) {\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (self._overwriteMode && selection.isEmpty()) {\n\t\t\t\t\tvar model = self._model;\n\t\t\t\t\tvar lineIndex = model.getLineAtOffset(selection.end);\n\t\t\t\t\tif (selection.end < model.getLineEnd(lineIndex)) {\n\t\t\t\t\t\tvar line = self._getLine(lineIndex);\n\t\t\t\t\t\tselection.extend(line.getNextOffset(selection.getCaret(), {unit:\"character\", count:1})); //$NON-NLS-0$\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this._modifyContent({text: text, selection: selections, _ignoreDOMSelection: true}, true);\n\t\t},\n\t\t_doCopy: function (e) {\n\t\t\tvar text = this.getSelectionText();\n\t\t\tif (text) {\n\t\t\t\treturn this._setClipboardText(text, e);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_doCursorNext: function (args) {\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (!selection.isEmpty() && !args.select) {\n\t\t\t\t\tselection.start = selection.end;\n\t\t\t\t} else {\n\t\t\t\t\tself._doMove(args, selection);\n\t\t\t\t}\n\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t});\n\t\t\tthis._setSelection(selections, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doCursorPrevious: function (args) {\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (!selection.isEmpty() && !args.select) {\n\t\t\t\t\tselection.end = selection.start;\n\t\t\t\t} else {\n\t\t\t\t\tif (!args.count) {\n\t\t\t\t\t\targs.count = 1;\n\t\t\t\t\t}\n\t\t\t\t\targs.count *= -1;\n\t\t\t\t\tself._doMove(args, selection);\n\t\t\t\t}\n\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t});\n\t\t\tthis._setSelection(selections, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doCut: function (e) {\n\t\t\tvar text = this.getSelectionText();\n\t\t\tif (text) {\n\t\t\t\tthis._doContent(\"\");\n\t\t\t\treturn this._setClipboardText(text, e);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_doDelete: function (args) {\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (selection.isEmpty()) {\n\t\t\t\t\tself._doMove(args, selection);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._modifyContent({text: \"\", selection: selections}, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doEnd: function (args) {\n\t\t\tvar model = this._model;\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (args.ctrl) {\n\t\t\t\t\tselection.extend(model.getCharCount());\n\t\t\t\t} else {\n\t\t\t\t\tvar offset = selection.getCaret();\n\t\t\t\t\tvar lineIndex = model.getLineAtOffset(offset);\n\t\t\t\t\tif (self._wrapMode) {\n\t\t\t\t\t\tvar line = self._getLine(lineIndex);\n\t\t\t\t\t\tvar visualIndex = line.getLineIndex(offset);\n\t\t\t\t\t\tif (visualIndex === line.getLineCount() - 1) {\n\t\t\t\t\t\t\toffset = model.getLineEnd(lineIndex);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toffset = line.getLineStart(visualIndex + 1) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (args.count && args.count > 0) {\n\t\t\t\t\t\t\tlineIndex = Math.min (lineIndex  + args.count - 1, model.getLineCount() - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset = model.getLineEnd(lineIndex);\n\t\t\t\t\t}\n\t\t\t\t\tselection.extend(offset);\n\t\t\t\t}\n\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t});\n\t\t\tthis._setSelection(selections, true, true, args.ctrl ? function() {} : null);\n\t\t\treturn true;\n\t\t},\n\t\t_doEnter: function (args) {\n\t\t\tif (this._singleMode) return true;\n\t\t\tvar model = this._model;\n\t\t\tvar selections = this._getSelections();\n\t\t\tthis._doContent(model.getLineDelimiter()); \n\t\t\tif (args && args.noCursor) {\n\t\t\t\tselections.forEach(function(selection) {\n\t\t\t\t\tselection.end = selection.start;\n\t\t\t\t});\n\t\t\t\tthis._setSelection(selections, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_doEscape: function () {\n\t\t\tvar selections = this._getSelections();\n\t\t\tif (selections.length > 1) {\n\t\t\t\tthis._setSelection(selections[0], true);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_doHome: function (args) {\n\t\t\tvar model = this._model;\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (args.ctrl) {\n\t\t\t\t\tselection.extend(0);\n\t\t\t\t} else {\n\t\t\t\t\tvar offset = selection.getCaret();\n\t\t\t\t\tvar lineIndex = model.getLineAtOffset(offset);\n\t\t\t\t\tif (self._wrapMode) {\n\t\t\t\t\t\tvar line = self._getLine(lineIndex);\n\t\t\t\t\t\tvar visualIndex = line.getLineIndex(offset);\n\t\t\t\t\t\toffset = line.getLineStart(visualIndex);\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = model.getLineStart(lineIndex);\n\t\t\t\t\t}\n\t\t\t\t\tselection.extend(offset); \n\t\t\t\t}\n\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t});\n\t\t\tthis._setSelection(selections, true, true, args.ctrl ? function() {} : null);\n\t\t\treturn true;\n\t\t},\n\t\t_doLineDown: function (args) {\n\t\t\tvar model = this._model;\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tvar caret = selection.getCaret();\n\t\t\t\tvar lineIndex = model.getLineAtOffset(caret), visualIndex;\n\t\t\t\tvar line = self._getLine(lineIndex);\n\t\t\t\tvar x = selection._columnX, y = 1, lastLine = false;\n\t\t\t\tif (x === -1 || args.wholeLine || (args.select && util.isIE)) {\n\t\t\t\t\tvar offset = args.wholeLine ? model.getLineEnd(lineIndex + 1) : caret;\n\t\t\t\t\tx = selection._columnX = line.getBoundingClientRect(offset).left;\n\t\t\t\t}\n\t\t\t\tif ((visualIndex = line.getLineIndex(caret)) < line.getLineCount() - 1) {\n\t\t\t\t\ty = line.getClientRects(visualIndex + 1).top + 1;\n\t\t\t\t} else {\n\t\t\t\t\tvar lastLineCount = model.getLineCount() - 1;\n\t\t\t\t\tlastLine = lineIndex === lastLineCount;\n\t\t\t\t\tif (args.count && args.count > 0) {\n\t\t\t\t\t\tlineIndex = Math.min (lineIndex + args.count, lastLineCount);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlineIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar select = false;\n\t\t\t\tif (lastLine) {\n\t\t\t\t\tif (args.select || (util.isMac || util.isLinux)) {\n\t\t\t\t\t\tselection.extend(model.getCharCount());\n\t\t\t\t\t\tselect = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (line.lineIndex !== lineIndex) {\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t\tline = self._getLine(lineIndex);\n\t\t\t\t\t}\n\t\t\t\t\tselection.extend(line.getOffset(x, y));\n\t\t\t\t\tselect = true;\n\t\t\t\t}\n\t\t\t\tif (select) {\n\t\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t\t}\n\t\t\t\tline.destroy();\n\t\t\t});\n\t\t\tself._setSelection(selections, true, true, null, 0, false, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doLineUp: function (args) {\n\t\t\tvar model = this._model;\n\t\t\tvar self = this;\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tvar caret = selection.getCaret();\n\t\t\t\tvar lineIndex = model.getLineAtOffset(caret), visualIndex;\n\t\t\t\tvar line = self._getLine(lineIndex);\n\t\t\t\tvar x = selection._columnX, firstLine = false, y;\n\t\t\t\tif (x === -1 || args.wholeLine || (args.select && util.isIE)) {\n\t\t\t\t\tvar offset = args.wholeLine ? model.getLineStart(lineIndex - 1) : caret;\n\t\t\t\t\tx = selection._columnX = line.getBoundingClientRect(offset).left;\n\t\t\t\t}\n\t\t\t\tif ((visualIndex = line.getLineIndex(caret)) > 0) {\n\t\t\t\t\ty = line.getClientRects(visualIndex - 1).top + 1;\n\t\t\t\t} else {\n\t\t\t\t\tfirstLine = lineIndex === 0;\n\t\t\t\t\tif (!firstLine) {\n\t\t\t\t\t\tif (args.count && args.count > 0) {\n\t\t\t\t\t\t\tlineIndex = Math.max (lineIndex - args.count, 0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlineIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ty = self._getLineHeight(lineIndex) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar select = false;\n\t\t\t\tif (firstLine) {\n\t\t\t\t\tif (args.select || (util.isMac || util.isLinux)) {\n\t\t\t\t\t\tselection.extend(0);\n\t\t\t\t\t\tselect = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (line.lineIndex !== lineIndex) {\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t\tline = self._getLine(lineIndex);\n\t\t\t\t\t}\n\t\t\t\t\tselection.extend(line.getOffset(x, y));\n\t\t\t\t\tselect = true;\n\t\t\t\t}\n\t\t\t\tif (select) {\n\t\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t\t}\n\t\t\t\tline.destroy();\n\t\t\t});\n\t\t\tself._setSelection(selections, true, true, null, 0, false, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doNoop: function () {\n\t\t\treturn true;\n\t\t},\n\t\t_doPageDown: function (args) {\n\t\t\tvar self = this;\n\t\t\tvar model = this._model;\n\t\t\tvar selections = this._getSelections();\n\t\t\tvar lineCount = model.getLineCount();\n\t\t\tvar scroll = this._getScroll();\n\t\t\tvar clientHeight = this._getClientHeight();\n\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\tvar lines = Math.floor(clientHeight / lineHeight);\n\t\t\tvar x, line, pageScroll;\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tvar caret = selection.getCaret();\n\t\t\t\tvar caretLine = model.getLineAtOffset(caret);\n\t\t\t\tif (self._lineHeight) {\n\t\t\t\t\tx = selection._columnX;\n\t\t\t\t\tvar caretRect = self._getBoundsAtOffset(caret);\n\t\t\t\t\tif (x === -1 || (args.select && util.isIE)) {\n\t\t\t\t\t\tx = selection._columnX = caretRect.left;\n\t\t\t\t\t}\n\t\t\t\t\tvar lineIndex = self._getLineIndex(caretRect.top + clientHeight);\n\t\t\t\t\tline = self._getLine(lineIndex);\n\t\t\t\t\tvar linePixel = self._getLinePixel(lineIndex);\n\t\t\t\t\tvar y = caretRect.top + clientHeight - linePixel;\n\t\t\t\t\tcaret = line.getOffset(x, y);\n\t\t\t\t\tvar rect = line.getBoundingClientRect(caret);\n\t\t\t\t\tline.destroy();\n\t\t\t\t\tselection.extend(caret);\n\t\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t\t\tpageScroll = pageScroll !== undefined ? Math.min(pageScroll, rect.top + linePixel - caretRect.top) : rect.top + linePixel - caretRect.top;\n\t\t\t\t} else {\n\t\t\t\t\tif (caretLine < lineCount - 1) {\n\t\t\t\t\t\tvar scrollLines = Math.min(lineCount - caretLine - 1, lines);\n\t\t\t\t\t\tscrollLines = Math.max(1, scrollLines);\n\t\t\t\t\t\tx = selection._columnX;\n\t\t\t\t\t\tif (x === -1 || (args.select && util.isIE)) {\n\t\t\t\t\t\t\tline = self._getLine(caretLine);\n\t\t\t\t\t\t\tx = selection._columnX = line.getBoundingClientRect(caret).left;\n\t\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tline = self._getLine(caretLine + scrollLines);\n\t\t\t\t\t\tselection.extend(line.getOffset(x, 0));\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t\t\t\tvar verticalMaximum = lineCount * lineHeight;\n\t\t\t\t\t\tvar scrollOffset = scroll.y + scrollLines * lineHeight;\n\t\t\t\t\t\tif (scrollOffset + clientHeight > verticalMaximum) {\n\t\t\t\t\t\t\tscrollOffset = verticalMaximum - clientHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpageScroll = pageScroll !== undefined ? Math.min(pageScroll, scrollOffset - scroll.y) : scrollOffset - scroll.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._setSelection(selections, true, true, function() {}, pageScroll, false, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doPageUp: function (args) {\n\t\t\tvar self = this;\n\t\t\tvar model = this._model;\n\t\t\tvar selections = this._getSelections();\n\t\t\tvar scroll = this._getScroll();\n\t\t\tvar clientHeight = this._getClientHeight();\n\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\tvar lines = Math.floor(clientHeight / lineHeight);\n\t\t\tvar x, line, pageScroll;\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tvar caret = selection.getCaret();\n\t\t\t\tvar caretLine = model.getLineAtOffset(caret);\n\t\t\t\tif (self._lineHeight) {\n\t\t\t\t\tx = selection._columnX;\n\t\t\t\t\tvar caretRect = self._getBoundsAtOffset(caret);\n\t\t\t\t\tif (x === -1 || (args.select && util.isIE)) {\n\t\t\t\t\t\tx = selection._columnX = caretRect.left;\n\t\t\t\t\t}\n\t\t\t\t\tvar lineIndex = self._getLineIndex(caretRect.bottom - clientHeight);\n\t\t\t\t\tline = self._getLine(lineIndex);\n\t\t\t\t\tvar linePixel = self._getLinePixel(lineIndex);\n\t\t\t\t\tvar y = (caretRect.bottom - clientHeight) - linePixel;\n\t\t\t\t\tcaret = line.getOffset(x, y);\n\t\t\t\t\tvar rect = line.getBoundingClientRect(caret);\n\t\t\t\t\tline.destroy();\n\t\t\t\t\tselection.extend(caret);\n\t\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t\t\tpageScroll = pageScroll !== undefined ? Math.max(pageScroll, rect.top + linePixel - caretRect.top) : rect.top + linePixel - caretRect.top;\n\t\t\t\t} else {\n\t\t\t\t\tif (caretLine > 0) {\n\t\t\t\t\t\tvar scrollLines = Math.max(1, Math.min(caretLine, lines));\n\t\t\t\t\t\tx = selection._columnX;\n\t\t\t\t\t\tif (x === -1 || (args.select && util.isIE)) {\n\t\t\t\t\t\t\tline = self._getLine(caretLine);\n\t\t\t\t\t\t\tx = selection._columnX = line.getBoundingClientRect(caret).left;\n\t\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tline = self._getLine(caretLine - scrollLines);\n\t\t\t\t\t\tselection.extend(line.getOffset(x, self._getLineHeight(caretLine - scrollLines) - 1));\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t\tif (!args.select) { selection.collapse(); }\n\t\t\t\t\t\tvar scrollOffset = Math.max(0, scroll.y - scrollLines * lineHeight);\n\t\t\t\t\t\tpageScroll = pageScroll !== undefined  ? Math.max(pageScroll, scrollOffset - scroll.y) : scrollOffset - scroll.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._setSelection(selections, true, true, function() {}, pageScroll, false, true);\n\t\t\treturn true;\n\t\t},\n\t\t_doPaste: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar result = this._getClipboardText(e, function(text) {\n\t\t\t\tif (text.length) {\n\t\t\t\t\tif (util.isLinux && self._lastMouseButton === 2) {\n\t\t\t\t\t\tvar timeDiff = new Date().getTime() - self._lastMouseTime;\n\t\t\t\t\t\tif (timeDiff <= self._clickTime) {\n\t\t\t\t\t\t\tself._setSelectionTo(self._lastMouseX, self._lastMouseY, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar selections = self._getSelections();\n\t\t\t\t\tvar delimiter = self._singleMode ? \"\" : self._model.getLineDelimiter();\n\t\t\t\t\tself._doContent(selections.length > 1 && selections.length === text.length ? text : text.join(delimiter));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result !== null;\n\t\t},\n\t\t_doScroll: function (args) {\n\t\t\tvar type = args.type;\n\t\t\tvar model = this._model;\n\t\t\tvar lineCount = model.getLineCount();\n\t\t\tvar clientHeight = this._getClientHeight();\n\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\tvar verticalMaximum = this._lineHeight ? this._scrollHeight : lineCount * lineHeight;\n\t\t\tvar verticalScrollOffset = this._getScroll().y;\n\t\t\tvar pixel;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"textStart\": pixel = 0; break; //$NON-NLS-0$\n\t\t\t\tcase \"textEnd\": pixel = verticalMaximum - clientHeight; break; //$NON-NLS-0$\n\t\t\t\tcase \"pageDown\": pixel = verticalScrollOffset + clientHeight; break; //$NON-NLS-0$\n\t\t\t\tcase \"pageUp\": pixel = verticalScrollOffset - clientHeight; break; //$NON-NLS-0$\n\t\t\t\tcase \"lineDown\": pixel = verticalScrollOffset + lineHeight; break; //$NON-NLS-0$\n\t\t\t\tcase \"lineUp\": pixel = verticalScrollOffset - lineHeight; break; //$NON-NLS-0$\n\t\t\t\tcase \"centerLine\": //$NON-NLS-0$\n\t\t\t\t\tvar selection = this._getSelections()[0];\n\t\t\t\t\tvar lineStart = model.getLineAtOffset(selection.start);\n\t\t\t\t\tvar lineEnd = model.getLineAtOffset(selection.end);\n\t\t\t\t\tvar selectionHeight = (lineEnd - lineStart + 1) * lineHeight;\n\t\t\t\t\tpixel = (lineStart * lineHeight) - (clientHeight / 2) + (selectionHeight / 2);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pixel !== undefined) {\n\t\t\t\tpixel = Math.min(Math.max(0, pixel), verticalMaximum - clientHeight);\n\t\t\t\tthis._scrollViewAnimated(0, pixel - verticalScrollOffset, function() {});\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_doSelectAll: function () {\n\t\t\tvar model = this._model;\n\t\t\tthis._setSelection(new Selection(0, model.getCharCount()), false);\n\t\t\treturn true;\n\t\t},\n\t\t_doTab: function () {\n\t\t\tif (!this._tabMode || this._readonly) { return; }\n\t\t\tvar text = \"\\t\"; //$NON-NLS-0$\n\t\t\tvar selections = this._getSelections();\n\t\t\tif (this._expandTab) {\n\t\t\t\ttext = [];\n\t\t\t\tvar model = this._model;\n\t\t\t\tvar tabSize = this._tabSize;\n\t\t\t\tselections.forEach(function(selection) {\n\t\t\t\t\tvar caret = selection.getCaret();\n\t\t\t\t\tvar lineIndex = model.getLineAtOffset(caret);\n\t\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\t\tvar spaces = tabSize - ((caret - lineStart) % tabSize);\n\t\t\t\t\ttext.push((newArray(spaces + 1)).join(\" \")); //$NON-NLS-0$\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this._modifyContent({text: text, selection: selections, _ignoreDOMSelection: true}, true);\n\t\t},\n\t\t_doShiftTab: function () {\n\t\t\tif (!this._tabMode || this._readonly) { return; }\n\t\t\treturn true;\n\t\t},\n\t\t_doOverwriteMode: function () {\n\t\t\tif (this._readonly) { return; }\n\t\t\tthis.setOptions({overwriteMode: !this.getOptions(\"overwriteMode\")}); //$NON-NLS-0$\n\t\t\treturn true;\n\t\t},\n\t\t_doTabMode: function () {\n\t\t\tthis._tabMode = !this._tabMode;\n\t\t\treturn true;\n\t\t},\n\t\t_doWrapMode: function () {\n\t\t\tthis.setOptions({wrapMode: !this.getOptions(\"wrapMode\")}); //$NON-NLS-0$\n\t\t\treturn true;\n\t\t},\n\t\t\n\t\t/************************************ Internals ******************************************/\n\t\t_autoScroll: function () {\n\t\t\tvar model = this._model;\n\t\t\tvar selections = this._getSelections();\n\t\t\tvar selection = Selection.editing(selections, this._autoScrollDir === \"down\"); //$NON-NLS-0$\n\t\t\tvar pt = this.convert({x: this._autoScrollX, y: this._autoScrollY}, \"page\", \"document\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar caret = selection.getCaret();\n\t\t\tvar lineCount = model.getLineCount();\n\t\t\tvar caretLine = model.getLineAtOffset(caret), lineIndex, line;\n\t\t\tif (this._autoScrollDir === \"up\" || this._autoScrollDir === \"down\") { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tvar scroll = this._autoScrollY / this._getLineHeight();\n\t\t\t\tscroll = scroll < 0 ? Math.floor(scroll) : Math.ceil(scroll);\n\t\t\t\tlineIndex = caretLine;\n\t\t\t\tlineIndex = Math.max(0, Math.min(lineCount - 1, lineIndex + scroll));\n\t\t\t} else if (this._autoScrollDir === \"left\" || this._autoScrollDir === \"right\") { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tlineIndex = this._getLineIndex(pt.y);\n\t\t\t\tline = this._getLine(caretLine); \n\t\t\t\tpt.x += line.getBoundingClientRect(caret, false).left;\n\t\t\t\tline.destroy();\n\t\t\t}\n\t\t\tif (this._blockSelection) {\n\t\t\t\tselections = this._getBlockSelections(selections, lineIndex, pt);\n\t\t\t} else if (lineIndex === 0 && (util.isMac || util.isLinux)) {\n\t\t\t\tselection.extend(0);\n\t\t\t} else if (lineIndex === lineCount - 1 && (util.isMac || util.isLinux)) {\n\t\t\t\tselection.extend(model.getCharCount());\n\t\t\t} else {\n\t\t\t\tline = this._getLine(lineIndex);\n\t\t\t\tselection.extend(line.getOffset(pt.x, pt.y - this._getLinePixel(lineIndex)));\n\t\t\t\tline.destroy();\n\t\t\t}\n\t\t\tthis._setSelection(selections, true);\n\t\t},\n\t\t_autoScrollTimer: function () {\n\t\t\tthis._autoScroll();\n\t\t\tvar self = this;\n\t\t\tvar window = this._getWindow();\n\t\t\tthis._autoScrollTimerID = window.setTimeout(function () {self._autoScrollTimer();}, this._AUTO_SCROLL_RATE);\n\t\t},\n\t\t_calculateLineHeightTimer: function(calculate) {\n\t\t\tif (!this._lineHeight) { return; }\n\t\t\tif (this._calculateLHTimer) { return; }\n\t\t\tvar lineCount = this._model.getLineCount(), i = 0;\n\t\t\tif (calculate) {\n\t\t\t\tvar c = 0;\n\t\t\t\tvar MAX_TIME = 100;\n\t\t\t\tvar start = new Date().getTime(), firstLine = 0;\n\t\t\t\twhile (i < lineCount) {\n\t\t\t\t\tif (!this._lineHeight[i]) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tif (!firstLine) { firstLine = i; }\n\t\t\t\t\t\tthis._lineHeight[i] = this._calculateLineHeight(i);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t\tif ((new Date().getTime() - start) > MAX_TIME) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.redrawRulers(0, lineCount);\n\t\t\t\tthis._queueUpdate();\n\t\t\t}\n\t\t\tvar window = this._getWindow();\n\t\t\tif (i !== lineCount) {\n\t\t\t\tvar self = this;\n\t\t\t\tthis._calculateLHTimer = window.setTimeout(function() {\n\t\t\t\t\tself._calculateLHTimer = null;\n\t\t\t\t\tself._calculateLineHeightTimer(true);\n\t\t\t\t}, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._calculateLHTimer) {\n\t\t\t\twindow.clearTimeout(this._calculateLHTimer);\n\t\t\t\tthis._calculateLHTimer = undefined;\n\t\t\t}\n\t\t},\n\t\t_calculateLineHeight: function(lineIndex) {\n\t\t\tvar line = this._getLine(lineIndex);\n\t\t\tvar rect = line.getBoundingClientRect();\n\t\t\tline.destroy();\n\t\t\treturn Math.max(1, rect.bottom - rect.top);\n\t\t},\n\t\t_calculateMetrics: function() {\n\t\t\tvar parent = this._clientDiv;\n\t\t\tvar document = parent.ownerDocument;\n\t\t\tvar c = \" \"; //$NON-NLS-0$\n\t\t\tvar line = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tline.style.lineHeight = \"normal\"; //$NON-NLS-0$\n\t\t\tvar model = this._model;\n\t\t\tvar lineText = model.getLine(0);\n\t\t\tvar e = {type:\"LineStyle\", textView: this, 0: 0, lineText: lineText, lineStart: 0}; //$NON-NLS-0$\n\t\t\tthis.onLineStyle(e);\n\t\t\tapplyStyle(e.style, line);\n\t\t\tline.style.position = \"fixed\"; //$NON-NLS-0$\n\t\t\tline.style.left = \"-1000px\"; //$NON-NLS-0$\n\t\t\tvar span1 = util.createElement(document, \"span\"); //$NON-NLS-0$\n\t\t\tspan1.appendChild(document.createTextNode(c));\n\t\t\tline.appendChild(span1);\n\t\t\tvar span2 = util.createElement(document, \"span\"); //$NON-NLS-0$\n\t\t\tspan2.style.fontStyle = \"italic\"; //$NON-NLS-0$\n\t\t\tspan2.appendChild(document.createTextNode(c));\n\t\t\tline.appendChild(span2);\n\t\t\tvar span3 = util.createElement(document, \"span\"); //$NON-NLS-0$\n\t\t\tspan3.style.fontWeight = \"bold\"; //$NON-NLS-0$\n\t\t\tspan3.appendChild(document.createTextNode(c));\n\t\t\tline.appendChild(span3);\n\t\t\tvar span4 = util.createElement(document, \"span\"); //$NON-NLS-0$\n\t\t\tspan4.style.fontWeight = \"bold\"; //$NON-NLS-0$\n\t\t\tspan4.style.fontStyle = \"italic\"; //$NON-NLS-0$\n\t\t\tspan4.appendChild(document.createTextNode(c));\n\t\t\tline.appendChild(span4);\n\t\t\tparent.appendChild(line);\n\t\t\tvar lineRect = line.getBoundingClientRect();\n\t\t\tvar spanRect1 = span1.getBoundingClientRect();\n\t\t\tvar spanRect2 = span2.getBoundingClientRect();\n\t\t\tvar spanRect3 = span3.getBoundingClientRect();\n\t\t\tvar spanRect4 = span4.getBoundingClientRect();\n\t\t\tvar h1 = spanRect1.bottom - spanRect1.top;\n\t\t\tvar h2 = spanRect2.bottom - spanRect2.top;\n\t\t\tvar h3 = spanRect3.bottom - spanRect3.top;\n\t\t\tvar h4 = spanRect4.bottom - spanRect4.top;\n\t\t\tvar fontStyle = 0;\n\t\t\tvar invalid = (lineRect.bottom - lineRect.top) <= 0;\n\t\t\tvar lineHeight = Math.max(1, lineRect.bottom - lineRect.top);\n\t\t\tif (h2 > h1) {\n\t\t\t\tfontStyle = 1;\n\t\t\t}\n\t\t\tif (h3 > h2) {\n\t\t\t\tfontStyle = 2;\n\t\t\t}\n\t\t\tif (h4 > h3) {\n\t\t\t\tfontStyle = 3;\n\t\t\t}\n\t\t\tvar style;\n\t\t\tif (fontStyle !== 0) {\n\t\t\t\tstyle = {style: {}};\n\t\t\t\tif ((fontStyle & 1) !== 0) {\n\t\t\t\t\tstyle.style.fontStyle = \"italic\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif ((fontStyle & 2) !== 0) {\n\t\t\t\t\tstyle.style.fontWeight = \"bold\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar trim = getLineTrim(line);\n\t\t\tparent.removeChild(line);\n\t\t\t\n\t\t\t// calculate pad and scroll width\n\t\t\tvar pad = getPadding(this._viewDiv);\n\t\t\tvar div1 = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tdiv1.style.position = \"fixed\"; //$NON-NLS-0$\n\t\t\tdiv1.style.left = \"-1000px\"; //$NON-NLS-0$\n\t\t\tdiv1.style.paddingLeft = pad.left + \"px\"; //$NON-NLS-0$\n\t\t\tdiv1.style.paddingTop = pad.top + \"px\"; //$NON-NLS-0$\n\t\t\tdiv1.style.paddingRight = pad.right + \"px\"; //$NON-NLS-0$\n\t\t\tdiv1.style.paddingBottom = pad.bottom + \"px\"; //$NON-NLS-0$\n\t\t\tdiv1.style.width = \"100px\"; //$NON-NLS-0$\n\t\t\tdiv1.style.height = \"100px\"; //$NON-NLS-0$\n\t\t\tvar div2 = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tdiv2.style.width = \"100%\"; //$NON-NLS-0$\n\t\t\tdiv2.style.height = \"100%\"; //$NON-NLS-0$\n\t\t\tdiv1.appendChild(div2);\n\t\t\tparent.appendChild(div1);\n\t\t\tvar rect1 = div1.getBoundingClientRect();\n\t\t\tvar rect2 = div2.getBoundingClientRect();\n\t\t\tvar scrollWidth = 0;\n\t\t\tif (!this._singleMode && !this._noScroll) {\n\t\t\t\tdiv1.style.overflow = 'hidden'; //$NON-NLS-0$\n\t\t\t\tdiv2.style.height = \"200px\"; //$NON-NLS-0$\n\t\t\t\tvar w1 = div1.clientWidth;\n\t\t\t\tdiv1.style.overflow = 'scroll'; //$NON-NLS-0$\n\t\t\t\tvar w2 = div1.clientWidth;\n\t\t\t\tscrollWidth = w1 - w2;\n\t\t\t}\n\t\t\tparent.removeChild(div1);\n\t\t\tpad = {\n\t\t\t\tleft: rect2.left - rect1.left,\n\t\t\t\ttop: rect2.top - rect1.top,\n\t\t\t\tright: rect1.right - rect2.right,\n\t\t\t\tbottom: rect1.bottom - rect2.bottom\n\t\t\t};\n\t\t\tvar wrapWidth = 0, marginWidth = 0, charWidth = 0;\n\t\t\tif (!invalid) {\n\t\t\t\tdiv1 = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tdiv1.style.position = \"fixed\"; //$NON-NLS-0$\n\t\t\t\tdiv1.style.left = \"-1000px\"; //$NON-NLS-0$\n\t\t\t\tparent.appendChild(div1);\n\t\t\t\tdiv1.innerHTML = newArray(2).join(\"a\"); //$NON-NLS-0$\n\t\t\t\trect1 = div1.getBoundingClientRect();\n\t\t\t\tcharWidth = Math.ceil(rect1.right - rect1.left);\n\t\t\t\tif (this._wrapOffset || this._marginOffset) {\n\t\t\t\t\tdiv1.innerHTML = newArray(this._wrapOffset + 1 + (util.isWebkit ? 0 : 1)).join(\" \"); //$NON-NLS-0$\n\t\t\t\t\trect1 = div1.getBoundingClientRect();\n\t\t\t\t\twrapWidth = Math.ceil(rect1.right - rect1.left);\n\t\t\t\t\tdiv1.innerHTML = newArray(this._marginOffset + 1).join(\" \"); //$NON-NLS-0$\n\t\t\t\t\trect2 = div1.getBoundingClientRect();\n\t\t\t\t\tmarginWidth = Math.ceil(rect2.right - rect2.left);\n\t\t\t\t}\n\t\t\t\tparent.removeChild(div1);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tlineHeight: lineHeight,\n\t\t\t\tlargestFontStyle: style,\n\t\t\t\tlineTrim: trim,\n\t\t\t\tviewPadding: pad,\n\t\t\t\tscrollWidth: scrollWidth,\n\t\t\t\twrapWidth: wrapWidth,\n\t\t\t\tmarginWidth: marginWidth,\n\t\t\t\tcharWidth: charWidth,\n\t\t\t\tinvalid: invalid\n\t\t\t};\n\t\t},\n\t\t_cancelAnimation: function() {\n\t\t\tif (this._animation) {\n\t\t\t\tthis._animation.stop();\n\t\t\t\tthis._animation = null;\n\t\t\t}\n\t\t},\n\t\t_clearSelection: function (direction) {\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (direction === \"next\") { //$NON-NLS-0$\n\t\t\t\t\tselection.start = selection.end;\n\t\t\t\t} else {\n\t\t\t\t\tselection.end = selection.start;\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._setSelection(selections, true);\n\t\t\treturn true;\n\t\t},\n\t\t_commitIME: function (insertText) {\n\t\t\tif (this._imeOffset === -1) { return; }\n\t\t\tvar model = this._model;\n\t\t\tvar lineIndex = model.getLineAtOffset(this._imeOffset);\n\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\tvar line = this._getLineNode(lineIndex);\n\t\t\tif (!insertText) {\n\t\t\t\t// make the state of the IME match the state the view expects it be in\n\t\t\t\t// when the view commits the text and IME also need to be committed\n\t\t\t\t// this can be accomplished by changing the focus around\n\t\t\t\tthis._scrollDiv.focus();\n\t\t\t\tthis._clientDiv.focus();\n\t\t\t\t\n\t\t\t\tvar newText = this._getDOMText(line).text;\n\t\t\t\tvar oldText = model.getLine(lineIndex);\n\t\t\t\tvar start = this._imeOffset - lineStart;\n\t\t\t\tvar end = start + newText.length - oldText.length;\n\t\t\t\tif (start !== end) {\n\t\t\t\t\tinsertText = newText.substring(start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._imeOffset = -1;\n\t\t\tif (insertText) {\n\t\t\t\tif (!this._doContent(insertText) && !util.isWebkit) {\n\t\t\t\t\tline.lineRemoved = true;\n\t\t\t\t\tthis._queueUpdate();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_createActions: function () {\n\t\t\tthis.addKeyMode(new mKeyModes.DefaultKeyMode(this));\n\t\t\t//1 to 1, no duplicates\n\t\t\tvar self = this;\n\t\t\tthis._actions = {\n\t\t\t\t\"noop\": {defaultHandler: function() {return self._doNoop();}}, //$NON-NLS-0$\n\n\t\t\t\t\"lineUp\": {defaultHandler: function(data) {return self._doLineUp(merge(data,{select: false}));}, actionDescription: {name: messages.lineUp}}, //$NON-NLS-0$\n\t\t\t\t\"lineDown\": {defaultHandler: function(data) {return self._doLineDown(merge(data,{select: false}));}, actionDescription: {name: messages.lineDown}}, //$NON-NLS-0$\n\t\t\t\t\"lineStart\": {defaultHandler: function(data) {return self._doHome(merge(data,{select: false, ctrl:false}));}, actionDescription: {name: messages.lineStart}}, //$NON-NLS-0$\n\t\t\t\t\"lineEnd\": {defaultHandler: function(data) {return self._doEnd(merge(data,{select: false, ctrl:false}));}, actionDescription: {name: messages.lineEnd}}, //$NON-NLS-0$\n\t\t\t\t\"charPrevious\": {defaultHandler: function(data) {return self._doCursorPrevious(merge(data,{select: false, unit:\"character\"}));}, actionDescription: {name: messages.charPrevious}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"charNext\": {defaultHandler: function(data) {return self._doCursorNext(merge(data,{select: false, unit:\"character\"}));}, actionDescription: {name: messages.charNext}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"pageUp\": {defaultHandler: function(data) {return self._doPageUp(merge(data,{select: false}));}, actionDescription: {name: messages.pageUp}}, //$NON-NLS-0$\n\t\t\t\t\"pageDown\": {defaultHandler: function(data) {return self._doPageDown(merge(data,{select: false}));}, actionDescription: {name: messages.pageDown}}, //$NON-NLS-0$\n\t\t\t\t\"scrollPageUp\": {defaultHandler: function(data) {return self._doScroll(merge(data,{type: \"pageUp\"}));}, actionDescription: {name: messages.scrollPageUp}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"scrollPageDown\": {defaultHandler: function(data) {return self._doScroll(merge(data,{type: \"pageDown\"}));}, actionDescription: {name: messages.scrollPageDown}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"scrollLineUp\": {defaultHandler: function(data) {return self._doScroll(merge(data,{type: \"lineUp\"}));}, actionDescription: {name: messages.scrollLineUp}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"scrollLineDown\": {defaultHandler: function(data) {return self._doScroll(merge(data,{type: \"lineDown\"}));}, actionDescription: {name: messages.scrollLineDown}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"wordPrevious\": {defaultHandler: function(data) {return self._doCursorPrevious(merge(data,{select: false, unit:\"word\"}));}, actionDescription: {name: messages.wordPrevious}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"wordNext\": {defaultHandler: function(data) {return self._doCursorNext(merge(data,{select: false, unit:\"word\"}));}, actionDescription: {name: messages.wordNext}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"textStart\": {defaultHandler: function(data) {return self._doHome(merge(data,{select: false, ctrl:true}));}, actionDescription: {name: messages.textStart}}, //$NON-NLS-0$\n\t\t\t\t\"textEnd\": {defaultHandler: function(data) {return self._doEnd(merge(data,{select: false, ctrl:true}));}, actionDescription: {name: messages.textEnd}}, //$NON-NLS-0$\n\t\t\t\t\"scrollTextStart\": {defaultHandler: function(data) {return self._doScroll(merge(data,{type: \"textStart\"}));}, actionDescription: {name: messages.scrollTextStart}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"scrollTextEnd\": {defaultHandler: function(data) {return self._doScroll(merge(data,{type: \"textEnd\"}));}, actionDescription: {name: messages.scrollTextEnd}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"centerLine\": {defaultHandler: function(data) {return self._doScroll(merge(data,{type: \"centerLine\"}));}, actionDescription: {name: messages.centerLine}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\n\t\t\t\t\"selectLineUp\": {defaultHandler: function(data) {return self._doLineUp(merge(data,{select: true}));}, actionDescription: {name: messages.selectLineUp}}, //$NON-NLS-0$\n\t\t\t\t\"selectLineDown\": {defaultHandler: function(data) {return self._doLineDown(merge(data,{select: true}));}, actionDescription: {name: messages.selectLineDown}}, //$NON-NLS-0$\n\t\t\t\t\"selectWholeLineUp\": {defaultHandler: function(data) {return self._doLineUp(merge(data,{select: true, wholeLine: true}));}, actionDescription: {name: messages.selectWholeLineUp}}, //$NON-NLS-0$\n\t\t\t\t\"selectWholeLineDown\": {defaultHandler: function(data) {return self._doLineDown(merge(data,{select: true, wholeLine: true}));}, actionDescription: {name: messages.selectWholeLineDown}}, //$NON-NLS-0$\n\t\t\t\t\"selectLineStart\": {defaultHandler: function(data) {return self._doHome(merge(data,{select: true, ctrl:false}));}, actionDescription: {name: messages.selectLineStart}}, //$NON-NLS-0$\n\t\t\t\t\"selectLineEnd\": {defaultHandler: function(data) {return self._doEnd(merge(data,{select: true, ctrl:false}));}, actionDescription: {name: messages.selectLineEnd}}, //$NON-NLS-0$\n\t\t\t\t\"selectCharPrevious\": {defaultHandler: function(data) {return self._doCursorPrevious(merge(data,{select: true, unit:\"character\"}));}, actionDescription: {name: messages.selectCharPrevious}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"selectCharNext\": {defaultHandler: function(data) {return self._doCursorNext(merge(data,{select: true, unit:\"character\"}));}, actionDescription: {name: messages.selectCharNext}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"selectPageUp\": {defaultHandler: function(data) {return self._doPageUp(merge(data,{select: true}));}, actionDescription: {name: messages.selectPageUp}}, //$NON-NLS-0$\n\t\t\t\t\"selectPageDown\": {defaultHandler: function(data) {return self._doPageDown(merge(data,{select: true}));}, actionDescription: {name: messages.selectPageDown}}, //$NON-NLS-0$\n\t\t\t\t\"selectWordPrevious\": {defaultHandler: function(data) {return self._doCursorPrevious(merge(data,{select: true, unit:\"word\"}));}, actionDescription: {name: messages.selectWordPrevious}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"selectWordNext\": {defaultHandler: function(data) {return self._doCursorNext(merge(data,{select: true, unit:\"word\"}));}, actionDescription: {name: messages.selectWordNext}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"selectTextStart\": {defaultHandler: function(data) {return self._doHome(merge(data,{select: true, ctrl:true}));}, actionDescription: {name: messages.selectTextStart}}, //$NON-NLS-0$\n\t\t\t\t\"selectTextEnd\": {defaultHandler: function(data) {return self._doEnd(merge(data,{select: true, ctrl:true}));}, actionDescription: {name: messages.selectTextEnd}}, //$NON-NLS-0$\n\n\t\t\t\t\"deletePrevious\": {defaultHandler: function(data) {return self._doBackspace(merge(data,{unit:\"character\"}));}, actionDescription: {name: messages.deletePrevious}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"deleteNext\": {defaultHandler: function(data) {return self._doDelete(merge(data,{unit:\"character\"}));}, actionDescription: {name: messages.deleteNext}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"deleteWordPrevious\": {defaultHandler: function(data) {return self._doBackspace(merge(data,{unit:\"word\"}));}, actionDescription: {name: messages.deleteWordPrevious}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"deleteWordNext\": {defaultHandler: function(data) {return self._doDelete(merge(data,{unit:\"word\"}));}, actionDescription: {name: messages.deleteWordNext}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"deleteLineStart\": {defaultHandler: function(data) {return self._doBackspace(merge(data,{unit: \"line\"}));}, actionDescription: {name: messages.deleteLineStart}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"deleteLineEnd\": {defaultHandler: function(data) {return self._doDelete(merge(data,{unit: \"line\"}));}, actionDescription: {name: messages.deleteLineEnd}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"tab\": {defaultHandler: function(data) {return self._doTab(merge(data,{}));}, actionDescription: {name: messages.tab}}, //$NON-NLS-0$\n\t\t\t\t\"shiftTab\": {defaultHandler: function(data) {return self._doShiftTab(merge(data,{}));}, actionDescription: {name: messages.shiftTab}}, //$NON-NLS-0$\n\t\t\t\t\"enter\": {defaultHandler: function(data) {return self._doEnter(merge(data,{}));}, actionDescription: {name: messages.enter}}, //$NON-NLS-0$\n\t\t\t\t\"enterNoCursor\": {defaultHandler: function(data) {return self._doEnter(merge(data,{noCursor:true}));}, actionDescription: {name: messages.enterNoCursor}}, //$NON-NLS-0$\n\t\t\t\t\"escape\": {defaultHandler: function(data) {return self._doEscape(merge(data,{}));}, actionDescription: {name: messages.escape}}, //$NON-NLS-0$\n\t\t\t\t\"selectAll\": {defaultHandler: function(data) {return self._doSelectAll(merge(data,{}));}, actionDescription: {name: messages.selectAll}}, //$NON-NLS-0$\n\t\t\t\t\"copy\": {defaultHandler: function(data) {return self._doCopy(merge(data,{}));}, actionDescription: {name: messages.copy}}, //$NON-NLS-0$\n\t\t\t\t\"cut\": {defaultHandler: function(data) {return self._doCut(merge(data,{}));}, actionDescription: {name: messages.cut}}, //$NON-NLS-0$\n\t\t\t\t\"paste\": {defaultHandler: function(data) {return self._doPaste(merge(data,{}));}, actionDescription: {name: messages.paste}}, //$NON-NLS-0$\n\t\t\t\t\n\t\t\t\t\"uppercase\": {defaultHandler: function(data) {return self._doCase(merge(data,{type: \"upper\"}));}, actionDescription: {name: messages.uppercase}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"lowercase\": {defaultHandler: function(data) {return self._doCase(merge(data,{type: \"lower\"}));}, actionDescription: {name: messages.lowercase}}, //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"capitalize\": {defaultHandler: function(data) {return self._doCase(merge(data,{unit: \"word\", type: \"capitalize\"}));}, actionDescription: {name: messages.capitalize}}, //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\"reversecase\": {defaultHandler: function(data) {return self._doCase(merge(data,{type: \"reverse\"}));}, actionDescription: {name: messages.reversecase}}, //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\n\t\t\t\t\"toggleOverwriteMode\": {defaultHandler: function(data) {return self._doOverwriteMode(merge(data,{}));}, actionDescription: {name: messages.toggleOverwriteMode}}, //$NON-NLS-0$\n\t\t\t\t\"toggleTabMode\": {defaultHandler: function(data) {return self._doTabMode(merge(data,{}));}, actionDescription: {name: messages.toggleTabMode}}, //$NON-NLS-0$\n\t\t\t\t\"toggleWrapMode\": {defaultHandler: function(data) {return self._doWrapMode(merge(data,{}));}, actionDescription: {name: messages.toggleWrapMode}} //$NON-NLS-0$\n\t\t\t};\n\t\t},\n\t\t_createRulerParent: function(document, className) {\n\t\t\tvar div = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tdiv.className = className;\n\t\t\tdiv.tabIndex = -1;\n\t\t\tdiv.style.overflow = \"hidden\"; //$NON-NLS-0$\n\t\t\tdiv.style.MozUserSelect = \"none\"; //$NON-NLS-0$\n\t\t\tdiv.style.WebkitUserSelect = \"none\"; //$NON-NLS-0$\n\t\t\tdiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\tdiv.style.top = \"0px\"; //$NON-NLS-0$\n\t\t\tdiv.style.bottom = \"0px\"; //$NON-NLS-0$\n\t\t\tdiv.style.cursor = \"default\"; //$NON-NLS-0$\n\t\t\tdiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\tdiv.setAttribute(\"aria-hidden\", \"true\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tthis._rootDiv.appendChild(div);\n\t\t\treturn div;\n\t\t},\n\t\t_createRuler: function(ruler, index) {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tvar rulerParent = this._getRulerParent(ruler);\n\t\t\tif (!rulerParent) { return; }\n\t\t\tif (rulerParent !== this._marginDiv || this._marginOffset) {\n\t\t\t\trulerParent.style.display = \"block\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\trulerParent.rulerWidth = undefined;\n\t\t\tvar div = util.createElement(rulerParent.ownerDocument, \"div\"); //$NON-NLS-0$\n\t\t\tdiv._ruler = ruler;\n\t\t\truler.node = div;\n\t\t\tdiv.rulerChanged = true;\n\t\t\tdiv.style.position = \"relative\"; //$NON-NLS-0$\n\t\t\tdiv.style.cssFloat = \"left\"; //$NON-NLS-0$\n\t\t\tdiv.style.styleFloat = \"left\"; //$NON-NLS-0$\n\t\t\tdiv.style.outline = \"none\"; //$NON-NLS-0$\n\t\t\tif (index === undefined || index < 0 || index >= rulerParent.children.length) {\n\t\t\t\trulerParent.appendChild(div);\n\t\t\t} else {\n\t\t\t\tvar sibling = rulerParent.firstChild;\n\t\t\t\twhile (sibling && index-- > 0) {\n\t\t\t\t\tsibling = sibling.nextSibling;\n\t\t\t\t}\n\t\t\t\trulerParent.insertBefore(div, sibling);\n\t\t\t}\n\t\t},\n\t\t_createSelectionDiv: function() {\n\t\t\tvar div = util.createElement(this._parent.ownerDocument, \"div\"); //$NON-NLS-0$\n\t\t\tdiv.className = \"textviewSelection\"; //$NON-NLS-0$\n\t\t\tdiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\tdiv.style.borderWidth = \"0px\"; //$NON-NLS-0$\n\t\t\tdiv.style.margin = \"0px\"; //$NON-NLS-0$\n\t\t\tdiv.style.padding = \"0px\"; //$NON-NLS-0$\n\t\t\tdiv.style.outline = \"none\"; //$NON-NLS-0$\n\t\t\tdiv.style.width = \"0px\"; //$NON-NLS-0$\n\t\t\tdiv.style.height = \"0px\"; //$NON-NLS-0$\n\t\t\tdiv.style.zIndex = \"0\"; //$NON-NLS-0$\n\t\t\treturn div;\n\t\t},\n\t\t_createView: function() {\n\t\t\tif (this._clientDiv) { return; }\n\t\t\tvar parent = this._parent;\n\t\t\twhile (parent.hasChildNodes()) { parent.removeChild(parent.lastChild); }\n\n\t\t\tvar document = parent.ownerDocument;\n\t\t\tvar rootDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tthis._rootDiv = rootDiv;\n\t\t\trootDiv.tabIndex = -1;\n\t\t\trootDiv.style.position = \"relative\"; //$NON-NLS-0$\n\t\t\trootDiv.style.overflow = \"hidden\"; //$NON-NLS-0$\n\t\t\trootDiv.style.width = \"100%\"; //$NON-NLS-0$\n\t\t\trootDiv.style.height = \"100%\"; //$NON-NLS-0$\n\t\t\trootDiv.style.overflow = \"hidden\"; //$NON-NLS-0$\n\t\t\trootDiv.style.WebkitTextSizeAdjust = \"100%\"; //$NON-NLS-0$\n\t\t\trootDiv.setAttribute(\"role\", \"application\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tparent.appendChild(rootDiv);\n\t\t\t\n\t\t\tvar leftDiv = this._createRulerParent(document, \"textviewLeftRuler\"); //$NON-NLS-0$\n\t\t\tthis._leftDiv = leftDiv;\n\n\t\t\tvar viewDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tviewDiv.className = \"textviewScroll\"; //$NON-NLS-0$\n\t\t\tthis._viewDiv = viewDiv;\n\t\t\tviewDiv.tabIndex = -1;\n\t\t\tviewDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\tviewDiv.style.top = \"0px\"; //$NON-NLS-0$\n\t\t\tviewDiv.style.bottom = \"0px\"; //$NON-NLS-0$\n\t\t\tviewDiv.style.borderWidth = \"0px\"; //$NON-NLS-0$\n\t\t\tviewDiv.style.margin = \"0px\"; //$NON-NLS-0$\n\t\t\tviewDiv.style.outline = \"none\"; //$NON-NLS-0$\n\t\t\tviewDiv.style.background = \"transparent\"; //$NON-NLS-0$\n\t\t\trootDiv.appendChild(viewDiv);\n\t\t\t\n\t\t\tvar rightDiv = this._createRulerParent(document, \"textviewRightRuler\"); //$NON-NLS-0$\n\t\t\tthis._rightDiv = rightDiv;\n\t\t\trightDiv.style.right = \"0px\"; //$NON-NLS-0$\n\n\t\t\tvar innerRightDiv = this._createRulerParent(document, \"textviewInnerRightRuler\"); //$NON-NLS-0$\n\t\t\tthis._innerRightDiv = innerRightDiv;\n\t\t\tinnerRightDiv.style.zIndex = \"1\"; //$NON-NLS-0$\n\n\t\t\tvar scrollDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tthis._scrollDiv = scrollDiv;\n\t\t\tscrollDiv.style.margin = \"0px\"; //$NON-NLS-0$\n\t\t\tscrollDiv.style.borderWidth = \"0px\"; //$NON-NLS-0$\n\t\t\tscrollDiv.style.padding = \"0px\"; //$NON-NLS-0$\n\t\t\tviewDiv.appendChild(scrollDiv);\n\t\t\t\n\t\t\tvar marginDiv = this._marginDiv = this._createRulerParent(document, \"textviewMarginRuler\"); //$NON-NLS-0$\n\t\t\tmarginDiv.style.zIndex = \"4\"; //$NON-NLS-0$\n\t\t\t\n\t\t\tif (!util.isIE && !util.isIOS) {\n\t\t\t\tvar clipDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tthis._clipDiv = clipDiv;\n\t\t\t\tclipDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.overflow = \"hidden\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.margin = \"0px\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.borderWidth = \"0px\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.padding = \"0px\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.background = \"transparent\"; //$NON-NLS-0$\n\t\t\t\trootDiv.appendChild(clipDiv);\n\t\t\t\t\n\t\t\t\tvar clipScrollDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tthis._clipScrollDiv = clipScrollDiv;\n\t\t\t\tclipScrollDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\t\tclipScrollDiv.style.height = \"1px\"; //$NON-NLS-0$\n\t\t\t\tclipScrollDiv.style.top = \"-1000px\"; //$NON-NLS-0$\n\t\t\t\tclipScrollDiv.style.background = \"transparent\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.appendChild(clipScrollDiv);\n\t\t\t}\n\n\t\t\tvar clientDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tclientDiv.className = \"textviewContent\"; //$NON-NLS-0$\n\t\t\tthis._clientDiv = clientDiv;\n\t\t\tclientDiv.tabIndex = 0;\n\t\t\tclientDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\tclientDiv.style.borderWidth = \"0px\"; //$NON-NLS-0$\n\t\t\tclientDiv.style.margin = \"0px\"; //$NON-NLS-0$\n\t\t\tclientDiv.style.padding = \"0px\"; //$NON-NLS-0$\n\t\t\tclientDiv.style.outline = \"none\"; //$NON-NLS-0$\n\t\t\tclientDiv.style.zIndex = \"1\"; //$NON-NLS-0$\n\t\t\tclientDiv.style.WebkitUserSelect = \"text\"; //$NON-NLS-0$\n\t\t\tclientDiv.setAttribute(\"spellcheck\", \"false\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tif (util.isIOS || util.isAndroid) {\n\t\t\t\tclientDiv.style.WebkitTapHighlightColor = \"transparent\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\t(this._clipDiv || rootDiv).appendChild(clientDiv);\n\t\t\t\n\t\t\tthis._setFullSelection(this._fullSelection, true);\n\t\t\t\n\t\t\tif (util.isIOS || util.isAndroid) {\n\t\t\t\tvar vScrollDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tthis._vScrollDiv = vScrollDiv;\n\t\t\t\tvScrollDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.borderWidth = \"1px\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.borderColor = \"white\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.borderStyle = \"solid\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.borderRadius = \"4px\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.backgroundColor = \"black\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.opacity = \"0.5\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.margin = \"0px\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.padding = \"0px\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.outline = \"none\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.zIndex = \"3\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.width = \"8px\"; //$NON-NLS-0$\n\t\t\t\tvScrollDiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\trootDiv.appendChild(vScrollDiv);\n\t\t\t\tvar hScrollDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tthis._hScrollDiv = hScrollDiv;\n\t\t\t\thScrollDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.borderWidth = \"1px\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.borderColor = \"white\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.borderStyle = \"solid\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.borderRadius = \"4px\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.backgroundColor = \"black\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.opacity = \"0.5\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.margin = \"0px\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.padding = \"0px\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.outline = \"none\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.zIndex = \"3\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.height = \"8px\"; //$NON-NLS-0$\n\t\t\t\thScrollDiv.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\trootDiv.appendChild(hScrollDiv);\n\t\t\t}\n\n\t\t\tif (util.isFirefox && !clientDiv.setCapture) {\n\t\t\t\tvar overlayDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tthis._overlayDiv = overlayDiv;\n\t\t\t\toverlayDiv.style.position = clientDiv.style.position;\n\t\t\t\toverlayDiv.style.borderWidth = clientDiv.style.borderWidth;\n\t\t\t\toverlayDiv.style.margin = clientDiv.style.margin;\n\t\t\t\toverlayDiv.style.padding = clientDiv.style.padding;\n\t\t\t\toverlayDiv.style.cursor = \"text\"; //$NON-NLS-0$\n\t\t\t\toverlayDiv.style.zIndex = \"2\"; //$NON-NLS-0$\n\t\t\t\t(this._clipDiv || rootDiv).appendChild(overlayDiv);\n\t\t\t}\n\t\t\tclientDiv.contentEditable = \"true\"; //$NON-NLS-0$\n\t\t\tclientDiv.setAttribute(\"role\", \"textbox\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tclientDiv.setAttribute(\"aria-multiline\", \"true\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tthis._setWrapMode(this._wrapMode, true);\n\t\t\tthis._setReadOnly(this._readonly);\n\t\t\tthis._setThemeClass(this._themeClass, true);\n\t\t\tthis._setTabSize(this._tabSize, true);\n\t\t\tthis._setMarginOffset(this._marginOffset, true);\n\t\t\tthis._hookEvents();\n\t\t\tvar rulers = this._rulers;\n\t\t\tfor (var i=0; i<rulers.length; i++) {\n\t\t\t\tthis._createRuler(rulers[i]);\n\t\t\t}\n\t\t\tthis._update();\n\t\t\t// Detect when the parent is attached to the DOM or display\n\t\t\tvar self = this;\n\t\t\tfunction checkDOMReady() {\n\t\t\t\tif (!self._rootDiv) { return; }\n\t\t\t\tself.update(true);\n\t\t\t\tif (self._metrics.invalid) {\n\t\t\t\t\tself._getWindow().setTimeout(function() {\n\t\t\t\t\t\tcheckDOMReady();\n\t\t\t\t\t}, 100);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDOMReady(document, rootDiv, \"textview\", checkDOMReady); //$NON-NLS-0$\n\t\t},\n\t\t_defaultOptions: function() {\n\t\t\treturn {\n\t\t\t\tparent: {value: undefined, update: null},\n\t\t\t\tmodel: {value: undefined, update: this.setModel},\n\t\t\t\tscrollAnimation: {value: 0, update: null},\n\t\t\t\treadonly: {value: false, update: this._setReadOnly},\n\t\t\t\tfullSelection: {value: true, update: this._setFullSelection},\n\t\t\t\ttabMode: { value: true, update: null },\n\t\t\t\ttabSize: {value: 8, update: this._setTabSize},\n\t\t\t\texpandTab: {value: false, update: null},\n\t\t\t\tsingleMode: {value: false, update: this._setSingleMode},\n\t\t\t\tnoScroll: {value: false, update: this._setNoScroll},\n\t\t\t\toverwriteMode: { value: false, update: this._setOverwriteMode },\n\t\t\t\tblockCursorVisible: { value: false, update: this._setBlockCursor},\n\t\t\t\tmarginOffset: {value: 0, update: this._setMarginOffset},\n\t\t\t\twrapOffset: {value: 0, update: this._setWrapOffset},\n\t\t\t\twrapMode: {value: false, update: this._setWrapMode},\n\t\t\t\twrappable: {value: false, update: null},\n\t\t\t\tundoStack: {value: null, update: this._setUndoStack},\n\t\t\t\ttheme: {value: mTextTheme.TextTheme.getTheme(), update: this._setTheme},\n\t\t\t\tthemeClass: {value: undefined, update: this._setThemeClass}\n\t\t\t};\n\t\t},\n\t\t_destroyRuler: function(ruler) {\n\t\t\tvar rulerParent = this._getRulerParent(ruler);\n\t\t\tif (rulerParent) {\n\t\t\t\tvar div = rulerParent.firstChild;\n\t\t\t\twhile (div) {\n\t\t\t\t\tif (div._ruler === ruler) {\n\t\t\t\t\t\tdiv._ruler = undefined;\n\t\t\t\t\t\trulerParent.removeChild(div);\n\t\t\t\t\t\tif (rulerParent.children.length === 0 && (rulerParent !== this._marginDiv || !this._marginOffset)) {\n\t\t\t\t\t\t\trulerParent.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\t\t\t}\n\t\t\t\t\t\trulerParent.rulerWidth = undefined;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdiv = div.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_destroyView: function() {\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tif (!clientDiv) { return; }\n\t\t\tthis._setGrab(null);\n\t\t\tthis._unhookEvents();\n\n\t\t\t/* Destroy timers */\n\t\t\tvar window = this._getWindow();\n\t\t\tif (this._autoScrollTimerID) {\n\t\t\t\twindow.clearTimeout(this._autoScrollTimerID);\n\t\t\t\tthis._autoScrollTimerID = null;\n\t\t\t}\n\t\t\tif (this._updateTimer) {\n\t\t\t\twindow.clearTimeout(this._updateTimer);\n\t\t\t\tthis._updateTimer = null;\n\t\t\t}\n\t\t\tif (this._calculateLHTimer) {\n\t\t\t\twindow.clearTimeout(this._calculateLHTimer);\n\t\t\t\tthis._calculateLHTimer = null;\n\t\t\t}\n\t\t\tif (this._cursorTimer) {\n\t\t\t\twindow.clearInterval(this._cursorTimer);\n\t\t\t\tthis._cursorTimer = null;\n\t\t\t}\n\t\t\tif (this._imeTimeout) {\n\t\t\t\twindow.clearInterval(this._imeTimeout);\n\t\t\t\tthis._imeTimeout = null;\n\t\t\t}\n\t\t\t\n\t\t\tvar rootDiv = this._rootDiv;\n\t\t\trootDiv.parentNode.removeChild(rootDiv);\n\n\t\t\t/* Destroy DOM */\n\t\t\tthis._domSelection = null;\n\t\t\tthis._clipboardDiv = null;\n\t\t\tthis._rootDiv = null;\n\t\t\tthis._scrollDiv = null;\n\t\t\tthis._viewDiv = null;\n\t\t\tthis._clipDiv = null;\n\t\t\tthis._clipScrollDiv = null;\n\t\t\tthis._clientDiv = null;\n\t\t\tthis._overlayDiv = null;\n\t\t\tthis._leftDiv = null;\n\t\t\tthis._rightDiv = null;\n\t\t\tthis._innerRightDiv = null;\n\t\t\tthis._marginDiv = null;\n\t\t\tthis._cursorDiv = null;\n\t\t\tthis._vScrollDiv = null;\n\t\t\tthis._hScrollDiv = null;\n\t\t},\n\t\t_doAutoScroll: function (direction, x, y) {\n\t\t\tthis._autoScrollDir = direction;\n\t\t\tthis._autoScrollX = x;\n\t\t\tthis._autoScrollY = y;\n\t\t\tif (!this._autoScrollTimerID) {\n\t\t\t\tthis._autoScrollTimer();\n\t\t\t}\n\t\t},\n\t\t_endAutoScroll: function () {\n\t\t\tif (this._autoScrollTimerID) {\n\t\t\t\tvar window = this._getWindow();\n\t\t\t\twindow.clearTimeout(this._autoScrollTimerID);\n\t\t\t}\n\t\t\tthis._autoScrollDir = undefined;\n\t\t\tthis._autoScrollTimerID = undefined;\n\t\t},\n\t\t_fixCaret: function() {\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tif (clientDiv) {\n\t\t\t\tvar hasFocus = this._hasFocus;\n\t\t\t\tthis._ignoreFocus = true;\n\t\t\t\tif (hasFocus) { clientDiv.blur(); }\n\t\t\t\tclientDiv.contentEditable = false;\n\t\t\t\tclientDiv.contentEditable = true;\n\t\t\t\tif (hasFocus) { clientDiv.focus(); }\n\t\t\t\tthis._ignoreFocus = false;\n\t\t\t}\n\t\t},\n\t\t_getBaseText: function(start, end) {\n\t\t\tvar model = this._model;\n\t\t\t/* This is the only case the view access the base model, alternatively the view could use a event to application to customize the text */\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tstart = model.mapOffset(start);\n\t\t\t\tend = model.mapOffset(end);\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\treturn model.getText(start, end);\n\t\t},\n\t\t_getBottomIndex: function (fullyVisible) {\n\t\t\tvar child = this._bottomChild;\n\t\t\tif (fullyVisible && this._getClientHeight() > this._getLineHeight()) {\n\t\t\t\tvar rect = child.getBoundingClientRect();\n\t\t\t\tvar clientRect = this._clientDiv.getBoundingClientRect();\n\t\t\t\tif (rect.bottom > clientRect.bottom) {\n\t\t\t\t\tchild = this._getLinePrevious(child) || child;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn child.lineIndex;\n\t\t},\n\t\t_getBlockSelections: function(selections, lineIndex, pt) {\n\t\t\tvar model = this._model;\n\t\t\tselections = selections.filter(function(sel) { return !sel._editing; });\n\t\t\tvar firstLine = model.getLineAtOffset(this._blockSelection.getAnchor()), lastLine;\n\t\t\tif (lineIndex > firstLine) {\n\t\t\t\tlastLine = lineIndex;\n\t\t\t} else {\n\t\t\t\tlastLine = firstLine;\n\t\t\t\tfirstLine = lineIndex;\n\t\t\t}\n\t\t\tfor (var l = firstLine; l <= lastLine; l++) {\n\t\t\t\tvar line = this._getLine(l);\n\t\t\t\tvar o1 = line.getOffset(pt.x, 1);\n\t\t\t\tvar o2 = line.getOffset(this._blockSelection._docX, 1);\n\t\t\t\tline.destroy();\n\t\t\t\tif (o1 === o2 && o1 === model.getLineEnd(l)) continue;\n\t\t\t\tvar caret = o1 < o2;\n\t\t\t\tvar sel = new Selection(caret ? o1 : o2, caret ? o2 : o1, caret);\n\t\t\t\tsel._editing = true;\n\t\t\t\tselections.push(sel);\n\t\t\t}\n\t\t\treturn selections;\n\t\t},\n\t\t_getBoundsAtOffset: function(offset) {\n\t\t\tvar model = this._model;\n\t\t\tvar line = this._getLine(model.getLineAtOffset(offset));\n\t\t\tvar result = line.getBoundingClientRect(offset);\n\t\t\tvar linePixel = this._getLinePixel(line.lineIndex);\n\t\t\tresult.top += linePixel;\n\t\t\tresult.bottom += linePixel;\n\t\t\tline.destroy();\n\t\t\treturn result;\n\t\t},\n\t\t_getClientHeight: function() {\n\t\t\tvar viewPad = this._getViewPadding();\n\t\t\treturn Math.max(0, this._viewDiv.clientHeight - viewPad.top - viewPad.bottom);\n\t\t},\n\t\t_getInnerRightWidth: function() {\n\t\t\tvar innerRightWidth = this._innerRightDiv.rulerWidth;\n\t\t\tif (innerRightWidth === undefined) {\n\t\t\t\tvar innerRightRect = this._innerRightDiv.getBoundingClientRect();\n\t\t\t\tthis._innerRightDiv.rulerWidth = innerRightWidth = innerRightRect.right - innerRightRect.left;\n\t\t\t}\n\t\t\treturn innerRightWidth;\n\t\t},\n\t\t_getClientWidth: function() {\n\t\t\tvar viewPad = this._getViewPadding();\n\t\t\tvar innerRightWidth = this._getInnerRightWidth();\n\t\t\treturn Math.max(0, this._viewDiv.clientWidth - viewPad.left - viewPad.right - innerRightWidth);\n\t\t},\n\t\t_getClipboardText: function (event, handler) {\n\t\t\t// IE\n\t\t\tvar window = this._getWindow();\n\t\t\tvar clipboardData = window.clipboardData;\n\t\t\t// WebKit and Firefox > 21\n\t\t\tif (!clipboardData && event) {\n\t\t\t\tclipboardData = event.clipboardData;\n\t\t\t}\n\t\t\tfunction convert(wholeText) {\n\t\t\t\tvar clipboadText = [];\n\t\t\t\tconvertDelimiter(wholeText, function(t) {clipboadText.push(t);}, null);\n\t\t\t\tif (handler) { handler(clipboadText); }\n\t\t\t\treturn clipboadText;\n\t\t\t}\n\t\t\tif (clipboardData) {\n\t\t\t\treturn convert(clipboardData.getData(util.isIE ? \"Text\" : \"text/plain\")); //$NON-NLS-1$\"//$NON-NLS-0$\n\t\t\t}\n\t\t\tif (util.isFirefox) {\n\t\t\t\tthis._ignoreFocus = true;\n\t\t\t\tvar clipboardDiv = this._clipboardDiv;\n\t\t\t\tvar document = this._rootDiv.ownerDocument;\n\t\t\t\tif (!clipboardDiv) {\n\t\t\t\t\tclipboardDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\t\tthis._clipboardDiv = clipboardDiv;\n\t\t\t\t\tclipboardDiv.style.position = \"fixed\"; //$NON-NLS-0$\n\t\t\t\t\tclipboardDiv.style.whiteSpace = \"pre\"; //$NON-NLS-0$\n\t\t\t\t\tclipboardDiv.style.left = \"-1000px\"; //$NON-NLS-0$\n\t\t\t\t\tthis._rootDiv.appendChild(clipboardDiv);\n\t\t\t\t}\n\t\t\t\tclipboardDiv.innerHTML = \"<pre contenteditable=''></pre>\"; //$NON-NLS-0$\n\t\t\t\tclipboardDiv.firstChild.focus();\n\t\t\t\tvar self = this;\n\t\t\t\tvar _getText = function() {\n\t\t\t\t\tvar noteText = self._getTextFromElement(clipboardDiv);\n\t\t\t\t\tclipboardDiv.innerHTML = \"\";\n\t\t\t\t\treturn convert(noteText);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\t/* Try execCommand first. Works on firefox with clipboard permission. */\n\t\t\t\tvar result = false;\n\t\t\t\tthis._ignorePaste = true;\n\n\t\t\t\t/* Do not try execCommand if middle-click is used, because if we do, we get the clipboard text, not the primary selection text. */\n\t\t\t\tif (!util.isLinux || this._lastMouseButton !== 2) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = document.execCommand(\"paste\", false, null); //$NON-NLS-0$\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t/* Firefox can throw even when execCommand() works, see bug 362835. */\n\t\t\t\t\t\tresult = clipboardDiv.childNodes.length > 1 || clipboardDiv.firstChild && clipboardDiv.firstChild.childNodes.length > 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._ignorePaste = false;\n\t\t\t\tif (!result) {\n\t\t\t\t\t/* Try native paste in DOM, works for firefox during the paste event. */\n\t\t\t\t\tif (event) {\n\t\t\t\t\t\twindow.setTimeout(function() {\n\t\t\t\t\t\t\tself.focus();\n\t\t\t\t\t\t\t_getText();\n\t\t\t\t\t\t\tself._ignoreFocus = false;\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* no event and no clipboard permission, paste can't be performed */\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\tthis._ignoreFocus = false;\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.focus();\n\t\t\t\tthis._ignoreFocus = false;\n\t\t\t\treturn _getText();\n\t\t\t}\n\t\t\treturn \"\";\n\t\t},\n\t\t_getDOMText: function(child, offsetNode) {\n\t\t\treturn child._line.getText(offsetNode);\n\t\t},\n\t\t_getTextFromElement: function(element) {\n\t\t\tvar document = element.ownerDocument;\n\t\t\tvar window = document.defaultView;\n\t\t\tif (!window.getSelection) {\n\t\t\t\treturn element.innerText || element.textContent;\n\t\t\t}\n\n\t\t\tvar newRange = document.createRange();\n\t\t\tnewRange.selectNode(element);\n\n\t\t\tvar selection = window.getSelection();\n\t\t\tvar oldRanges = [], i;\n\t\t\tfor (i = 0; i < selection.rangeCount; i++) {\n\t\t\t\toldRanges.push(selection.getRangeAt(i));\n\t\t\t}\n\n\t\t\tthis._ignoreSelect = true;\n\t\t\tselection.removeAllRanges();\n\t\t\tselection.addRange(newRange);\n\n\t\t\tvar text = selection.toString();\n\n\t\t\tselection.removeAllRanges();\n\t\t\tfor (i = 0; i < oldRanges.length; i++) {\n\t\t\t\tselection.addRange(oldRanges[i]);\n\t\t\t}\n\n\t\t\tthis._ignoreSelect = false;\n\t\t\treturn text;\n\t\t},\n\t\t_getViewPadding: function() {\n\t\t\treturn this._metrics.viewPadding;\n\t\t},\n\t\t_getLine: function(lineIndex) {\n\t\t\tvar child = this._getLineNode(lineIndex);\n\t\t\tif (child && !child.lineChanged && !child.lineRemoved) {\n\t\t\t\treturn child._line;\n\t\t\t}\n\t\t\treturn new TextLine(this, lineIndex);\n\t\t},\n\t\t_getLineHeight: function(lineIndex, calculate) {\n\t\t\tif (lineIndex !== undefined && this._lineHeight) {\n\t\t\t\tvar lineHeight = this._lineHeight[lineIndex];\n\t\t\t\tif (lineHeight) { return lineHeight; }\n\t\t\t\tif (calculate || calculate === undefined) {\n\t\t\t\t\tvar height = this._lineHeight[lineIndex] = this._calculateLineHeight(lineIndex);\n\t\t\t\t\treturn height;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._metrics.lineHeight;\n\t\t},\n\t\t_getLineNode: function (lineIndex) {\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tvar child = clientDiv.firstChild;\n\t\t\twhile (child) {\n\t\t\t\tif (lineIndex === child.lineIndex) {\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\t\t_getLineNext: function (lineNode) {\n\t\t\tvar node = lineNode ? lineNode.nextSibling : this._clientDiv.firstChild;\n\t\t\twhile (node && (node.lineIndex === -1 || !node._line)) {\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\t\t_getLinePrevious: function (lineNode) {\n\t\t\tvar node = lineNode ? lineNode.previousSibling : this._clientDiv.lastChild;\n\t\t\twhile (node && (node.lineIndex === -1 || !node._line)) {\n\t\t\t\tnode = node.previousSibling;\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\t\t_getLinePixel: function(lineIndex) {\n\t\t\tlineIndex = Math.min(Math.max(0, lineIndex), this._model.getLineCount());\n\t\t\tif (this._lineHeight) {\n\t\t\t\tvar topIndex = this._getTopIndex();\n\t\t\t\tvar pixel = -this._topIndexY + this._getScroll().y, i;\n\t\t\t\tif (lineIndex > topIndex) {\n\t\t\t\t\tfor (i = topIndex; i < lineIndex; i++) {\n\t\t\t\t\t\tpixel += this._getLineHeight(i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = topIndex - 1; i >= lineIndex; i--) {\n\t\t\t\t\t\tpixel -= this._getLineHeight(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn pixel;\n\t\t\t}\n\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\treturn lineHeight * lineIndex;\n\t\t},\n\t\t/**\n\t\t * @name _getLineIndex\n\t\t * @description Returns the line index closest to the given text view relative location.  Will return -1\n\t\t * \t\t\t\tif restrictToValidLines is true and y location is outside of text lines.\n\t\t * @function\n\t\t * @private\n\t\t * @param y location to search\n\t\t * @param restrictToValidLines whether to return -1 if the location is outside a valid line, otherwise return the closest valid line index\n\t\t * @returns returns The line index closest to the location or -1 if restrictToValidLines is true and location is outside text area\n\t\t */\n\t\t_getLineIndex: function(y, restrictToValidLines) {\n\t\t\tvar lineHeight, lineIndex = 0;\n\t\t\tvar lineCount = this._model.getLineCount();\n\t\t\tif (this._lineHeight) {\n\t\t\t\tlineIndex = this._getTopIndex();\n\t\t\t\tvar pixel = -this._topIndexY + this._getScroll().y;\n\t\t\t\tif (y !== pixel) {\n\t\t\t\t\tif (y < pixel) {\n\t\t\t\t\t\twhile (y < pixel && lineIndex > 0) {\n\t\t\t\t\t\t\ty += this._getLineHeight(--lineIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlineHeight = this._getLineHeight(lineIndex);\n\t\t\t\t\t\twhile (y - lineHeight >= pixel && lineIndex < lineCount - 1) {\n\t\t\t\t\t\t\ty -= lineHeight;\n\t\t\t\t\t\t\tlineHeight = this._getLineHeight(++lineIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineHeight = this._getLineHeight();\n\t\t\t\tlineIndex = Math.floor(y / lineHeight);\n\t\t\t}\n\t\t\tif (restrictToValidLines){\n\t\t\t\tif (lineCount === 0 || lineIndex < 0 || lineIndex > (lineCount-1)){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Math.max(0, Math.min(lineCount - 1, lineIndex));\n\t\t},\n\t\t_getRulerParent: function(ruler) {\n\t\t\tswitch (ruler.getLocation()) {\n\t\t\t\tcase \"left\": return this._leftDiv; //$NON-NLS-0$\n\t\t\t\tcase \"right\": return this._rightDiv; //$NON-NLS-0$\n\t\t\t\tcase \"innerRight\": return this._innerRightDiv; //$NON-NLS-0$\n\t\t\t\tcase \"margin\": return this._marginDiv; //$NON-NLS-0$\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t_getScroll: function(cancelAnimation) {\n\t\t\tif (cancelAnimation === undefined || cancelAnimation) {\n\t\t\t\tthis._cancelAnimation();\n\t\t\t}\n\t\t\tvar viewDiv = this._viewDiv;\n\t\t\treturn {x: viewDiv.scrollLeft, y: viewDiv.scrollTop};\n\t\t},\n\t\t_getSelection: function () {\n\t\t\treturn (Array.isArray(this._selection) ? this._selection[0] : this._selection).clone();\n\t\t},\n\t\t_getSelections: function () {\n\t\t\treturn (Array.isArray(this._selection) ? this._selection : [this._selection]).map(function(s) {\n\t\t\t\treturn s.clone();\n\t\t\t});\n\t\t},\n\t\t_getTopIndex: function (fullyVisible) {\n\t\t\tvar child = this._topChild;\n\t\t\tif (fullyVisible && this._getClientHeight() > this._getLineHeight()) {\n\t\t\t\tvar rect = child.getBoundingClientRect();\n\t\t\t\tvar viewPad = this._getViewPadding();\n\t\t\t\tvar viewRect = this._viewDiv.getBoundingClientRect();\n\t\t\t\tif (rect.top < viewRect.top + viewPad.top) {\n\t\t\t\t\tchild = this._getLineNext(child) || child;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn child.lineIndex;\n\t\t},\n\t\t_hookEvents: function() {\n\t\t\tvar self = this;\n\t\t\tthis._modelListener = {\n\t\t\t\t/** @private */\n\t\t\t\tonChanging: function(modelChangingEvent) {\n\t\t\t\t\tself._onModelChanging(modelChangingEvent);\n\t\t\t\t},\n\t\t\t\t/** @private */\n\t\t\t\tonChanged: function(modelChangedEvent) {\n\t\t\t\t\tself._onModelChanged(modelChangedEvent);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._model.addEventListener(\"preChanging\", this._modelListener.onChanging); //$NON-NLS-0$\n\t\t\tthis._model.addEventListener(\"postChanged\", this._modelListener.onChanged); //$NON-NLS-0$\n\t\t\t\n\t\t\tthis._themeListener = {\n\t\t\t\tonChanged: function() {\n\t\t\t\t\tself._setThemeClass(self._themeClass);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._theme.addEventListener(\"ThemeChanged\", this._themeListener.onChanged); //$NON-NLS-0$\n\t\t\t\n\t\t\tvar handlers = this._handlers = [];\n\t\t\tvar clientDiv = this._clientDiv, viewDiv = this._viewDiv, rootDiv = this._rootDiv;\n\t\t\tvar topNode = this._overlayDiv || clientDiv;\n\t\t\tvar document = clientDiv.ownerDocument;\n\t\t\tvar window = this._getWindow();\n\t\t\tvar grabNode = util.isIE ? document : window;\n\t\t\thandlers.push({target: window, type: \"resize\", handler: function(e) { return self._handleResize(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"blur\", handler: function(e) { return self._handleBlur(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"focus\", handler: function(e) { return self._handleFocus(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: viewDiv, type: \"focus\", handler: function() { clientDiv.focus(); }}); //$NON-NLS-0$\n\t\t\thandlers.push({target: viewDiv, type: \"scroll\", handler: function(e) { return self._handleScroll(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"textInput\", handler: function(e) { return self._handleTextInput(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"keydown\", handler: function(e) { return self._handleKeyDown(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"keypress\", handler: function(e) { return self._handleKeyPress(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"keyup\", handler: function(e) { return self._handleKeyUp(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\tif (util.isIE) {\n\t\t\t\thandlers.push({target: document, type: \"keyup\", handler: function(e) { return self._handleDocKeyUp(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t}\n\t\t\thandlers.push({target: clientDiv, type: \"contextmenu\", handler: function(e) { return self._handleContextMenu(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"copy\", handler: function(e) { return self._handleCopy(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"cut\", handler: function(e) { return self._handleCut(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: clientDiv, type: \"paste\", handler: function(e) { return self._handlePaste(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\thandlers.push({target: document, type: \"selectionchange\", handler: function(e) { return self._handleSelectionChange(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\tif (util.isIOS || util.isAndroid) {\n\t\t\t\thandlers.push({target: clientDiv, type: \"touchstart\", handler: function(e) { return self._handleTouchStart(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: clientDiv, type: \"touchmove\", handler: function(e) { return self._handleTouchMove(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: clientDiv, type: \"touchend\", handler: function(e) { return self._handleTouchEnd(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\thandlers.push({target: clientDiv, type: \"selectstart\", handler: function(e) { return self._handleSelectStart(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: clientDiv, type: \"mousedown\", handler: function(e) { return self._handleMouseDown(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: clientDiv, type: \"mouseover\", handler: function(e) { return self._handleMouseOver(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: clientDiv, type: \"mouseout\", handler: function(e) { return self._handleMouseOut(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: grabNode, type: \"mouseup\", handler: function(e) { return self._handleMouseUp(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: grabNode, type: \"mousemove\", handler: function(e) { return self._handleMouseMove(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: rootDiv, type: \"mousedown\", handler: function(e) { return self._handleRootMouseDown(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: rootDiv, type: \"mouseup\", handler: function(e) { return self._handleRootMouseUp(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: topNode, type: \"dragstart\", handler: function(e) { return self._handleDragStart(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: topNode, type: \"drag\", handler: function(e) { return self._handleDrag(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: topNode, type: \"dragend\", handler: function(e) { return self._handleDragEnd(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: topNode, type: \"dragenter\", handler: function(e) { return self._handleDragEnter(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: topNode, type: \"dragover\", handler: function(e) { return self._handleDragOver(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: topNode, type: \"dragleave\", handler: function(e) { return self._handleDragLeave(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: topNode, type: \"drop\", handler: function(e) { return self._handleDrop(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\thandlers.push({target: this._clientDiv, type: util.isFirefox > 26 ? \"wheel\" : util.isFirefox ? \"DOMMouseScroll\" : \"mousewheel\", handler: function(e) { return self._handleMouseWheel(e ? e : window.event); }}); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tif (this._clipDiv) {\n\t\t\t\t\thandlers.push({target: this._clipDiv, type: util.isFirefox > 26 ? \"wheel\" : util.isFirefox ? \"DOMMouseScroll\" : \"mousewheel\", handler: function(e) { return self._handleMouseWheel(e ? e : window.event); }}); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (util.isFirefox && (!util.isWindows || util.isFirefox >= 15)) {\n\t\t\t\t\tvar MutationObserver = window.MutationObserver || window.MozMutationObserver;\n\t\t\t\t\tif (MutationObserver) {\n\t\t\t\t\t\tthis._mutationObserver = new MutationObserver(function(mutations) { self._handleDataModified(mutations); });\n\t\t\t\t\t\tthis._mutationObserver.observe(clientDiv, {subtree: true, characterData: true});\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandlers.push({target: this._clientDiv, type: \"DOMCharacterDataModified\", handler: function (e) { return self._handleDataModified(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((util.isFirefox && (!util.isWindows || util.isFirefox >= 15)) || util.isIE || util.isWebkit) {\n\t\t\t\t\thandlers.push({target: this._clientDiv, type: \"compositionstart\", handler: function (e) { return self._handleCompositionStart(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\t\thandlers.push({target: this._clientDiv, type: \"compositionend\", handler: function (e) { return self._handleCompositionEnd(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\t\thandlers.push({target: this._clientDiv, type: \"compositionupdate\", handler: function (e) { return self._handleCompositionUpdate(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (this._overlayDiv) {\n\t\t\t\t\thandlers.push({target: this._overlayDiv, type: \"mousedown\", handler: function(e) { return self._handleMouseDown(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\t\thandlers.push({target: this._overlayDiv, type: \"mouseover\", handler: function(e) { return self._handleMouseOver(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\t\thandlers.push({target: this._overlayDiv, type: \"mouseout\", handler: function(e) { return self._handleMouseOut(e ? e : window.event);}}); //$NON-NLS-0$\n\t\t\t\t\thandlers.push({target: this._overlayDiv, type: \"contextmenu\", handler: function(e) { return self._handleContextMenu(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (!this._isW3CEvents) {\n\t\t\t\t\thandlers.push({target: this._clientDiv, type: \"dblclick\", handler: function(e) { return self._handleDblclick(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._hookRulerEvents(this._leftDiv, handlers);\n\t\t\tthis._hookRulerEvents(this._rightDiv, handlers);\n\t\t\tthis._hookRulerEvents(this._innerRightDiv, handlers);\n\t\t\tthis._hookRulerEvents(this._marginDiv, handlers);\n\t\t\t\n\t\t\tfor (var i=0; i<handlers.length; i++) {\n\t\t\t\tvar h = handlers[i];\n\t\t\t\taddHandler(h.target, h.type, h.handler, h.capture);\n\t\t\t}\n\t\t},\n\t\t_hookRulerEvents: function(div, handlers) {\n\t\t\tif (!div) { return; }\n\t\t\tvar self = this;\n\t\t\tvar window = this._getWindow();\n\t\t\tif (util.isIE) {\n\t\t\t\thandlers.push({target: div, type: \"selectstart\", handler: function() {return false;}}); //$NON-NLS-0$\n\t\t\t}\n\t\t\thandlers.push({target: div, type: util.isFirefox > 26 ? \"wheel\" : util.isFirefox ? \"DOMMouseScroll\" : \"mousewheel\", handler: function(e) { return self._handleMouseWheel(e ? e : window.event); }}); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\thandlers.push({target: div, type: \"click\", handler: function(e) { self._handleRulerEvent(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\thandlers.push({target: div, type: \"dblclick\", handler: function(e) { self._handleRulerEvent(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\thandlers.push({target: div, type: \"mousemove\", handler: function(e) { self._handleRulerEvent(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\thandlers.push({target: div, type: \"mouseover\", handler: function(e) { self._handleRulerEvent(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t\thandlers.push({target: div, type: \"mouseout\", handler: function(e) { self._handleRulerEvent(e ? e : window.event); }}); //$NON-NLS-0$\n\t\t},\n\t\t_getWindow: function() {\n\t\t\treturn getWindow(this._parent.ownerDocument);\n\t\t},\n\t\t_ignoreEvent: function(e) {\n\t\t\tvar node = e.target;\n\t\t\twhile (node && node !== this._clientDiv) {\n\t\t\t\tif (node.ignore) { return true; }\n\t\t\t\tnode = node.parentNode;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t_init: function(options) {\n\t\t\tvar parent = options.parent;\n\t\t\tif (typeof(parent) === \"string\") { //$NON-NLS-0$\n\t\t\t\tparent = (options.document || document).getElementById(parent);\n\t\t\t}\n\t\t\tif (!parent) { throw new Error(\"no parent\"); } //$NON-NLS-0$\n\t\t\toptions.parent = parent;\n\t\t\toptions.model = options.model || new mTextModel.TextModel();\n\t\t\tvar defaultOptions = this._defaultOptions();\n\t\t\tfor (var option in defaultOptions) {\n\t\t\t\tif (defaultOptions.hasOwnProperty(option)) {\n\t\t\t\t\tvar value;\n\t\t\t\t\tif (options[option] !== undefined) {\n\t\t\t\t\t\tvalue = options[option];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = defaultOptions[option].value;\n\t\t\t\t\t}\n\t\t\t\t\tthis[\"_\" + option] = value; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._keyModes = [];\n\t\t\tthis._rulers = [];\n\t\t\tthis._selection = [new Selection(0, 0, false)];\n\t\t\tthis._linksVisible = false;\n\t\t\tthis._redrawCount = 0;\n\t\t\tthis._maxLineWidth = 0;\n\t\t\tthis._maxLineIndex = -1;\n\t\t\tthis._ignoreSelect = true;\n\t\t\tthis._ignoreFocus = false;\n\t\t\tthis._hasFocus = false;\n\t\t\tthis._dragOffset = -1;\n\t\t\tthis._isRangeRects = (!util.isIE || util.isIE >= 9) && typeof parent.ownerDocument.createRange().getBoundingClientRect === \"function\"; //$NON-NLS-0$\n\t\t\tthis._isW3CEvents = parent.addEventListener;\n\n\t\t\t/* Auto scroll */\n\t\t\tthis._autoScrollX = null;\n\t\t\tthis._autoScrollY = null;\n\t\t\tthis._autoScrollTimerID = null;\n\t\t\tthis._AUTO_SCROLL_RATE = 50;\n\t\t\tthis._grabControl = null;\n\t\t\tthis._moseMoveClosure  = null;\n\t\t\tthis._mouseUpClosure = null;\n\t\t\t\n\t\t\t/* Double click */\n\t\t\tthis._lastMouseX = 0;\n\t\t\tthis._lastMouseY = 0;\n\t\t\tthis._lastMouseTime = 0;\n\t\t\tthis._clickCount = 0;\n\t\t\tthis._clickTime = 250;\n\t\t\tthis._clickDist = 5;\n\t\t\tthis._isMouseDown = false;\n\t\t\tthis._doubleClickSelection = null;\n\t\t\t\n\t\t\t/* Scroll */\n\t\t\tthis._hScroll = 0;\n\t\t\tthis._vScroll = 0;\n\n\t\t\t/* IME */\n\t\t\tthis._imeOffset = -1;\n\t\t\t\n\t\t\t/* Create elements */\n\t\t\tthis._createActions();\n\t\t\tthis._createView();\n\t\t},\n\t\t_checkOverlayScroll: function() {\n\t\t\tif (util.isMac && util.isWebkit) {\n\t\t\t\tif (!this._metrics.invalid && this._metrics.scrollWidth === 0) {\n\t\t\t\t\tvar viewDiv = this._viewDiv;\n\t\t\t\t\tvar overlay = this._isOverOverlayScroll();\n\t\t\t\t\tif (overlay.vertical || overlay.horizontal) {\n\t\t\t\t\t\tviewDiv.style.pointerEvents = \"\"; //$NON-NLS-0$\n\t\t\t\t\t} else {\n\t\t\t\t\t\tviewDiv.style.pointerEvents = \"none\"; //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t},\n\t\t_isOverOverlayScroll: function() {\n\t\t\tvar scrollShowing = new Date().getTime() - this._lastScrollTime < 200;\n\t\t\tif (!scrollShowing) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t\tvar rect = this._viewDiv.getBoundingClientRect();\n\t\t\tvar x = this._lastMouseMoveX;\n\t\t\tvar y = this._lastMouseMoveY;\n\t\t\tvar overlayScrollWidth = 15;\n\t\t\treturn {\n\t\t\t\tvertical: rect.top <= y && y < rect.bottom && rect.right - overlayScrollWidth <= x && x < rect.right,\n\t\t\t\thorizontal: rect.bottom - overlayScrollWidth <= y && y < rect.bottom && rect.left <= x && x < rect.right\n\t\t\t};\n\t\t},\n\t\t_startUndo: function() {\n\t\t\tif (this._undoStack) {\n\t\t\t\tvar self = this;\n\t\t\t\tthis._compoundChange = this._undoStack.startCompoundChange({\n\t\t\t\t\tend: function() {\n\t\t\t\t\t\tself._compoundChange = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t_endUndo: function() {\n\t\t\tif (this._undoStack) {\n\t\t\t\tthis._undoStack.endCompoundChange();\n\t\t\t}\n\t\t},\n\t\t_modifyContent: function(e, caretAtEnd, show, callback) {\n\t\t\tif (this._readonly && !e._code) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\te.type = \"Verify\"; //$NON-NLS-0$\n\t\t\tvar oldStart = e.start = e.selection[0].start;\n\t\t\tvar oldEnd = e.end = e.selection[0].end;\n\t\t\tthis.onVerify(e);\n\t\t\tif (oldStart !== e.start) e.selection[0].start = e.start;\n\t\t\tif (oldEnd !== e.end) e.selection[0].end = e.end;\n\n\t\t\tif (e.text === null || e.text === undefined) { return false; }\n\t\t\t\n\t\t\tif (e.selection.length > 1) this.setRedraw(false);\n\t\t\t\n\t\t\tvar undo = this._compoundChange;\n\t\t\tif (undo) {\n\t\t\t\tif (!Selection.compare(this._getSelections(), undo.owner.selection)) {\n\t\t\t\t\tthis._endUndo();\n\t\t\t\t\tif (e.selection.length > 1) this._startUndo();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (e.selection.length > 1) this._startUndo();\n\t\t\t}\n\t\t\t\n\t\t\tvar model = this._model;\n\t\t\ttry {\n\t\t\t\tif (e._ignoreDOMSelection) { this._ignoreDOMSelection = true; }\n\t\t\t\tvar offset = 0, i = 0;\n\t\t\t\te.selection.forEach(function(selection) {\n\t\t\t\t\tselection.start += offset;\n\t\t\t\t\tselection.end += offset;\n\t\t\t\t\tvar text = Array.isArray(e.text) ? e.text[i] : e.text;\n\t\t\t\t\tmodel.setText(text, selection.start, selection.end);\n\t\t\t\t\toffset += (selection.start - selection.end) + text.length;\n\t\t\t\t\tselection.setCaret(caretAtEnd ? selection.start + text.length : selection.start);\n\t\t\t\t\ti++;\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\tif (e._ignoreDOMSelection) { this._ignoreDOMSelection = false; }\n\t\t\t}\n\t\t\tthis._setSelection(e.selection, show, true, callback);\n\t\t\t\n\t\t\tundo = this._compoundChange;\n\t\t\tif (undo) undo.owner.selection = e.selection;\n\t\t\t\n\t\t\tif (e.selection.length > 1) this.setRedraw(true);\n\n\t\t\tthis.onModify({type: \"Modify\"}); //$NON-NLS-0$\n\t\t\treturn true;\n\t\t},\n\t\t_onModelChanged: function(modelChangedEvent) {\n\t\t\tmodelChangedEvent.type = \"ModelChanged\"; //$NON-NLS-0$\n\t\t\tthis.onModelChanged(modelChangedEvent);\n\t\t\tmodelChangedEvent.type = \"Changed\"; //$NON-NLS-0$\n\t\t\tvar start = modelChangedEvent.start;\n\t\t\tvar addedCharCount = modelChangedEvent.addedCharCount;\n\t\t\tvar removedCharCount = modelChangedEvent.removedCharCount;\n\t\t\tvar addedLineCount = modelChangedEvent.addedLineCount;\n\t\t\tvar removedLineCount = modelChangedEvent.removedLineCount;\n\t\t\t\n\t\t\tvar selections = this._getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (selection.end > start) {\n\t\t\t\t\tif (selection.end > start && selection.start < start + removedCharCount) {\n\t\t\t\t\t\t// selection intersects replaced text. set caret behind text change\n\t\t\t\t\t\tselection.setCaret(start + addedCharCount);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// move selection to keep same text selected\n\t\t\t\t\t\tselection.start +=  addedCharCount - removedCharCount;\n\t\t\t\t\t\tselection.end +=  addedCharCount - removedCharCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._setSelection(selections, false, false);\n\t\t\t\n\t\t\tvar model = this._model;\n\t\t\tvar startLine = model.getLineAtOffset(start);\n\t\t\tvar child = this._getLineNext();\n\t\t\twhile (child) {\n\t\t\t\tvar lineIndex = child.lineIndex;\n\t\t\t\tif (startLine <= lineIndex && lineIndex <= startLine + removedLineCount) {\n\t\t\t\t\tif (startLine === lineIndex && !child.modelChangedEvent && !child.lineRemoved) {\n\t\t\t\t\t\tchild.modelChangedEvent = modelChangedEvent;\n\t\t\t\t\t\tchild.lineChanged = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.lineRemoved = true;\n\t\t\t\t\t\tchild.lineChanged = false;\n\t\t\t\t\t\tchild.modelChangedEvent = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lineIndex > startLine + removedLineCount) {\n\t\t\t\t\tchild.lineIndex = lineIndex + addedLineCount - removedLineCount;\n\t\t\t\t\tchild._line.lineIndex = child.lineIndex;\n\t\t\t\t}\n\t\t\t\tchild = this._getLineNext(child);\n\t\t\t}\n\t\t\tif (this._lineHeight) {\n\t\t\t\tvar args = [startLine, removedLineCount].concat(newArray(addedLineCount));\n\t\t\t\tArray.prototype.splice.apply(this._lineHeight, args);\n\t\t\t}\n\t\t\tif (!this._wrapMode) {\n\t\t\t\tif (startLine <= this._maxLineIndex && this._maxLineIndex <= startLine + removedLineCount) {\n\t\t\t\t\tthis._checkMaxLineIndex = this._maxLineIndex;\n\t\t\t\t\tthis._maxLineIndex = -1;\n\t\t\t\t\tthis._maxLineWidth = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._update();\n\t\t},\n\t\t_onModelChanging: function(modelChangingEvent) {\n\t\t\tmodelChangingEvent.type = \"ModelChanging\"; //$NON-NLS-0$\n\t\t\tthis.onModelChanging(modelChangingEvent);\n\t\t\tmodelChangingEvent.type = \"Changing\"; //$NON-NLS-0$\n\t\t},\n\t\t_queueUpdate: function() {\n\t\t\tif (this._updateTimer || this._ignoreQueueUpdate) { return; }\n\t\t\tvar self = this;\n\t\t\tvar window = this._getWindow();\n\t\t\tthis._updateTimer = window.setTimeout(function() { \n\t\t\t\tself._updateTimer = null;\n\t\t\t\tself._update();\n\t\t\t}, 0);\n\t\t},\n\t\t_rangesToSelections: function(ranges) {\n\t\t\tvar selections = [];\n\t\t\tvar charCount = this._model.getCharCount();\n\t\t\tranges.forEach(function(range) {\n\t\t\t\tvar selection;\n\t\t\t\tif (range instanceof Selection) {\n\t\t\t\t\tselection = range.clone();\n\t\t\t\t} else {\n\t\t\t\t\tvar start = range.start;\n\t\t\t\t\tvar end = range.end;\n\t\t\t\t\tvar caret = start > end;\n\t\t\t\t\tif (caret) {\n\t\t\t\t\t\tvar tmp = start;\n\t\t\t\t\t\tstart = end;\n\t\t\t\t\t\tend = tmp;\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(0, Math.min (start, charCount));\n\t\t\t\t\tend = Math.max(0, Math.min (end, charCount));\n\t\t\t\t\tselection = new Selection(start, end, caret);\n\t\t\t\t}\n\t\t\t\tselections.push(selection);\n\t\t\t});\n\t\t\treturn selections;\n\t\t},\n\t\t_resetLineHeight: function(startLine, endLine) {\n\t\t\tif (this._wrapMode || this._variableLineHeight) {\n\t\t\t\tif (startLine !== undefined && endLine !== undefined) {\n\t\t\t\t\tfor (var i = startLine; i < endLine; i++) {\n\t\t\t\t\t\tthis._lineHeight[i] = undefined;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._lineHeight = newArray(this._model.getLineCount());\n\t\t\t\t}\n\t\t\t\tthis._calculateLineHeightTimer();\n\t\t\t} else {\n\t\t\t\tthis._lineHeight = null;\n\t\t\t}\n\t\t},\n\t\t_resetLineWidth: function() {\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tif (clientDiv) {\n\t\t\t\tvar child = clientDiv.firstChild;\n\t\t\t\twhile (child) {\n\t\t\t\t\tchild.lineWidth = undefined;\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_reset: function() {\n\t\t\tthis._maxLineIndex = -1;\n\t\t\tthis._maxLineWidth = 0;\n\t\t\tthis._topChild = null;\n\t\t\tthis._bottomChild = null;\n\t\t\tthis._topIndexY = 0;\n\t\t\tthis._variableLineHeight = false;\n\t\t\tthis._resetLineHeight();\n\t\t\tthis._setSelection(new Selection(0, 0, false), false, false);\n\t\t\tif (this._viewDiv) {\n\t\t\t\tthis._viewDiv.scrollLeft = 0;\n\t\t\t\tthis._viewDiv.scrollTop = 0;\n\t\t\t}\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tif (clientDiv) {\n\t\t\t\tvar child = clientDiv.firstChild;\n\t\t\t\twhile (child) {\n\t\t\t\t\tchild.lineRemoved = true;\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t* Bug in Firefox.  For some reason, the caret does not show after the\n\t\t\t\t* view is refreshed.  The fix is to toggle the contentEditable state and\n\t\t\t\t* force the clientDiv to loose and receive focus if it is focused.\n\t\t\t\t*/\n\t\t\t\tif (util.isFirefox < 13) {\n\t\t\t\t\tthis._fixCaret ();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_scrollViewAnimated: function (pixelX, pixelY, callback) {\n\t\t\tvar window = this._getWindow();\n\t\t\tif (callback && this._scrollAnimation) {\n\t\t\t\tvar self = this;\n\t\t\t\tthis._animation = new Animation({\n\t\t\t\t\twindow: window,\n\t\t\t\t\tduration: this._scrollAnimation,\n\t\t\t\t\tcurve: [pixelY, 0],\n\t\t\t\t\tonAnimate: function(x) {\n\t\t\t\t\t\tvar deltaY = pixelY - Math.floor(x);\n\t\t\t\t\t\tself._scrollView (0, deltaY);\n\t\t\t\t\t\tpixelY -= deltaY;\n\t\t\t\t\t},\n\t\t\t\t\tonEnd: function() {\n\t\t\t\t\t\tself._animation = null;\n\t\t\t\t\t\tself._scrollView (pixelX, pixelY);\n\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\twindow.setTimeout(callback, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis._animation.play();\n\t\t\t} else {\n\t\t\t\tthis._scrollView (pixelX, pixelY);\n\t\t\t\tif (callback) {\n\t\t\t\t\twindow.setTimeout(callback, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}, \n\t\t_scrollView: function (pixelX, pixelY) {\n\t\t\t/*\n\t\t\t* Always set _ensureCaretVisible to false so that the view does not scroll\n\t\t\t* to show the caret when scrollView is not called from showCaret().\n\t\t\t*/\n\t\t\tthis._ensureCaretVisible = false;\n\t\t\t\n\t\t\t/*\n\t\t\t* Scrolling is done only by setting the scrollLeft and scrollTop fields in the\n\t\t\t* view div. This causes an update from the scroll event. In some browsers \n\t\t\t* this event is asynchronous and forcing update page to run synchronously\n\t\t\t* leads to redraw problems. \n\t\t\t* On Chrome 11, the view redrawing at times when holding PageDown/PageUp key.\n\t\t\t* On Firefox 4 for Linux, the view redraws the first page when holding \n\t\t\t* PageDown/PageUp key, but it will not redraw again until the key is released.\n\t\t\t*/\n\t\t\tvar viewDiv = this._viewDiv;\n\t\t\tif (pixelX) { viewDiv.scrollLeft += pixelX; }\n\t\t\tif (pixelY) { viewDiv.scrollTop += pixelY; }\n\t\t},\n\t\t_setClipboardText: function (text, event) {\n\t\t\tvar clipboardText;\n\t\t\t// IE\n\t\t\tvar window = this._getWindow();\n\t\t\tvar clipboardData = window.clipboardData;\n\t\t\t// WebKit and Firefox > 21\n\t\t\tif (!clipboardData && event) {\n\t\t\t\tclipboardData = event.clipboardData;\n\t\t\t}\n\t\t\tif (clipboardData) {\n\t\t\t\tclipboardText = [];\n\t\t\t\tconvertDelimiter(text, function(t) {clipboardText.push(t);}, function() {clipboardText.push(util.platformDelimiter);});\n\t\t\t\t/*\n\t\t\t\t* Note that setData() succeeds on Firefox 22 and greater, but the return value is not a boolean like IE and Chrome.\n\t\t\t\t*/\n\t\t\t\tvar success = clipboardData.setData(util.isIE ? \"Text\" : \"text/plain\", clipboardText.join(\"\")); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tif (success || util.isFirefox > 21) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar document = this._parent.ownerDocument;\n\t\t\tvar child = util.createElement(document, \"pre\"); //$NON-NLS-0$\n\t\t\tchild.style.position = \"fixed\"; //$NON-NLS-0$\n\t\t\tchild.style.left = \"-1000px\"; //$NON-NLS-0$\n\t\t\tconvertDelimiter(text, \n\t\t\t\tfunction(t) {\n\t\t\t\t\tchild.appendChild(document.createTextNode(t));\n\t\t\t\t}, \n\t\t\t\tfunction() {\n\t\t\t\t\tchild.appendChild(util.createElement(document, \"br\")); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t);\n\t\t\tchild.appendChild(document.createTextNode(\" \")); //$NON-NLS-0$\n\t\t\tthis._clientDiv.appendChild(child);\n\t\t\tvar range = document.createRange();\n\t\t\trange.setStart(child.firstChild, 0);\n\t\t\trange.setEndBefore(child.lastChild);\n\t\t\tvar sel = window.getSelection();\n\t\t\tif (sel.rangeCount > 0) { sel.removeAllRanges(); }\n\t\t\tsel.addRange(range);\n\t\t\tvar self = this;\n\t\t\t/** @ignore */\n\t\t\tvar cleanup = function() {\n\t\t\t\tif (child && child.parentNode === self._clientDiv) {\n\t\t\t\t\tself._clientDiv.removeChild(child);\n\t\t\t\t}\n\t\t\t\tself._updateDOMSelection();\n\t\t\t};\n\t\t\tvar result = false;\n\t\t\t/* \n\t\t\t* Try execCommand first, it works on firefox with clipboard permission,\n\t\t\t* chrome 5, safari 4.\n\t\t\t*/\n\t\t\tthis._ignoreCopy = true;\n\t\t\ttry {\n\t\t\t\tresult = document.execCommand(\"copy\", false, null); //$NON-NLS-0$\n\t\t\t} catch (e) {}\n\t\t\tthis._ignoreCopy = false;\n\t\t\tif (!result) {\n\t\t\t\tif (event) {\n\t\t\t\t\twindow.setTimeout(cleanup, 0);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* no event and no permission, copy can not be done */\n\t\t\tcleanup();\n\t\t\treturn true;\n\t\t},\n\t\t_setGrab: function (target) {\n\t\t\tif (target === this._grabControl) { return; }\n\t\t\tif (target) {\n\t\t\t\tif (target.setCapture) { target.setCapture(); }\n\t\t\t\tthis._grabControl = target;\n\t\t\t} else {\n\t\t\t\tif (this._grabControl.releaseCapture) { this._grabControl.releaseCapture(); }\n\t\t\t\tthis._grabControl = null;\n\t\t\t}\n\t\t},\n\t\t_setLinksVisible: function(visible) {\n\t\t\tif (this._linksVisible === visible) { return; }\n\t\t\tthis._linksVisible = visible;\n\t\t\t/*\n\t\t\t* Feature in IE.  The client div looses focus and does not regain it back\n\t\t\t* when the content editable flag is reset. The fix is to remember that it\n\t\t\t* had focus when the flag is cleared and give focus back to the div when\n\t\t\t* the flag is set.\n\t\t\t*/\n\t\t\tif (util.isIE && visible) {\n\t\t\t\tthis._hadFocus = this._hasFocus;\n\t\t\t}\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tclientDiv.contentEditable = !visible;\n\t\t\tif (this._hadFocus && !visible) {\n\t\t\t\tclientDiv.focus();\n\t\t\t}\n\t\t\tif (this._overlayDiv) {\n\t\t\t\tthis._overlayDiv.style.zIndex = visible ? \"-1\" : \"1\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}\n\t\t\tvar line = this._getLineNext();\n\t\t\twhile (line) {\n\t\t\t\tline._line.updateLinks();\n\t\t\t\tline = this._getLineNext(line);\n\t\t\t}\n\t\t\tthis._updateDOMSelection();\n\t\t},\n\t\t_setSelection: function (selection, scroll, update, callback, pageScroll, add, preserveCursorX) {\n\t\t\tif (selection) {\n\t\t\t\tif (update === undefined) { update = true; }\n\t\t\t\tvar oldSelection = this._getSelections(), newSelection;\n\t\t\t\tif (Array.isArray(selection)) {\n\t\t\t\t\tnewSelection = selection;\n\t\t\t\t} else if (add) {\n\t\t\t\t\tnewSelection = oldSelection.concat([selection]);\n\t\t\t\t} else {\n\t\t\t\t\tnewSelection = [selection];\n\t\t\t\t}\n\t\t\t\tthis._selection = Selection.merge(newSelection);\n\t\t\t\t\n\t\t\t\tif (!preserveCursorX) {\n\t\t\t\t\tnewSelection.forEach(function(sel) {\n\t\t\t\t\t\tsel._columnX = -1;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t/* \n\t\t\t\t* Always showCaret(), even when the selection is not changing, to ensure the\n\t\t\t\t* caret is visible. Note that some views do not scroll to show the caret during\n\t\t\t\t* keyboard navigation when the selection does not chanage. For example, line down\n\t\t\t\t* when the caret is already at the last line.\n\t\t\t\t*/\n\t\t\t\tif (scroll !== false) { /*update = !*/this._showCaret(false, callback, scroll, pageScroll); }\n\t\t\t\t\n\t\t\t\t/* \n\t\t\t\t* Sometimes the browser changes the selection \n\t\t\t\t* as result of method calls or \"leaked\" events. \n\t\t\t\t* The fix is to set the visual selection even\n\t\t\t\t* when the logical selection is not changed.\n\t\t\t\t*/\n\t\t\t\tif (update) { this._updateDOMSelection(); }\n\t\t\t\t\n\t\t\t\tif (!Selection.compare(oldSelection, newSelection)) {\n\t\t\t\t\tvar e = {\n\t\t\t\t\t\ttype: \"Selection\", //$NON-NLS-0$\n\t\t\t\t\t\toldValue: Selection.convert(oldSelection),\n\t\t\t\t\t\tnewValue: Selection.convert(newSelection)\n\t\t\t\t\t};\n\t\t\t\t\tthis.onSelection(e);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_setSelectionTo: function (x, y, down, extent, add, drag) {\n\t\t\tvar model = this._model;\n\t\t\tvar selections = this._getSelections();\n\t\t\tvar pt = this.convert({x: x, y: y}, \"page\", \"document\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar lineIndex = this._getLineIndex(pt.y);\n\t\t\tvar line = this._getLine(lineIndex);\n\t\t\tvar offset = line.getOffset(pt.x, pt.y - this._getLinePixel(lineIndex));\n\t\t\tif (drag && !extent) {\n\t\t\t\tif (Selection.contains(selections, offset)) {\n\t\t\t\t\tthis._dragOffset = offset;\n\t\t\t\t\tline.destroy();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._blockSelection) {\n\t\t\t\tselections = this._getBlockSelections(selections, lineIndex, pt);\n\t\t\t} else {\n\t\t\t\tvar selection;\n\t\t\t\tif (!down) {\n\t\t\t\t\tselection = Selection.editing(selections);\n\t\t\t\t} else if (extent) {\n\t\t\t\t\tselection = selections[selections.length - 1];\n\t\t\t\t\tselection._editing = true;\n\t\t\t\t} else {\n\t\t\t\t\tselection = new Selection(0, 0);\n\t\t\t\t\tselection._editing = true;\n\t\t\t\t\tif (add) {\n\t\t\t\t\t\tselections.push(selection);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tselections = [selection];\n\t\t\t\t\t}\n\t\t\t\t\tselection._docX = pt.x;\n\t\t\t\t}\n\t\t\t\tif (this._clickCount === 1) {\n\t\t\t\t\tselection.extend(offset);\n\t\t\t\t\tif (!extent) { selection.collapse(); }\n\t\t\t\t} else {\n\t\t\t\t\tvar word = (this._clickCount & 1) === 0;\n\t\t\t\t\tvar start, end;\n\t\t\t\t\tif (word) {\n\t\t\t\t\t\tif (this._doubleClickSelection) {\n\t\t\t\t\t\t\tif (offset >= this._doubleClickSelection.start) {\n\t\t\t\t\t\t\t\tstart = this._doubleClickSelection.start;\n\t\t\t\t\t\t\t\tend = line.getNextOffset(offset, {unit:\"wordend\", count:1}); //$NON-NLS-0$\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstart = line.getNextOffset(offset, {unit:\"word\", count:-1}); //$NON-NLS-0$\n\t\t\t\t\t\t\t\tend = this._doubleClickSelection.end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstart = line.getNextOffset(offset, {unit:\"word\", count:-1}); //$NON-NLS-0$\n\t\t\t\t\t\t\tend = line.getNextOffset(start, {unit:\"wordend\", count:1}); //$NON-NLS-0$\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this._doubleClickSelection) {\n\t\t\t\t\t\t\tvar doubleClickLine = model.getLineAtOffset(this._doubleClickSelection.start);\n\t\t\t\t\t\t\tif (lineIndex >= doubleClickLine) {\n\t\t\t\t\t\t\t\tstart = model.getLineStart(doubleClickLine);\n\t\t\t\t\t\t\t\tend = model.getLineEnd(lineIndex);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstart = model.getLineStart(lineIndex);\n\t\t\t\t\t\t\t\tend = model.getLineEnd(doubleClickLine);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstart = model.getLineStart(lineIndex);\n\t\t\t\t\t\t\tend = model.getLineEnd(lineIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tselection.setCaret(start);\n\t\t\t\t\tselection.extend(end);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._setSelection(selections, true, true, null, false);\n\t\t\tline.destroy();\n\t\t\treturn true;\n\t\t},\n\t\t_setFullSelection: function(fullSelection, init) {\n\t\t\tthis._fullSelection = fullSelection;\n\t\t\tif (util.isWebkit) {\n\t\t\t\tthis._fullSelection = fullSelection = true;\n\t\t\t}\n\t\t\tif (!this._domSelection) {\n\t\t\t\tthis._domSelection = [];\n\t\t\t\tthis._cursorVisible = true;\n\t\t\t}\n\t\t\tif (!init) {\n\t\t\t\tthis._updateDOMSelection();\n\t\t\t}\n\t\t},\n\t\t_setBlockCursor: function (visible) {\n\t\t\tthis._blockCursorVisible = visible;\n\t\t\tthis._updateBlockCursorVisible();\n\t\t},\n\t\t_setOverwriteMode: function (overwrite) {\n\t\t\tthis._overwriteMode = overwrite;\n\t\t\tthis._updateBlockCursorVisible();\n\t\t},\n\t\t_updateBlockCursorVisible: function () {\n\t\t\tif (this._blockCursorVisible || this._overwriteMode) {\n\t\t\t\tif (!this._cursorDiv) {\n\t\t\t\t\tvar viewDiv = this._viewDiv;\n\t\t\t\t\tvar cursorDiv = util.createElement(viewDiv.ownerDocument, \"div\"); //$NON-NLS-0$\n\t\t\t\t\tcursorDiv.className = \"textviewBlockCursor\"; //$NON-NLS-0$\n\t\t\t\t\tthis._cursorDiv = cursorDiv;\n\t\t\t\t\tcursorDiv.tabIndex = -1;\n\t\t\t\t\tcursorDiv.style.zIndex = \"2\"; //$NON-NLS-0$\n\t\t\t\t\tcursorDiv.style.color = \"transparent\"; //$NON-NLS-0$\n\t\t\t\t\tcursorDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\t\t\tcursorDiv.style.pointerEvents = \"none\"; //$NON-NLS-0$\n\t\t\t\t\tcursorDiv.innerHTML = \"&nbsp;\"; //$NON-NLS-0$\n\t\t\t\t\tviewDiv.appendChild(cursorDiv);\n\t\t\t\t\tthis._updateDOMSelection();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._cursorDiv) {\n\t\t\t\t\tthis._cursorDiv.parentNode.removeChild(this._cursorDiv);\n\t\t\t\t\tthis._cursorDiv = null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_setMarginOffset: function(marginOffset, init) {\n\t\t\tthis._marginOffset = marginOffset;\n\t\t\tthis._marginDiv.style.display = marginOffset ? \"block\" : \"none\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tif (!init) {\n\t\t\t\tthis._metrics = this._calculateMetrics();\n\t\t\t\tthis._queueUpdate();\n\t\t\t}\n\t\t},\n\t\t_setWrapOffset: function(wrapOffset, init) {\n\t\t\tthis._wrapOffset = wrapOffset;\n\t\t\tif (!init) {\n\t\t\t\tthis._metrics = this._calculateMetrics();\n\t\t\t\tthis._queueUpdate();\n\t\t\t}\n\t\t},\n\t\t_setReadOnly: function (readOnly) {\n\t\t\tthis._readonly = readOnly;\n\t\t\tthis._clientDiv.setAttribute(\"aria-readonly\", readOnly ? \"true\" : \"false\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t},\n\t\t_setSingleMode: function (singleMode, init) {\n\t\t\tthis._singleMode = singleMode;\n\t\t\tthis._updateOverflow();\n\t\t\tthis._updateStyle(init);\n\t\t},\n\t\t_setNoScroll: function (noScroll, init) {\n\t\t\tthis._noScroll = noScroll;\n\t\t\tthis._updateOverflow();\n\t\t\tthis._updateStyle(init);\n\t\t},\n\t\t_setTabSize: function (tabSize, init) {\n\t\t\tthis._tabSize = tabSize;\n\t\t\tthis._customTabSize = undefined;\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tif (util.isOpera) {\n\t\t\t\tif (clientDiv) { clientDiv.style.OTabSize = this._tabSize+\"\"; }\n\t\t\t} else if (util.isWebkit >= 537.1) {\n\t\t\t\tif (clientDiv) { clientDiv.style.tabSize = this._tabSize+\"\"; }\n\t\t\t} else if (util.isFirefox >= 4) {\n\t\t\t\tif (clientDiv) {  clientDiv.style.MozTabSize = this._tabSize+\"\"; }\n\t\t\t} else if (this._tabSize !== 8) {\n\t\t\t\tthis._customTabSize = this._tabSize;\n\t\t\t}\n\t\t\tif (!init) {\n\t\t\t\tthis.redrawLines();\n\t\t\t\tthis._resetLineWidth();\n\t\t\t}\n\t\t},\n\t\t_setTheme: function(theme) {\n\t\t\tif (this._theme) {\n\t\t\t\tthis._theme.removeEventListener(\"ThemeChanged\", this._themeListener.onChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._theme = theme;\n\t\t\tif (this._theme) {\n\t\t\t\tthis._theme.addEventListener(\"ThemeChanged\", this._themeListener.onChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._setThemeClass(this._themeClass);\n\t\t},\n\t\t_setThemeClass: function (themeClass, init) {\n\t\t\tthis._themeClass = themeClass;\n\t\t\tvar viewContainerClass = \"textview\"; //$NON-NLS-0$\n\t\t\tvar globalThemeClass = this._theme.getThemeClass();\n\t\t\tif (globalThemeClass) { viewContainerClass += \" \" + globalThemeClass; } //$NON-NLS-0$\n\t\t\tif (this._themeClass && globalThemeClass !== this._themeClass) { viewContainerClass += \" \" + this._themeClass; } //$NON-NLS-0$\n\t\t\tthis._rootDiv.className = viewContainerClass;\n\t\t\tthis._updateStyle(init);\n\t\t},\n\t\t_setUndoStack: function (undoStack) {\n\t\t\tthis._undoStack = undoStack;\n\t\t},\n\t\t_setWrapMode: function (wrapMode, init) {\n\t\t\tthis._wrapMode = wrapMode && this._wrappable;\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tif (this._wrapMode) {\n\t\t\t\tclientDiv.style.whiteSpace = \"pre-wrap\"; //$NON-NLS-0$\n\t\t\t\tclientDiv.style.wordWrap = \"break-word\"; //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tclientDiv.style.whiteSpace = \"pre\"; //$NON-NLS-0$\n\t\t\t\tclientDiv.style.wordWrap = \"normal\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._updateOverflow();\n\t\t\tif (!init) {\n\t\t\t\tthis.redraw();\n\t\t\t\tthis._resetLineWidth();\n\t\t\t}\n\t\t\tthis._resetLineHeight();\n\t\t},\n\t\t_showCaret: function (allSelection, callback, showOptions, pageScroll) {\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tif (this._redrawCount > 0) { return; }\n\t\t\tif (this._ignoreDOMSelection) { return; }\n\t\t\tif (this._imeOffset !== -1) return;\n\t\t\tvar model = this._model;\n\t\t\tvar selections = this._getSelections();\n\t\t\tvar selection = Selection.editing(selections, this._autoScrollDir === \"down\"); //$NON-NLS-0$\n\t\t\tvar scroll = this._getScroll();\n\t\t\tvar caret = selection.getCaret();\n\t\t\tvar start = selection.start;\n\t\t\tvar end = selection.end;\n\t\t\tvar startLine = model.getLineAtOffset(start);\n\t\t\tvar endLine = model.getLineAtOffset(end);\n\t\t\tvar endInclusive = Math.max(Math.max(start, model.getLineStart(endLine)), end - 1);\n\t\t\tvar clientWidth = this._getClientWidth();\n\t\t\tvar clientHeight = this._getClientHeight();\n\t\t\tvar minScroll = clientWidth / 4;\n\t\t\tvar bounds = this._getBoundsAtOffset(caret === start ? start : endInclusive);\n\t\t\tvar left = bounds.left;\n\t\t\tvar right = bounds.right;\n\t\t\tvar top = bounds.top;\n\t\t\tvar bottom = bounds.bottom;\n\t\t\tvar selectionHeight = 0;\n\t\t\tvar hasShowOptions = typeof showOptions === \"object\"; //$NON-NLS-0$\n\t\t\tif ((allSelection || hasShowOptions) && !selection.isEmpty()) {\n\t\t\t\tbounds = this._getBoundsAtOffset(caret === end ? start : endInclusive);\n\t\t\t\tselectionHeight = (bounds.bottom > bottom ? bounds.bottom : bottom) - (bounds.top < top ? bounds.top : top);\n\t\t\t\tif (allSelection) {\n\t\t\t\t\tif (bounds.top === top) {\n\t\t\t\t\t\tif (caret === start) {\n\t\t\t\t\t\t\tright = left + Math.min(bounds.right - left, clientWidth);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft = right - Math.min(right - bounds.left, clientWidth);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (caret === start) {\n\t\t\t\t\t\t\tbottom = top + Math.min(bounds.bottom - top, clientHeight);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttop = bottom - Math.min(bottom - bounds.top, clientHeight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar pixelX = 0;\n\t\t\tif (left < scroll.x) {\n\t\t\t\tpixelX = Math.min(left - scroll.x, -minScroll);\n\t\t\t}\n\t\t\tif (right > scroll.x + clientWidth) {\n\t\t\t\tpixelX = Math.max(right - scroll.x - clientWidth, minScroll);\n\t\t\t}\n\t\t\tvar pixelY = 0;\n\t\t\tif (top < scroll.y) {\n\t\t\t\tpixelY = top - scroll.y;\n\t\t\t} else if (bottom > scroll.y + clientHeight) {\n\t\t\t\tpixelY = bottom - scroll.y - clientHeight;\n\t\t\t}\n\t\t\tif (pageScroll) {\n\t\t\t\tif (pageScroll > 0) {\n\t\t\t\t\tif (pixelY > 0) {\n\t\t\t\t\t\tpixelY = Math.max(pixelY, pageScroll);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (pixelY < 0) {\n\t\t\t\t\t\tpixelY = Math.min(pixelY, pageScroll);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar alwaysScroll = hasShowOptions && showOptions.scrollPolicy === \"always\"; //$NON-NLS-0$\n\t\t\tif (pixelX !== 0 || pixelY !== 0 || alwaysScroll) {\n\t\t\t\tif (hasShowOptions) {\n\t\t\t\t\tvar flag = pixelY > 0;\n\t\t\t\t\tif (pixelY === 0) {\n\t\t\t\t\t\tpixelY = top - scroll.y;\n\t\t\t\t\t}\n\t\t\t\t\tvar viewAnchor = showOptions.viewAnchor;\n\t\t\t\t\tvar selectionAnchor = showOptions.selectionAnchor;\n\t\t\t\t\tvar viewAnchorOffset = Math.min(Math.max(0, showOptions.viewAnchorOffset || 0));\n//\t\t\t\t\tvar selectionAnchorOffset = Math.min(Math.max(0, showOptions.selectionAnchorOffset || 0));\n\t\t\t\t\tif (viewAnchor === \"top\") { //$NON-NLS-0$\n\t\t\t\t\t\tpixelY += Math.floor(flag ? (1 - viewAnchorOffset) * clientHeight : -viewAnchorOffset * clientHeight);\n\t\t\t\t\t} else if (viewAnchor === \"bottom\") { //$NON-NLS-0$\n\t\t\t\t\t\tpixelY += Math.floor(flag ? viewAnchorOffset * clientHeight : -(1 - viewAnchorOffset) * clientHeight);\n\t\t\t\t\t} else if (viewAnchor === \"center\") { //$NON-NLS-0$\n\t\t\t\t\t\tpixelY += Math.floor(flag ? clientHeight / 2 + viewAnchorOffset * clientHeight : clientHeight / 2  - (1 - viewAnchorOffset) * clientHeight);\n\t\t\t\t\t} else { // caret is the default\n\t\t\t\t\t\tpixelY += Math.floor(flag ? viewAnchorOffset * clientHeight : -viewAnchorOffset * clientHeight);\n\t\t\t\t\t}\n\t\t\t\t\tif (startLine !== endLine) {\n\t\t\t\t\t\tif (selectionAnchor === \"top\" && caret !== start) { //$NON-NLS-0$\n\t\t\t\t\t\t\tpixelY += Math.floor(-selectionHeight);\n\t\t\t\t\t\t} else if (selectionAnchor === \"bottom\" && caret !== end) { //$NON-NLS-0$\n\t\t\t\t\t\t\tpixelY += Math.floor(selectionHeight);\n\t\t\t\t\t\t} else if (selectionAnchor === \"center\") { //$NON-NLS-0$\n\t\t\t\t\t\t\tpixelY += Math.floor(selectionHeight / 2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// caret is the default\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (pixelY !== 0 && typeof showOptions === \"number\") { //$NON-NLS-0$\n\t\t\t\t\tif (showOptions < 0) { showOptions = 0; }\n\t\t\t\t\tif (showOptions > 1) { showOptions = 1; }\n\t\t\t\t\tpixelY += Math.floor(pixelY > 0 ? showOptions * clientHeight : -showOptions * clientHeight);\n\t\t\t\t}\n\t\t\t\tthis._scrollViewAnimated(pixelX, pixelY, callback);\n\t\t\t\t/*\n\t\t\t\t* When the view scrolls it is possible that one of the scrollbars can show over the caret.\n\t\t\t\t* Depending on the browser scrolling can be synchronous (Safari), in which case the change \n\t\t\t\t* can be detected before showCaret() returns. When scrolling is asynchronous (most browsers), \n\t\t\t\t* the detection is done during the next update page.\n\t\t\t\t*/\n\t\t\t\tif (clientHeight !== this._getClientHeight() || clientWidth !== this._getClientWidth()) {\n\t\t\t\t\tthis._showCaret();\n\t\t\t\t} else {\n\t\t\t\t\tthis._ensureCaretVisible = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t_startIME: function () {\n\t\t\tif (this._imeOffset !== -1) { return; }\n\t\t\tvar selected = false;\n\t\t\tvar selections = this._getSelections();\n\t\t\tfor (var i=0; i<selections.length && !selected; i++) {\n\t\t\t\tselected = !selections[i].isEmpty();\n\t\t\t}\n\t\t\tif (selected) {\n\t\t\t\tthis._modifyContent({text: \"\", selection: selections}, true);\n\t\t\t}\n\t\t\tthis._imeOffset = selections[0].start;\n\t\t},\n\t\t_unhookEvents: function() {\n\t\t\tthis._model.removeEventListener(\"preChanging\", this._modelListener.onChanging); //$NON-NLS-0$\n\t\t\tthis._model.removeEventListener(\"postChanged\", this._modelListener.onChanged); //$NON-NLS-0$\n\t\t\tthis._theme.removeEventListener(\"ThemeChanged\", this._themeListener.onChanged); //$NON-NLS-0$\n\t\t\tthis._modelListener = null;\n\t\t\tfor (var i=0; i<this._handlers.length; i++) {\n\t\t\t\tvar h = this._handlers[i];\n\t\t\t\tremoveHandler(h.target, h.type, h.handler);\n\t\t\t}\n\t\t\tthis._handlers = null;\n\t\t\tif (this._mutationObserver) {\n\t\t\t\tthis._mutationObserver.disconnect();\n\t\t\t}\n\t\t},\n\t\t_updateDOMSelection: function () {\n\t\t\tif (this._redrawCount > 0) { return; }\n\t\t\tif (this._ignoreDOMSelection) { return; }\n\t\t\tif (this._imeOffset !== -1) return;\n\t\t\tif (!this._clientDiv) { return; }\n\t\t\tvar selection = this._getSelections();\n\t\t\tvar domSelection = this._domSelection, i;\n\t\t\tif (domSelection.length < selection.length) {\n\t\t\t\tfor (i=domSelection.length; i<selection.length; i++) {\n\t\t\t\t\tdomSelection.push(new DOMSelection(this));\n\t\t\t\t}\n\t\t\t} else if (domSelection.length > selection.length) {\n\t\t\t\tdomSelection.splice(selection.length).forEach(function(s) {\n\t\t\t\t\ts.destroy();\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (i=0; i<domSelection.length; i++) {\n\t\t\t\tdomSelection[i].setPrimary(i === 0);\n\t\t\t\tdomSelection[i].setSelection(selection[i]);\n\t\t\t}\n\t\t\tvar window = this._getWindow();\n\t\t\tvar self = this;\n\t\t\tif (domSelection.length > 1) {\n\t\t\t\tif (!this._cursorTimer) {\n\t\t\t\t\tthis._cursorTimer = window.setInterval(function() {\n\t\t\t\t\t\tself._cursorVisible = !self._cursorVisible;\n\t\t\t\t\t\tself._domSelection.forEach(function(domSelection) { domSelection.update(); });\n\t\t\t\t\t}, 500);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._cursorTimer) {\n\t\t\t\t\twindow.clearInterval(this._cursorTimer);\n\t\t\t\t\tthis._cursorTimer = null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_update: function(hScrollOnly) {\n\t\t\tif (this._redrawCount > 0) { return; }\n\t\t\tif (this._updateTimer) {\n\t\t\t\tvar window = this._getWindow();\n\t\t\t\twindow.clearTimeout(this._updateTimer);\n\t\t\t\tthis._updateTimer = null;\n\t\t\t\thScrollOnly = false;\n\t\t\t}\n\t\t\tvar clientDiv = this._clientDiv;\n\t\t\tvar viewDiv = this._viewDiv;\n\t\t\tif (!clientDiv) { return; }\n\t\t\tif (this._metrics.invalid) {\n\t\t\t\tthis._ignoreQueueUpdate = true;\n\t\t\t\tthis._updateStyle();\n\t\t\t\tthis._ignoreQueueUpdate = false;\n\t\t\t}\n\t\t\tvar model = this._model;\n\t\t\tvar scroll = this._getScroll(false);\n\t\t\tvar viewPad = this._getViewPadding();\n\t\t\tvar lineCount = model.getLineCount();\n\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\tvar needUpdate = false;\n\t\t\tvar hScroll = false, vScroll = false;\n\t\t\tvar scrollbarWidth = this._metrics.scrollWidth;\n\t\t\t\n\t\t\tif (this._wrapMode) {\n\t\t\t\tclientDiv.style.width = (this._metrics.wrapWidth || this._getClientWidth()) + \"px\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t* topIndex - top line index of the view (maybe be particialy visible)\n\t\t\t* lineStart - top line minus one line (if any)\n\t\t\t* topIndexY - portion of the top line that is NOT visible.\n\t\t\t* top - topIndexY plus height of the line before top line (if any)\n\t\t\t*/\n\t\t\tvar topIndex, lineStart, top, topIndexY,\n\t\t\t\tleftWidth, leftRect,\n\t\t\t\tclientWidth, clientHeight, scrollWidth, scrollHeight,\n\t\t\t\ttotalHeight = 0, totalLineIndex = 0, tempLineHeight;\n\t\t\tif (this._lineHeight) {\n\t\t\t\twhile (totalLineIndex < lineCount) {\n\t\t\t\t\ttempLineHeight = this._getLineHeight(totalLineIndex);\n\t\t\t\t\tif (totalHeight + tempLineHeight > scroll.y) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttotalHeight += tempLineHeight;\n\t\t\t\t\ttotalLineIndex++;\n\t\t\t\t}\n\t\t\t\ttopIndex = totalLineIndex;\n\t\t\t\tlineStart = Math.max(0, topIndex - 1);\n\t\t\t\ttopIndexY = top = scroll.y - totalHeight;\n\t\t\t\tif (topIndex > 0) {\n\t\t\t\t\ttop += this._getLineHeight(topIndex - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar firstLine = Math.max(0, scroll.y) / lineHeight;\n\t\t\t\ttopIndex = Math.floor(firstLine);\n\t\t\t\tlineStart = Math.max(0, topIndex - 1);\n\t\t\t\ttop = Math.round((firstLine - lineStart) * lineHeight);\n\t\t\t\ttopIndexY = Math.round((firstLine - topIndex) * lineHeight);\n\t\t\t\tscrollHeight = lineCount * lineHeight;\n\t\t\t}\n\t\t\tthis._topIndexY = topIndexY;\n\t\t\tvar rootDiv = this._rootDiv;\n\t\t\tvar rootWidth = rootDiv.clientWidth;\n\t\t\tvar rootHeight = rootDiv.clientHeight;\n\t\t\tif (hScrollOnly) {\n\t\t\t\tleftWidth = 0;\n\t\t\t\tif (this._leftDiv) {\n\t\t\t\t\tleftRect = this._leftDiv.getBoundingClientRect();\n\t\t\t\t\tleftWidth = leftRect.right - leftRect.left;\n\t\t\t\t}\n\t\t\t\tclientWidth = this._getClientWidth();\n\t\t\t\tclientHeight = this._getClientHeight();\n\t\t\t\tscrollWidth = clientWidth;\n\t\t\t\tif (this._wrapMode) {\n\t\t\t\t\tif (this._metrics.wrapWidth) {\n\t\t\t\t\t\tscrollWidth = this._metrics.wrapWidth;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tscrollWidth = Math.max(this._maxLineWidth, scrollWidth);\n\t\t\t\t}\n\t\t\t\twhile (totalLineIndex < lineCount) {\n\t\t\t\t\ttempLineHeight = this._getLineHeight(totalLineIndex, false);\n\t\t\t\t\ttotalHeight += tempLineHeight;\n\t\t\t\t\ttotalLineIndex++;\n\t\t\t\t}\n\t\t\t\tscrollHeight = totalHeight;\n\t\t\t} else {\n\t\t\t\tclientHeight = this._getClientHeight();\n\n\t\t\t\tvar linesPerPage = Math.floor((clientHeight + topIndexY) / lineHeight);\n\t\t\t\tvar bottomIndex = Math.min(topIndex + linesPerPage, lineCount - 1);\n\t\t\t\tvar lineEnd = Math.min(bottomIndex + 1, lineCount - 1);\n\t\t\t\t\n\t\t\t\tvar lineIndex, lineWidth;\n\t\t\t\tvar child = clientDiv.firstChild;\n\t\t\t\twhile (child) {\n\t\t\t\t\tlineIndex = child.lineIndex;\n\t\t\t\t\tvar nextChild = child.nextSibling;\n\t\t\t\t\tif (!(lineStart <= lineIndex && lineIndex <= lineEnd) || child.lineRemoved || child.lineIndex === -1) {\n\t\t\t\t\t\tif (this._mouseWheelLine === child) {\n\t\t\t\t\t\t\tchild.style.display = \"none\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tchild.lineIndex = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclientDiv.removeChild(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchild = nextChild;\n\t\t\t\t}\n\t\n\t\t\t\tchild = this._getLineNext();\n\t\t\t\tvar document = viewDiv.ownerDocument;\n\t\t\t\tvar frag = document.createDocumentFragment();\n\t\t\t\tfor (lineIndex=lineStart; lineIndex<=lineEnd; lineIndex++) {\n\t\t\t\t\tif (!child || child.lineIndex > lineIndex) {\n\t\t\t\t\t\tnew TextLine(this, lineIndex).create(frag, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (frag.firstChild) {\n\t\t\t\t\t\t\tclientDiv.insertBefore(frag, child);\n\t\t\t\t\t\t\tfrag = document.createDocumentFragment();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (child && child.lineChanged) {\n\t\t\t\t\t\t\tchild = new TextLine(this, lineIndex).create(frag, child);\n\t\t\t\t\t\t\tchild.lineChanged = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchild = this._getLineNext(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (frag.firstChild) { clientDiv.insertBefore(frag, child); }\n\t\n\t\t\t\t/*\n\t\t\t\t* Feature in WekKit. Webkit limits the width of the lines\n\t\t\t\t* computed below to the width of the client div.  This causes\n\t\t\t\t* the lines to be wrapped even though \"pre\" is set.  The fix\n\t\t\t\t* is to set the width of the client div to \"0x7fffffffpx\"\n\t\t\t\t* before computing the lines width.  Note that this value is\n\t\t\t\t* reset to the appropriate value further down.\n\t\t\t\t*/ \n\t\t\t\tif (util.isWebkit && !this._wrapMode) {\n\t\t\t\t\tclientDiv.style.width = \"0x7fffffffpx\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\n\t\t\t\tvar rect;\n\t\t\t\tchild = this._getLineNext();\n\t\t\t\tvar bottomHeight = clientHeight + top;\n\t\t\t\tvar foundBottomIndex = false;\n\t\t\t\twhile (child) {\n\t\t\t\t\tlineWidth = child.lineWidth;\n\t\t\t\t\tif (lineWidth === undefined) {\n\t\t\t\t\t\trect = child._line.getBoundingClientRect();\n\t\t\t\t\t\tlineWidth = child.lineWidth = Math.ceil(rect.right - rect.left);\n\t\t\t\t\t\tvar lh = rect.bottom - rect.top;\n\t\t\t\t\t\tif (this._lineHeight) {\n\t\t\t\t\t\t\tthis._lineHeight[child.lineIndex] = lh;\n\t\t\t\t\t\t} else if (lineHeight !== 0 && lh !== 0 && Math.ceil(lineHeight) !== Math.ceil(lh)) {\n\t\t\t\t\t\t\tthis._variableLineHeight = true;\n\t\t\t\t\t\t\tthis._lineHeight = [];\n\t\t\t\t\t\t\tthis._lineHeight[child.lineIndex] = lh;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._lineHeight && !foundBottomIndex) {\n\t\t\t\t\t\tbottomHeight -= this._lineHeight[child.lineIndex];\n\t\t\t\t\t\tif (bottomHeight < 0) {\n\t\t\t\t\t\t\tbottomIndex = child.lineIndex;\n\t\t\t\t\t\t\tfoundBottomIndex = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!this._wrapMode) {\n\t\t\t\t\t\tif (lineWidth >= this._maxLineWidth) {\n\t\t\t\t\t\t\tthis._maxLineWidth = lineWidth;\n\t\t\t\t\t\t\tthis._maxLineIndex = child.lineIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._checkMaxLineIndex === child.lineIndex) { this._checkMaxLineIndex = -1; }\n\t\t\t\t\t}\n\t\t\t\t\tif (child.lineIndex === topIndex) { this._topChild = child; }\n\t\t\t\t\tif (child.lineIndex === bottomIndex) { this._bottomChild = child; }\n\t\t\t\t\tchild = this._getLineNext(child);\n\t\t\t\t}\n\t\t\t\tif (this._checkMaxLineIndex !== -1) {\n\t\t\t\t\tlineIndex = this._checkMaxLineIndex;\n\t\t\t\t\tthis._checkMaxLineIndex = -1;\n\t\t\t\t\tif (0 <= lineIndex && lineIndex < lineCount) {\n\t\t\t\t\t\tvar line = new TextLine(this, lineIndex);\n\t\t\t\t\t\trect = line.getBoundingClientRect();\n\t\t\t\t\t\tlineWidth = rect.right - rect.left;\n\t\t\t\t\t\tif (lineWidth >= this._maxLineWidth) {\n\t\t\t\t\t\t\tthis._maxLineWidth = lineWidth;\n\t\t\t\t\t\t\tthis._maxLineIndex = lineIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tline.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile (totalLineIndex < lineCount) {\n\t\t\t\t\ttempLineHeight = this._getLineHeight(totalLineIndex, totalLineIndex <= bottomIndex);\n\t\t\t\t\ttotalHeight += tempLineHeight;\n\t\t\t\t\ttotalLineIndex++;\n\t\t\t\t}\n\t\t\t\tscrollHeight = totalHeight;\n\t\n\t\t\t\t// Update rulers\n\t\t\t\tthis._updateRuler(this._leftDiv, topIndex, lineEnd, rootHeight);\n\t\t\t\tthis._updateRuler(this._rightDiv, topIndex, lineEnd, rootHeight);\n\t\t\t\tthis._updateRuler(this._innerRightDiv, topIndex, lineEnd, rootHeight);\n\t\t\t\tthis._updateRuler(this._marginDiv, topIndex, lineEnd, rootHeight);\n\t\t\t\t\n\t\t\t\tleftWidth = 0;\n\t\t\t\tif (this._leftDiv) {\n\t\t\t\t\tleftRect = this._leftDiv.getBoundingClientRect();\n\t\t\t\t\tleftWidth = leftRect.right - leftRect.left;\n\t\t\t\t}\n\t\t\t\tvar rightWidth = 0;\n\t\t\t\tif (this._rightDiv) {\n\t\t\t\t\tvar rightRect = this._rightDiv.getBoundingClientRect();\n\t\t\t\t\trightWidth = rightRect.right - rightRect.left;\n\t\t\t\t}\n\t\t\t\tviewDiv.style.left = leftWidth + \"px\"; //$NON-NLS-0$\n\t\t\t\tviewDiv.style.right = rightWidth + \"px\"; //$NON-NLS-0$\n\n\t\t\t\t/* Need to set the height first in order for the width to consider the vertical scrollbar */\n\t\t\t\tvar scrollDiv = this._scrollDiv;\n\t\t\t\tscrollDiv.style.height = (scrollHeight + (util.isWebkit ? 0 : viewPad.bottom)) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\n\t\t\t\tclientWidth = this._getClientWidth();\n\t\t\t\tif (!this._singleMode && !this._wrapMode && !this._noScroll) {\n\t\t\t\t\tvar clientHeightNoScroll = clientHeight, clientHeightScroll = clientHeight;\n\t\t\t\t\tvar oldHScroll = viewDiv.style.overflowX === \"scroll\"; //$NON-NLS-0$\n\t\t\t\t\tif (oldHScroll) {\n\t\t\t\t\t\tclientHeightNoScroll += scrollbarWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclientHeightScroll -= scrollbarWidth;\n\t\t\t\t\t}\n\t\t\t\t\tvar clientWidthNoScroll = clientWidth, clientWidthScroll = clientWidth;\n\t\t\t\t\tvar oldVScroll = viewDiv.style.overflowY === \"scroll\"; //$NON-NLS-0$\n\t\t\t\t\tif (oldVScroll) {\n\t\t\t\t\t\tclientWidthNoScroll += scrollbarWidth;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclientWidthScroll -= scrollbarWidth;\n\t\t\t\t\t}\n\t\t\t\t\tclientHeight = clientHeightNoScroll;\n\t\t\t\t\tclientWidth = clientWidthNoScroll;\n\t\t\t\t\tif (scrollHeight > clientHeight) {\n\t\t\t\t\t\tvScroll = true;\n\t\t\t\t\t\tclientWidth = clientWidthScroll;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._maxLineWidth > clientWidth) {\n\t\t\t\t\t\thScroll = true;\n\t\t\t\t\t\tclientHeight = clientHeightScroll;\n\t\t\t\t\t\tif (scrollHeight > clientHeight) {\n\t\t\t\t\t\t\tvScroll = true;\n\t\t\t\t\t\t\tclientWidth = clientWidthScroll;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (oldHScroll !== hScroll) {\n\t\t\t\t\t\tviewDiv.style.overflowX = hScroll ? \"scroll\" : \"hidden\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t\tif (oldVScroll !== vScroll) {\n\t\t\t\t\t\tviewDiv.style.overflowY = vScroll ? \"scroll\" : \"hidden\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t\tneedUpdate = oldHScroll !== hScroll || oldVScroll !== vScroll;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar width = clientWidth;\n\t\t\t\tif (this._wrapMode) {\n\t\t\t\t\tif (this._metrics.wrapWidth) {\n\t\t\t\t\t\twidth = this._metrics.wrapWidth;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twidth = Math.max(this._maxLineWidth + this._getInnerRightWidth(), width);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t* Except by IE 8 and earlier, all other browsers are not allocating enough space for the right padding \n\t\t\t\t* in the scrollbar. It is possible this a bug since all other paddings are considered.\n\t\t\t\t*/\n\t\t\t\tscrollWidth = width;\n\t\t\t\tif ((!util.isIE || util.isIE >= 9) && this._maxLineWidth > clientWidth) { width += viewPad.right + viewPad.left; }\n\t\t\t\tscrollDiv.style.width = width + \"px\"; //$NON-NLS-0$\n\t\t\t\tif (this._clipScrollDiv) {\n\t\t\t\t\tthis._clipScrollDiv.style.width = width + \"px\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\t/* Get the left scroll after setting the width of the scrollDiv as this can change the horizontal scroll offset. */\n\t\t\t\tscroll = this._getScroll(false);\n\n\t\t\t\tvar innerRightDiv = this._innerRightDiv;\n\t\t\t\tif (innerRightDiv) {\n\t\t\t\t\tinnerRightDiv.style.right = rightWidth + (viewDiv.style.overflowY === \"scroll\" ? this._metrics.scrollWidth : 0) + \"px\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\tinnerRightDiv.style.bottom = (viewDiv.style.overflowX === \"scroll\" ? scrollbarWidth : 0) + \"px\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._scrollHeight = scrollHeight;\n\t\t\tif (this._vScrollDiv) {\n\t\t\t\tvar trackHeight = clientHeight - 8;\n\t\t\t\tvar thumbHeight = Math.max(15, Math.ceil(Math.min(1, trackHeight / (scrollHeight + viewPad.top + viewPad.bottom)) * trackHeight));\n\t\t\t\tthis._vScrollDiv.style.left = (leftWidth + clientWidth - 8) + \"px\"; //$NON-NLS-0$\n\t\t\t\tthis._vScrollDiv.style.top = Math.floor(Math.max(0, (scroll.y * trackHeight / scrollHeight))) + \"px\"; //$NON-NLS-0$\n\t\t\t\tthis._vScrollDiv.style.height = thumbHeight + \"px\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tif (!this._wrapMode && this._hScrollDiv) {\n\t\t\t\tvar trackWidth = clientWidth - 8;\n\t\t\t\tvar thumbWidth = Math.max(15, Math.ceil(Math.min(1, trackWidth / (this._maxLineWidth + viewPad.left + viewPad.right)) * trackWidth));\n\t\t\t\tthis._hScrollDiv.style.left = leftWidth + Math.floor(Math.max(0, Math.floor(scroll.x * trackWidth / this._maxLineWidth))) + \"px\"; //$NON-NLS-0$\n\t\t\t\tthis._hScrollDiv.style.top = (clientHeight - 9) + \"px\"; //$NON-NLS-0$\n\t\t\t\tthis._hScrollDiv.style.width = thumbWidth + \"px\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tvar left = scroll.x;\t\n\t\t\tvar clipDiv = this._clipDiv;\n\t\t\tvar overlayDiv = this._overlayDiv;\n\t\t\tvar marginDiv = this._marginDiv;\n\t\t\tvar clipLeft, clipTop;\n\t\t\tif (marginDiv) {\n\t\t\t\tmarginDiv.style.left = (-left + leftWidth + this._metrics.marginWidth + viewPad.left) + \"px\"; //$NON-NLS-0$\n\t\t\t\tmarginDiv.style.bottom = (viewDiv.style.overflowX === \"scroll\" ? scrollbarWidth : 0) + \"px\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}\n\t\t\tif (clipDiv) {\n\t\t\t\tclipDiv.scrollLeft = left;\n\t\t\t\tclipDiv.scrollTop = 0;\n\t\t\t\tclipLeft = leftWidth + viewPad.left;\n\t\t\t\tclipTop = viewPad.top;\n\t\t\t\tvar clipWidth = clientWidth;\n\t\t\t\tvar clipHeight = clientHeight;\n\t\t\t\tvar clientLeft = 0, clientTop = -top;\n\t\t\t\tif (scroll.x === 0) {\n\t\t\t\t\tclipLeft -= viewPad.left;\n\t\t\t\t\tclipWidth += viewPad.left;\n\t\t\t\t\tclientLeft = viewPad.left;\n\t\t\t\t} \n\t\t\t\tif (scroll.x + clientWidth === scrollWidth) {\n\t\t\t\t\tclipWidth += viewPad.right;\n\t\t\t\t}\n\t\t\t\tif (scroll.y === 0) {\n\t\t\t\t\tclipTop -= viewPad.top;\n\t\t\t\t\tclipHeight += viewPad.top;\n\t\t\t\t\tclientTop += viewPad.top;\n\t\t\t\t}\n\t\t\t\tif (scroll.y + clientHeight === scrollHeight) { \n\t\t\t\t\tclipHeight += viewPad.bottom; \n\t\t\t\t}\n\t\t\t\tclipDiv.style.left = clipLeft + \"px\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.top = clipTop + \"px\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.right = (rootWidth - clipWidth - clipLeft) + \"px\"; //$NON-NLS-0$\n\t\t\t\tclipDiv.style.bottom = (rootHeight - clipHeight - clipTop) + \"px\"; //$NON-NLS-0$\n\t\t\t\tclientDiv.style.left = clientLeft + \"px\"; //$NON-NLS-0$\n\t\t\t\tclientDiv.style.top = clientTop + \"px\"; //$NON-NLS-0$\n\t\t\t\tclientDiv.style.width = scrollWidth + \"px\"; //$NON-NLS-0$\n\t\t\t\tclientDiv.style.height = (clientHeight + top) + \"px\"; //$NON-NLS-0$\n\t\t\t\tif (overlayDiv) {\n\t\t\t\t\toverlayDiv.style.left = clientDiv.style.left;\n\t\t\t\t\toverlayDiv.style.top = clientDiv.style.top;\n\t\t\t\t\toverlayDiv.style.width = clientDiv.style.width;\n\t\t\t\t\toverlayDiv.style.height = clientDiv.style.height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tclipLeft = left;\n\t\t\t\tclipTop = top;\n\t\t\t\tvar clipRight = left + clientWidth;\n\t\t\t\tvar clipBottom = top + clientHeight;\n\t\t\t\tif (clipLeft === 0) { clipLeft -= viewPad.left; }\n\t\t\t\tif (clipTop === 0) { clipTop -= viewPad.top; }\n\t\t\t\tif (clipRight === scrollWidth) { clipRight += viewPad.right; }\n\t\t\t\tif (scroll.y + clientHeight === scrollHeight) { clipBottom += viewPad.bottom; }\n\t\t\t\tclientDiv.style.clip = \"rect(\" + clipTop + \"px,\" + clipRight + \"px,\" + clipBottom + \"px,\" + clipLeft + \"px)\"; //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tclientDiv.style.left = (-left + leftWidth + viewPad.left) + \"px\"; //$NON-NLS-0$\n\t\t\t\tclientDiv.style.width = (this._wrapMode || util.isWebkit ? scrollWidth : clientWidth + left) + \"px\"; //$NON-NLS-0$\n\t\t\t\tif (!hScrollOnly) {\n\t\t\t\t\tclientDiv.style.top = (-top + viewPad.top) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\tclientDiv.style.height = (clientHeight + top) + \"px\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (overlayDiv) {\n\t\t\t\t\toverlayDiv.style.clip = clientDiv.style.clip;\n\t\t\t\t\toverlayDiv.style.left = clientDiv.style.left;\n\t\t\t\t\toverlayDiv.style.width = clientDiv.style.width;\n\t\t\t\t\tif (!hScrollOnly) {\n\t\t\t\t\t\toverlayDiv.style.top = clientDiv.style.top;\n\t\t\t\t\t\toverlayDiv.style.height = clientDiv.style.height;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._updateDOMSelection();\n\n\t\t\tif (needUpdate) {\n\t\t\t\tvar ensureCaretVisible = this._ensureCaretVisible;\n\t\t\t\tthis._ensureCaretVisible = false;\n\t\t\t\tif (ensureCaretVisible) {\n\t\t\t\t\tthis._showCaret();\n\t\t\t\t}\n\t\t\t\tthis._queueUpdate();\n\t\t\t}\n\t\t},\n\t\t_updateOverflow: function() {\n\t\t\tvar viewDiv = this._viewDiv;\n\t\t\tif (this._noScroll) {\n\t\t\t\tviewDiv.style.overflow = \"hidden\"; //$NON-NLS-0$\n\t\t\t} else if (this._wrapMode) {\n\t\t\t\tviewDiv.style.overflowX = \"hidden\"; //$NON-NLS-0$\n\t\t\t\tviewDiv.style.overflowY = \"scroll\"; //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tviewDiv.style.overflow = \"hidden\"; //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_updateRuler: function (divRuler, topIndex, bottomIndex, rootHeight) {\n\t\t\tif (!divRuler) { return; }\n\t\t\tvar document = this._parent.ownerDocument;\n\t\t\tvar lineHeight = this._getLineHeight();\n\t\t\tvar viewPad = this._getViewPadding();\n\t\t\tvar div = divRuler.firstChild;\n\t\t\twhile (div) {\n\t\t\t\tvar ruler = div._ruler;\n\t\t\t\tvar overview = ruler.getOverview();\n\t\t\t\tif (div.rulerChanged) {\n\t\t\t\t\tapplyStyle(ruler.getRulerStyle(), div);\n\t\t\t\t\tdivRuler.rulerWidth = undefined;\n\t\t\t\t}\n\t\t\t\tif (overview === \"fixed\") { //$NON-NLS-0$\n\t\t\t\t\tdiv.rulerChanged = false;\n\t\t\t\t\tdiv = div.nextSibling;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar offset = lineHeight;\n\t\t\t\tif (overview === \"page\") { offset += this._topIndexY; } //$NON-NLS-0$\n\t\t\t\tdiv.style.top = -offset + \"px\"; //$NON-NLS-0$\n\t\t\t\tdiv.style.height = (rootHeight + offset) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tvar widthDiv;\n\t\t\t\tvar child = div.firstChild;\n\t\t\t\tif (child) {\n\t\t\t\t\twidthDiv = child;\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\twidthDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\t\twidthDiv.style.visibility = \"hidden\"; //$NON-NLS-0$\n\t\t\t\t\tdiv.appendChild(widthDiv);\n\t\t\t\t}\n\t\t\t\tvar lineIndex, annotation;\n\t\t\t\tif (div.rulerChanged) {\n\t\t\t\t\tif (widthDiv) {\n\t\t\t\t\t\tlineIndex = -1;\n\t\t\t\t\t\tannotation = ruler.getWidestAnnotation();\n\t\t\t\t\t\tif (annotation) {\n\t\t\t\t\t\t\tapplyStyle(annotation.style, widthDiv);\n\t\t\t\t\t\t\tif (annotation.html) {\n\t\t\t\t\t\t\t\twidthDiv.innerHTML = annotation.html;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twidthDiv.lineIndex = lineIndex;\n\t\t\t\t\t\twidthDiv.style.height = (lineHeight + viewPad.top) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar lineDiv, frag, annotations;\n\t\t\t\tif (overview === \"page\") { //$NON-NLS-0$\n\t\t\t\t\tannotations = ruler.getAnnotations(topIndex, bottomIndex + 1);\n\t\t\t\t\twhile (child) {\n\t\t\t\t\t\tlineIndex = child.lineIndex;\n\t\t\t\t\t\tvar nextChild = child.nextSibling;\n\t\t\t\t\t\tif (!(topIndex <= lineIndex && lineIndex <= bottomIndex) || child.lineChanged) {\n\t\t\t\t\t\t\tdiv.removeChild(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchild = nextChild;\n\t\t\t\t\t}\n\t\t\t\t\tchild = div.firstChild.nextSibling;\n\t\t\t\t\tfrag = document.createDocumentFragment();\n\t\t\t\t\tfor (lineIndex=topIndex; lineIndex<=bottomIndex; lineIndex++) {\n\t\t\t\t\t\tif (!child || child.lineIndex > lineIndex) {\n\t\t\t\t\t\t\tlineDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\t\t\t\tannotation = annotations[lineIndex];\n\t\t\t\t\t\t\tif (annotation) {\n\t\t\t\t\t\t\t\tapplyStyle(annotation.style, lineDiv);\n\t\t\t\t\t\t\t\tif (annotation.html) {\n\t\t\t\t\t\t\t\t\tlineDiv.innerHTML = annotation.html;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlineDiv.annotation = annotation;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlineDiv.lineIndex = lineIndex;\n\t\t\t\t\t\t\tlineDiv.style.height = this._getLineHeight(lineIndex) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tfrag.appendChild(lineDiv);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (frag.firstChild) {\n\t\t\t\t\t\t\t\tdiv.insertBefore(frag, child);\n\t\t\t\t\t\t\t\tfrag = document.createDocumentFragment();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (child) {\n\t\t\t\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (frag.firstChild) { div.insertBefore(frag, child); }\n\t\t\t\t} else {\n\t\t\t\t\tvar clientHeight = this._getClientHeight ();\n\t\t\t\t\tvar lineCount = this._model.getLineCount ();\n\t\t\t\t\tvar contentHeight = lineHeight * lineCount;\n\t\t\t\t\tvar trackHeight = clientHeight + viewPad.top + viewPad.bottom - 2 * this._metrics.scrollWidth;\n\t\t\t\t\tvar divHeight, arrowWidth;\n\t\t\t\t\tif (contentHeight < trackHeight) {\n\t\t\t\t\t\tdivHeight = lineHeight;\n\t\t\t\t\t\tarrowWidth = viewPad.top;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdivHeight = trackHeight / lineCount;\n\t\t\t\t\t\tarrowWidth = this._metrics.scrollWidth;\n\t\t\t\t\t}\n\t\t\t\t\tif (div.rulerChanged) {\n\t\t\t\t\t\tvar count = div.childNodes.length;\n\t\t\t\t\t\twhile (count > 1) {\n\t\t\t\t\t\t\tdiv.removeChild(div.lastChild);\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tannotations = ruler.getAnnotations(0, lineCount);\n\t\t\t\t\t\tfrag = document.createDocumentFragment();\n\t\t\t\t\t\tfor (var prop in annotations) {\n\t\t\t\t\t\t\tlineIndex = prop >>> 0;\n\t\t\t\t\t\t\tif (lineIndex < 0) { continue; }\n\t\t\t\t\t\t\tlineDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\t\t\t\tannotation = annotations[prop];\n\t\t\t\t\t\t\tapplyStyle(annotation.style, lineDiv);\n\t\t\t\t\t\t\tlineDiv.style.position = \"absolute\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tlineDiv.style.top = arrowWidth + lineHeight + Math.floor(lineIndex * divHeight) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tif (annotation.html) {\n\t\t\t\t\t\t\t\tlineDiv.innerHTML = annotation.html;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlineDiv.annotation = annotation;\n\t\t\t\t\t\t\tlineDiv.lineIndex = lineIndex;\n\t\t\t\t\t\t\tfrag.appendChild(lineDiv);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdiv.appendChild(frag);\n\t\t\t\t\t} else if (div._oldTrackHeight !== trackHeight) {\n\t\t\t\t\t\tlineDiv = div.firstChild ? div.firstChild.nextSibling : null;\n\t\t\t\t\t\twhile (lineDiv) {\n\t\t\t\t\t\t\tlineDiv.style.top = this._metrics.scrollWidth + lineHeight + Math.floor(lineDiv.lineIndex * divHeight) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tlineDiv = lineDiv.nextSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdiv._oldTrackHeight = trackHeight;\n\t\t\t\t}\n\t\t\t\tdiv.rulerChanged = false;\n\t\t\t\tdiv = div.nextSibling;\n\t\t\t}\n\t\t},\n\t\t_updateStyleSheet: function() {\n\t\t\tvar styleText = \"\";\n\t\t\tif (util.isWebkit && this._metrics.scrollWidth > 0) {\n\t\t\t\tstyleText += \"\\n.textview ::-webkit-scrollbar-corner {background: #eeeeee;}\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tif (styleText) {\n\t\t\t\tvar document = this._clientDiv.ownerDocument;\n\t\t\t\tvar node = document.getElementById(\"_textviewStyle\"); //$NON-NLS-0$\n\t\t\t\tif (!node) {\n\t\t\t\t\tnode = util.createElement(document, \"style\"); //$NON-NLS-0$\n\t\t\t\t\tnode.id = \"_textviewStyle\"; //$NON-NLS-0$\n\t\t\t\t\tvar head = document.getElementsByTagName(\"head\")[0] || document.documentElement; //$NON-NLS-0$\n\t\t\t\t\tnode.appendChild(document.createTextNode(styleText));\n\t\t\t\t\thead.insertBefore(node, head.firstChild);\n\t\t\t\t} else {\n\t\t\t\t\tnode.removeChild(node.firstChild);\n\t\t\t\t\tnode.appendChild(document.createTextNode(styleText));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_updateStyle: function (init, metrics) {\n\t\t\tif (!init && util.isIE) {\n\t\t\t\tthis._rootDiv.style.lineHeight = \"normal\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tmetrics = this._metrics = metrics || this._calculateMetrics();\n\t\t\tif (this._variableLineHeight) {\n\t\t\t\tthis._variableLineHeight = false;\n\t\t\t\tthis._resetLineHeight();\n\t\t\t}\n\t\t\tif (util.isIE) {\n\t\t\t\tthis._rootDiv.style.lineHeight = (metrics.lineHeight - (metrics.lineTrim.top + metrics.lineTrim.bottom)) + \"px\"; //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tthis._rootDiv.style.lineHeight = \"normal\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._updateStyleSheet();\n\t\t\tif (util.isMac && util.isWebkit) {\n\t\t\t\tvar viewDiv = this._viewDiv;\n\t\t\t\tif (!metrics.invalid && metrics.scrollWidth === 0) {\n\t\t\t\t\tviewDiv.style.pointerEvents = \"none\"; //$NON-NLS-0$\n\t\t\t\t\tviewDiv.style.zIndex = \"2\"; //$NON-NLS-0$\n\t\t\t\t} else {\n\t\t\t\t\tviewDiv.style.pointerEvents = \"\"; //$NON-NLS-0$\n\t\t\t\t\tviewDiv.style.zIndex = \"\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!init) {\n\t\t\t\tthis.redraw();\n\t\t\t\tthis._resetLineWidth();\n\t\t\t}\n\t\t}\n\t};//end prototype\n\tmEventTarget.EventTarget.addMixin(TextView.prototype);\n\t\n\treturn {TextView: TextView};\n});\n\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/projectionTextModel\", ['orion/editor/textModel', 'orion/editor/eventTarget'], function(mTextModel, mEventTarget) { //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\n\t/**\n\t * @class This object represents a projection range. A projection specifies a\n\t * range of text and the replacement text. The range of text is relative to the\n\t * base text model associated to a projection model.\n\t * <p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.ProjectionTextModel}<br/>\n\t * {@link orion.editor.ProjectionTextModel#addProjection}<br/>\n\t * </p>\t\t \n\t * @name orion.editor.Projection\n\t * \n\t * @property {Number} start The start offset of the projection range. \n\t * @property {Number} end The end offset of the projection range. This offset is exclusive.\n\t * @property {String|orion.editor.TextModel} [text=\"\"] The projection text to be inserted\n\t */\n\t/**\n\t * Constructs a new <code>ProjectionTextModel</code> based on the specified <code>TextModel</code>.\n\t *\n\t * @param {orion.editor.TextModel} baseModel The base text model.\n\t *\n\t * @name orion.editor.ProjectionTextModel\n\t * @class The <code>ProjectionTextModel</code> represents a projection of its base text\n\t * model. Projection ranges can be added to the projection text model to hide and/or insert\n\t * ranges to the base text model.\n\t * <p>\n\t * The contents of the projection text model is modified when changes occur in the base model,\n\t * projection model or by calls to {@link #addProjection} and {@link #removeProjection}.\n\t * </p>\n\t * <p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.TextView}<br/>\n\t * {@link orion.editor.TextModel}\n\t * {@link orion.editor.TextView#setModel}\n\t * </p>\n\t * @borrows orion.editor.EventTarget#addEventListener as #addEventListener\n\t * @borrows orion.editor.EventTarget#removeEventListener as #removeEventListener\n\t * @borrows orion.editor.EventTarget#dispatchEvent as #dispatchEvent\n\t */\n\tfunction ProjectionTextModel(baseModel) {\n\t\tthis._model = baseModel;\n\t\tthis._projections = [];\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonChanged: function(e) {\n\t\t\t\tself._onChanged(e);\n\t\t\t},\n\t\t\tonChanging: function(e) {\n\t\t\t\tself._onChanging(e);\n\t\t\t}\n\t\t};\n\t\tbaseModel.addEventListener(\"postChanged\", this._listener.onChanged); //$NON-NLS-0$\n\t\tbaseModel.addEventListener(\"preChanging\", this._listener.onChanging); //$NON-NLS-0$\n\t}\n\n\tProjectionTextModel.prototype = /** @lends orion.editor.ProjectionTextModel.prototype */ {\n\t\t/**\n\t\t * Destroys this projection text model.\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._model) {\n\t\t\t\tthis._model.removeEventListener(\"postChanged\", this._listener.onChanged); //$NON-NLS-0$\n\t\t\t\tthis._model.removeEventListener(\"preChanging\", this._listener.onChanging); //$NON-NLS-0$\n\t\t\t\tthis._model = null;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Adds a projection range to the model.\n\t\t * <p>\n\t\t * The model must notify the listeners before and after the the text is\n\t\t * changed by calling {@link #onChanging} and {@link #onChanged} respectively. \n\t\t * </p>\n\t\t * @param {orion.editor.Projection} projection The projection range to be added.\n\t\t * \n\t\t * @see orion.editor.ProjectionTextModel#removeProjection\n\t\t */\n\t\taddProjection: function(projection) {\n\t\t\tif (!projection) {return;}\n\t\t\t//start and end can't overlap any exist projection\n\t\t\tvar model = this._model, projections = this._projections;\n\t\t\tprojection._lineIndex = model.getLineAtOffset(projection.start);\n\t\t\tprojection._lineCount = model.getLineAtOffset(projection.end) - projection._lineIndex;\n\t\t\tvar text = projection.text;\n\t\t\tif (!text) { text = \"\"; }\n\t\t\tif (typeof text === \"string\") { //$NON-NLS-0$\n\t\t\t\tprojection._model = new mTextModel.TextModel(text, model.getLineDelimiter());\n\t\t\t} else {\n\t\t\t\tprojection._model = text;\n\t\t\t}\n\t\t\tvar eventStart = this.mapOffset(projection.start, true);\n\t\t\tvar removedCharCount = projection.end - projection.start;\n\t\t\tvar removedLineCount = projection._lineCount;\n\t\t\tvar addedCharCount = projection._model.getCharCount();\n\t\t\tvar addedLineCount = projection._model.getLineCount() - 1;\n\t\t\tvar modelChangingEvent = {\n\t\t\t\ttype: \"Changing\", //$NON-NLS-0$\n\t\t\t\ttext: projection._model.getText(),\n\t\t\t\tstart: eventStart,\n\t\t\t\tremovedCharCount: removedCharCount,\n\t\t\t\taddedCharCount: addedCharCount,\n\t\t\t\tremovedLineCount: removedLineCount,\n\t\t\t\taddedLineCount: addedLineCount\n\t\t\t};\n\t\t\tthis.onChanging(modelChangingEvent);\n\t\t\tvar index = this._binarySearch(projections, projection.start);\n\t\t\tprojections.splice(index, 0, projection);\n\t\t\tvar modelChangedEvent = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tstart: eventStart,\n\t\t\t\tremovedCharCount: removedCharCount,\n\t\t\t\taddedCharCount: addedCharCount,\n\t\t\t\tremovedLineCount: removedLineCount,\n\t\t\t\taddedLineCount: addedLineCount\n\t\t\t};\n\t\t\tthis.onChanged(modelChangedEvent);\n\t\t},\n\t\t/**\n\t\t * Returns all projection ranges of this model.\n\t\t * \n\t\t * @return {orion.editor.Projection[]} The projection ranges.\n\t\t * \n\t\t * @see orion.editor.ProjectionTextModel#addProjection\n\t\t */\n\t\tgetProjections: function() {\n\t\t\treturn this._projections.slice(0);\n\t\t},\n\t\t/**\n\t\t * Gets the base text model.\n\t\t *\n\t\t * @return {orion.editor.TextModel} The base text model.\n\t\t */\n\t\tgetBaseModel: function() {\n\t\t\treturn this._model;\n\t\t},\n\t\t/**\n\t\t * Maps offsets between the projection model and its base model.\n\t\t *\n\t\t * @param {Number} offset The offset to be mapped.\n\t\t * @param {Boolean} [baseOffset=false] <code>true</code> if <code>offset</code> is in base model and\n\t\t *\tshould be mapped to the projection model.\n\t\t * @return {Number} The mapped offset\n\t\t */\n\t\tmapOffset: function(offset, baseOffset) {\n\t\t\tvar projections = this._projections, delta = 0, i, projection;\n\t\t\tif (baseOffset) {\n\t\t\t\tfor (i = 0; i < projections.length; i++) {\n\t\t\t\t\tprojection = projections[i];\n\t\t\t\t\tif (projection.start > offset) { break; }\n\t\t\t\t\tif (projection.end > offset) { return -1; }\n\t\t\t\t\tdelta += projection._model.getCharCount() - (projection.end - projection.start);\n\t\t\t\t}\n\t\t\t\treturn offset + delta;\n\t\t\t}\n\t\t\tfor (i = 0; i < projections.length; i++) {\n\t\t\t\tprojection = projections[i];\n\t\t\t\tif (projection.start > offset - delta) { break; }\n\t\t\t\tvar charCount = projection._model.getCharCount();\n\t\t\t\tif (projection.start + charCount > offset - delta) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tdelta += charCount - (projection.end - projection.start);\n\t\t\t}\n\t\t\treturn offset - delta;\n\t\t},\n\t\t/**\n\t\t * Removes a projection range from the model.\n\t\t * <p>\n\t\t * The model must notify the listeners before and after the the text is\n\t\t * changed by calling {@link #onChanging} and {@link #onChanged} respectively. \n\t\t * </p>\n\t\t * \n\t\t * @param {orion.editor.Projection} projection The projection range to be removed.\n\t\t * \n\t\t * @see orion.editor.ProjectionTextModel#addProjection\n\t\t */\n\t\tremoveProjection: function(projection) {\n\t\t\tthis._removeProjection(projection);\n\t\t},\n\t\t_removeProjection: function(projection, noEvents) {\n\t\t\tvar i, delta = 0;\n\t\t\tfor (i = 0; i < this._projections.length; i++) {\n\t\t\t\tvar p = this._projections[i];\n\t\t\t\tif (p === projection) {\n\t\t\t\t\tprojection = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelta += p._model.getCharCount() - (p.end - p.start);\n\t\t\t}\n\t\t\tif (i < this._projections.length) {\n\t\t\t\tvar model = this._model;\n\t\t\t\tvar eventStart = projection.start + delta;\n\t\t\t\tvar addedCharCount = projection.end - projection.start;\n\t\t\t\tvar addedLineCount = projection._lineCount;\n\t\t\t\tvar removedCharCount = projection._model.getCharCount();\n\t\t\t\tvar removedLineCount = projection._model.getLineCount() - 1;\n\t\t\t\tif (!noEvents) {\n\t\t\t\t\tvar modelChangingEvent = {\n\t\t\t\t\t\ttype: \"Changing\", //$NON-NLS-0$\n\t\t\t\t\t\ttext: model.getText(projection.start, projection.end),\n\t\t\t\t\t\tstart: eventStart,\n\t\t\t\t\t\tremovedCharCount: removedCharCount,\n\t\t\t\t\t\taddedCharCount: addedCharCount,\n\t\t\t\t\t\tremovedLineCount: removedLineCount,\n\t\t\t\t\t\taddedLineCount: addedLineCount\n\t\t\t\t\t};\n\t\t\t\t\tthis.onChanging(modelChangingEvent);\n\t\t\t\t}\n\t\t\t\tthis._projections.splice(i, 1);\n\t\t\t\tif (!noEvents) {\n\t\t\t\t\tvar modelChangedEvent = {\n\t\t\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\t\t\tstart: eventStart,\n\t\t\t\t\t\tremovedCharCount: removedCharCount,\n\t\t\t\t\t\taddedCharCount: addedCharCount,\n\t\t\t\t\t\tremovedLineCount: removedLineCount,\n\t\t\t\t\t\taddedLineCount: addedLineCount\n\t\t\t\t\t};\n\t\t\t\t\tthis.onChanged(modelChangedEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/** @ignore */\n\t\t_binarySearch: function (array, offset) {\n\t\t\tvar high = array.length, low = -1, index;\n\t\t\twhile (high - low > 1) {\n\t\t\t\tindex = Math.floor((high + low) / 2);\n\t\t\t\tif (offset <= array[index].start) {\n\t\t\t\t\thigh = index;\n\t\t\t\t} else {\n\t\t\t\t\tlow = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn high;\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getCharCount\n\t\t */\n\t\tgetCharCount: function() {\n\t\t\tvar count = this._model.getCharCount(), projections = this._projections;\n\t\t\tfor (var i = 0; i < projections.length; i++) {\n\t\t\t\tvar projection = projections[i];\n\t\t\t\tcount += projection._model.getCharCount() - (projection.end - projection.start);\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getLine\n\t\t */\n\t\tgetLine: function(lineIndex, includeDelimiter) {\n\t\t\tif (lineIndex < 0) { return null; }\n\t\t\tvar model = this._model, projections = this._projections;\n\t\t\tvar delta = 0, result = [], offset = 0, i, lineCount, projection;\n\t\t\tfor (i = 0; i < projections.length; i++) {\n\t\t\t\tprojection = projections[i];\n\t\t\t\tif (projection._lineIndex >= lineIndex - delta) { break; }\n\t\t\t\tlineCount = projection._model.getLineCount() - 1;\n\t\t\t\tif (projection._lineIndex + lineCount >= lineIndex - delta) {\n\t\t\t\t\tvar projectionLineIndex = lineIndex - (projection._lineIndex + delta);\n\t\t\t\t\tif (projectionLineIndex < lineCount) {\n\t\t\t\t\t\treturn projection._model.getLine(projectionLineIndex, includeDelimiter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.push(projection._model.getLine(lineCount));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toffset = projection.end;\n\t\t\t\tdelta += lineCount - projection._lineCount;\n\t\t\t}\n\t\t\toffset = Math.max(offset, model.getLineStart(lineIndex - delta));\n\t\t\tfor (; i < projections.length; i++) {\n\t\t\t\tprojection = projections[i];\n\t\t\t\tif (projection._lineIndex > lineIndex - delta) { break; }\n\t\t\t\tresult.push(model.getText(offset, projection.start));\n\t\t\t\tlineCount = projection._model.getLineCount() - 1;\n\t\t\t\tif (projection._lineIndex + lineCount > lineIndex - delta) {\n\t\t\t\t\tresult.push(projection._model.getLine(0, includeDelimiter));\n\t\t\t\t\treturn result.join(\"\");\n\t\t\t\t}\n\t\t\t\tresult.push(projection._model.getText());\n\t\t\t\toffset = projection.end;\n\t\t\t\tdelta += lineCount - projection._lineCount;\n\t\t\t}\n\t\t\tvar end = model.getLineEnd(lineIndex - delta, includeDelimiter);\n\t\t\tif (offset < end) {\n\t\t\t\tresult.push(model.getText(offset, end));\n\t\t\t}\n\t\t\treturn result.join(\"\");\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getLineAtOffset\n\t\t */\n\t\tgetLineAtOffset: function(offset) {\n\t\t\tvar model = this._model, projections = this._projections;\n\t\t\tvar delta = 0, lineDelta = 0;\n\t\t\tfor (var i = 0; i < projections.length; i++) {\n\t\t\t\tvar projection = projections[i];\n\t\t\t\tif (projection.start > offset - delta) { break; }\n\t\t\t\tvar charCount = projection._model.getCharCount();\n\t\t\t\tif (projection.start + charCount > offset - delta) {\n\t\t\t\t\tvar projectionOffset = offset - (projection.start + delta);\n\t\t\t\t\tlineDelta += projection._model.getLineAtOffset(projectionOffset);\n\t\t\t\t\tdelta += projectionOffset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlineDelta += projection._model.getLineCount() - 1 - projection._lineCount;\n\t\t\t\tdelta += charCount - (projection.end - projection.start);\n\t\t\t}\n\t\t\treturn model.getLineAtOffset(offset - delta) + lineDelta;\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getLineCount\n\t\t */\n\t\tgetLineCount: function() {\n\t\t\tvar model = this._model, projections = this._projections;\n\t\t\tvar count = model.getLineCount();\n\t\t\tfor (var i = 0; i < projections.length; i++) {\n\t\t\t\tvar projection = projections[i];\n\t\t\t\tcount += projection._model.getLineCount() - 1 - projection._lineCount;\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getLineDelimiter\n\t\t */\n\t\tgetLineDelimiter: function() {\n\t\t\treturn this._model.getLineDelimiter();\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getLineEnd\n\t\t */\n\t\tgetLineEnd: function(lineIndex, includeDelimiter) {\n\t\t\tif (lineIndex < 0) { return -1; }\n\t\t\tvar model = this._model, projections = this._projections;\n\t\t\tvar delta = 0, offsetDelta = 0;\n\t\t\tfor (var i = 0; i < projections.length; i++) {\n\t\t\t\tvar projection = projections[i];\n\t\t\t\tif (projection._lineIndex > lineIndex - delta) { break; }\n\t\t\t\tvar lineCount = projection._model.getLineCount() - 1;\n\t\t\t\tif (projection._lineIndex + lineCount > lineIndex - delta) {\n\t\t\t\t\tvar projectionLineIndex = lineIndex - (projection._lineIndex + delta);\n\t\t\t\t\treturn projection._model.getLineEnd (projectionLineIndex, includeDelimiter) + projection.start + offsetDelta;\n\t\t\t\t}\n\t\t\t\toffsetDelta += projection._model.getCharCount() - (projection.end - projection.start);\n\t\t\t\tdelta += lineCount - projection._lineCount;\n\t\t\t}\n\t\t\treturn model.getLineEnd(lineIndex - delta, includeDelimiter) + offsetDelta;\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getLineStart\n\t\t */\n\t\tgetLineStart: function(lineIndex) {\n\t\t\tif (lineIndex < 0) { return -1; }\n\t\t\tvar model = this._model, projections = this._projections;\n\t\t\tvar delta = 0, offsetDelta = 0;\n\t\t\tfor (var i = 0; i < projections.length; i++) {\n\t\t\t\tvar projection = projections[i];\n\t\t\t\tif (projection._lineIndex >= lineIndex - delta) { break; }\n\t\t\t\tvar lineCount = projection._model.getLineCount() - 1;\n\t\t\t\tif (projection._lineIndex + lineCount >= lineIndex - delta) {\n\t\t\t\t\tvar projectionLineIndex = lineIndex - (projection._lineIndex + delta);\n\t\t\t\t\treturn projection._model.getLineStart (projectionLineIndex) + projection.start + offsetDelta;\n\t\t\t\t}\n\t\t\t\toffsetDelta += projection._model.getCharCount() - (projection.end - projection.start);\n\t\t\t\tdelta += lineCount - projection._lineCount;\n\t\t\t}\n\t\t\treturn model.getLineStart(lineIndex - delta) + offsetDelta;\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#getText\n\t\t */\n\t\tgetText: function(start, end) {\n\t\t\tif (start === undefined) { start = 0; }\n\t\t\tvar model = this._model, projections = this._projections;\n\t\t\tvar delta = 0, result = [], i, projection, charCount;\n\t\t\tfor (i = 0; i < projections.length; i++) {\n\t\t\t\tprojection = projections[i];\n\t\t\t\tif (projection.start > start - delta) { break; }\n\t\t\t\tcharCount = projection._model.getCharCount();\n\t\t\t\tif (projection.start + charCount > start - delta) {\n\t\t\t\t\tif (end !== undefined && projection.start + charCount > end - delta) {\n\t\t\t\t\t\treturn projection._model.getText(start - (projection.start + delta), end - (projection.start + delta));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.push(projection._model.getText(start - (projection.start + delta)));\n\t\t\t\t\t\tstart = projection.end + delta + charCount - (projection.end - projection.start);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelta += charCount - (projection.end - projection.start);\n\t\t\t}\n\t\t\tvar offset = start - delta;\n\t\t\tif (end !== undefined) {\n\t\t\t\tfor (; i < projections.length; i++) {\n\t\t\t\t\tprojection = projections[i];\n\t\t\t\t\tif (projection.start > end - delta) { break; }\n\t\t\t\t\tresult.push(model.getText(offset, projection.start));\n\t\t\t\t\tcharCount = projection._model.getCharCount();\n\t\t\t\t\tif (projection.start + charCount > end - delta) {\n\t\t\t\t\t\tresult.push(projection._model.getText(0, end - (projection.start + delta)));\n\t\t\t\t\t\treturn result.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tresult.push(projection._model.getText());\n\t\t\t\t\toffset = projection.end;\n\t\t\t\t\tdelta += charCount - (projection.end - projection.start);\n\t\t\t\t}\n\t\t\t\tresult.push(model.getText(offset, end - delta));\n\t\t\t} else {\n\t\t\t\tfor (; i < projections.length; i++) {\n\t\t\t\t\tprojection = projections[i];\n\t\t\t\t\tresult.push(model.getText(offset, projection.start));\n\t\t\t\t\tresult.push(projection._model.getText());\n\t\t\t\t\toffset = projection.end;\n\t\t\t\t}\n\t\t\t\tresult.push(model.getText(offset));\n\t\t\t}\n\t\t\treturn result.join(\"\");\n\t\t},\n\t\t/** @ignore */\n\t\t_onChanged: function(modelChangedEvent) {\n\t\t\tvar change = this._change;\n\t\t\tvar start = change.baseStart, end = change.baseEnd, i;\n\t\t\tvar projection, projections = this._projections;\n\t\t\tfor (i = 0; i < projections.length; i++) {\n\t\t\t\tprojection = projections[i];\n\t\t\t\tif (projection.end > start) { break; }\n\t\t\t}\n\t\t\tvar rangeStart = i;\n\t\t\tfor (i = 0; i < projections.length; i++) {\n\t\t\t\tprojection = projections[i];\n\t\t\t\tif (projection.start >= end) { break; }\n\t\t\t}\n\t\t\tvar rangeEnd = i;\n\t\t\tvar model = this._model;\n\t\t\tvar changeCount = change.baseText.length - (end - start);\n\t\t\tfor (i = rangeEnd; i < projections.length; i++) {\n\t\t\t\tprojection = projections[i];\n\t\t\t\tprojection.start += changeCount;\n\t\t\t\tprojection.end += changeCount;\n\t\t\t\tprojection._lineIndex = model.getLineAtOffset(projection.start);\n\t\t\t}\n\t\t\tvar removed = projections.splice(rangeStart, rangeEnd - rangeStart);\n\t\t\tfor (i = 0; i < removed.length; i++) {\n\t\t\t\tif (removed[i].annotation) {\n\t\t\t\t\tremoved[i].annotation._expand();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar modelChangedEvent1 = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tstart: change.start,\n\t\t\t\tremovedCharCount: change.removedCharCount,\n\t\t\t\taddedCharCount: change.addedCharCount,\n\t\t\t\tremovedLineCount: change.removedLineCount,\n\t\t\t\taddedLineCount: change.addedLineCount\n\t\t\t};\n\t\t\tthis.onChanged(modelChangedEvent1);\n\t\t\tthis._change = undefined;\n\t\t},\n\t\t_onChanging: function(modelChangingEvent) {\n\t\t\tvar hasChange = !!this._change;\n\t\t\tvar change = this._change || {};\n\t\t\tvar start = modelChangingEvent.start, end = start + modelChangingEvent.removedCharCount;\n\t\t\tchange.baseStart = start;\n\t\t\tchange.baseEnd = end;\n\t\t\tchange.baseText = modelChangingEvent.text;\n\t\t\tchange.addedLineCount = modelChangingEvent.addedLineCount;\n\t\t\tif (!hasChange) {\n\t\t\t\tthis._change = change;\n\t\t\t\tchange.text = modelChangingEvent.text;\n\t\t\t\tvar projections = this._projections, delta, i, projection;\n\t\t\t\tfunction mapOffset(offset) {\n\t\t\t\t\tfor (i = 0, delta = 0; i < projections.length; i++) {\n\t\t\t\t\t\tprojection = projections[i];\n\t\t\t\t\t\tif (projection.start > offset) { break; }\n\t\t\t\t\t\tif (projection.end > offset) { return -1; }\n\t\t\t\t\t\tdelta += projection._model.getCharCount() - (projection.end - projection.start);\n\t\t\t\t\t}\n\t\t\t\t\treturn offset + delta;\n\t\t\t\t}\n\t\t\t\tchange.start = mapOffset(start);\n\t\t\t\tif (change.start === -1) {\n\t\t\t\t\tchange.text = this._model.getText(projection.start, start) + change.text;\n\t\t\t\t\tchange.addedLineCount += this._model.getLineAtOffset(start) - this._model.getLineAtOffset(projection.start);\n\t\t\t\t\tchange.start = projection.start + delta;\n\t\t\t\t}\n\t\t\t\tchange.end = mapOffset(end);\n\t\t\t\tif (change.end === -1) {\n\t\t\t\t\tchange.text += this._model.getText(end, projection.end);\n\t\t\t\t\tchange.addedLineCount += this._model.getLineAtOffset(projection.end) - this._model.getLineAtOffset(end);\n\t\t\t\t\tchange.end = projection.start + delta;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchange.addedCharCount = change.text.length;\n\t\t\tchange.removedCharCount = change.end - change.start;\n\t\t\tchange.removedLineCount = this.getLineAtOffset(change.end) - this.getLineAtOffset(change.start);\n\t\t\tvar modelChangingEvent1 = {\n\t\t\t\ttype: \"Changing\", //$NON-NLS-0$\n\t\t\t\ttext: change.text,\n\t\t\t\tstart: change.start,\n\t\t\t\tremovedCharCount: change.removedCharCount,\n\t\t\t\taddedCharCount: change.addedCharCount,\n\t\t\t\tremovedLineCount: change.removedLineCount,\n\t\t\t\taddedLineCount: change.addedLineCount\n\t\t\t};\n\t\t\tthis.onChanging(modelChangingEvent1);\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#onChanging\n\t\t */\n\t\tonChanging: function(modelChangingEvent) {\n\t\t\treturn this.dispatchEvent(modelChangingEvent);\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#onChanged\n\t\t */\n\t\tonChanged: function(modelChangedEvent) {\n\t\t\treturn this.dispatchEvent(modelChangedEvent);\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#setLineDelimiter\n\t\t */\n\t\tsetLineDelimiter: function(lineDelimiter) {\n\t\t\tthis._model.setLineDelimiter(lineDelimiter);\n\t\t},\n\t\t/**\n\t\t * @see orion.editor.TextModel#setText\n\t\t */\n\t\tsetText: function(text, start, end) {\n\t\t\tthis._change = {\n\t\t\t\ttext: text || \"\",\n\t\t\t\tstart: start || 0,\n\t\t\t\tend: end === undefined ? this.getCharCount() : end\n\t\t\t};\n\t\t\tvar projections = this._projections, delta, i, projection;\n\t\t\tfunction mapOffset(offset) {\n\t\t\t\tfor (i = 0, delta = 0; i < projections.length; i++) {\n\t\t\t\t\tprojection = projections[i];\n\t\t\t\t\tif (projection.start > offset - delta) { break; }\n\t\t\t\t\tvar charCount = projection._model.getCharCount();\n\t\t\t\t\tif (projection.start + charCount > offset - delta) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tdelta += charCount - (projection.end - projection.start);\n\t\t\t\t}\n\t\t\t\treturn offset - delta;\n\t\t\t}\n\t\t\tvar startProjection, endProjection;\n\t\t\tvar mapStart = mapOffset(this._change.start);\n\t\t\tif (mapStart === -1) {\n\t\t\t\tstartProjection = {\n\t\t\t\t\tprojection: projection,\n\t\t\t\t\tstart: this._change.start - (projection.start + delta)\n\t\t\t\t};\n\t\t\t\tmapStart = projection.end;\n\t\t\t}\n\t\t\tvar mapEnd = mapOffset(this._change.end);\n\t\t\tif (mapEnd === -1) {\n\t\t\t\tendProjection = {\n\t\t\t\t\tprojection: projection,\n\t\t\t\t\tend: this._change.end - (projection.start + delta)\n\t\t\t\t};\n\t\t\t\tmapEnd = projection.start;\n\t\t\t}\n\t\t\tif (startProjection && endProjection && startProjection.projection === endProjection.projection) {\n\t\t\t\t//TODO events - special case - change is completely inside of a projection\n\t\t\t\tprojection._model.setText(this._change.text, startProjection.start, endProjection.end);\n\t\t\t} else {\n\t\t\t\tthis._model.setText(this._change.text, mapStart, mapEnd);\n\t\t\t\tif (startProjection) {\n\t\t\t\t\tprojection = startProjection.projection;\n\t\t\t\t\tprojection._model.setText(\"\", startProjection.start);\n\t\t\t\t}\t\t\n\t\t\t\tif (endProjection) {\n\t\t\t\t\tprojection = endProjection.projection;\n\t\t\t\t\tprojection._model.setText(\"\", 0, endProjection.end);\n\t\t\t\t\tprojection.start = projection.end;\n\t\t\t\t\tprojection._lineCount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._change = undefined;\n\t\t}\n\t};\n\tmEventTarget.EventTarget.addMixin(ProjectionTextModel.prototype);\n\n\treturn {ProjectionTextModel: ProjectionTextModel};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n/*eslint-env browser, amd, node*/\n(function(root, factory) { // UMD\n    if (typeof define === \"function\" && define.amd) { //$NON-NLS-0$\n        define('orion/Deferred',factory);\n    } else if (typeof exports === \"object\") { //$NON-NLS-0$\n        module.exports = factory();\n    } else {\n        root.orion = root.orion || {};\n        root.orion.Deferred = factory();\n    }\n}(this, function() {\n    var queue = [],\n        running = false;\n\n    function run() {\n        var fn;\n        while ((fn = queue.shift())) {\n            fn();\n        }\n        running = false;\n    }\n\n\tvar runAsync = (function() {\n\t\tif (typeof process !== \"undefined\" && typeof process.nextTick === \"function\") {\n\t\t\tvar nextTick = process.nextTick;\n    \t\treturn function() {\n    \t\t\tnextTick(run);\n    \t\t};\n\t\t} else if (typeof MutationObserver === \"function\") {\n\t\t\tvar div = document.createElement(\"div\");\n\t\t\tvar observer = new MutationObserver(run);\n\t\t\tobserver.observe(div, {\n            \tattributes: true\n        \t});\n        \treturn function() {\n        \t\tdiv.setAttribute(\"class\", \"_tick\");\n        \t};\n\t\t}\n\t\treturn function() {\n\t\t\tsetTimeout(run, 0);\n\t\t};\n\t})();\n\n    function enqueue(fn) {\n        queue.push(fn);\n        if (!running) {\n            running = true;\n            runAsync();\n        }\n    }\n\n    function noReturn(fn) {\n        return function(result) {\n            fn(result);\n        };\n    }\n    \n    function settleDeferred(fn, result, deferred) {\n    \ttry {\n    \t\tvar listenerResult = fn(result);\n    \t\tvar listenerThen = listenerResult && (typeof listenerResult === \"object\" || typeof listenerResult === \"function\") && listenerResult.then;\n    \t\tif (typeof listenerThen === \"function\") {\n    \t\t\tif (listenerResult === deferred.promise) {\n    \t\t\t\tdeferred.reject(new TypeError());\n    \t\t\t} else {\n    \t\t\t\tvar listenerResultCancel = listenerResult.cancel;\n    \t\t\t\tif (typeof listenerResultCancel === \"function\") {\n    \t\t\t\t\tdeferred._parentCancel = listenerResultCancel.bind(listenerResult);\n    \t\t\t\t} else {\n    \t\t\t\t\tdelete deferred._parentCancel;\n    \t\t\t\t}\n    \t\t\t\tlistenerThen.call(listenerResult, noReturn(deferred.resolve), noReturn(deferred.reject), noReturn(deferred.progress));\n    \t\t\t}\n    \t\t} else {\n    \t\t\tdeferred.resolve(listenerResult);\n    \t\t}\n    \t} catch (e) {\n    \t\tdeferred.reject(e);\n    \t}\n    }\n\n\n    /**\n     * @name orion.Promise\n     * @class Interface representing an eventual value.\n     * @description Promise is an interface that represents an eventual value returned from the single completion of an operation.\n     *\n     * <p>For a concrete class that implements Promise and provides additional API, see {@link orion.Deferred}.</p>\n     * @see orion.Deferred\n     * @see orion.Deferred#promise\n     */\n    /**\n     * @name then\n     * @function\n     * @memberOf orion.Promise.prototype\n     * @description Adds handlers to be called on fulfillment or progress of this promise.\n     * @param {Function} [onResolve] Called when this promise is resolved.\n     * @param {Function} [onReject] Called when this promise is rejected.\n     * @param {Function} [onProgress] May be called to report progress events on this promise.\n     * @returns {orion.Promise} A new promise that is fulfilled when the given <code>onResolve</code> or <code>onReject</code>\n     * callback is finished. The callback's return value gives the fulfillment value of the returned promise.\n     */\n    /**\n     * Cancels this promise.\n     * @name cancel\n     * @function\n     * @memberOf orion.Promise.prototype\n     * @param {Object} reason The reason for canceling this promise.\n     * @param {Boolean} [strict]\n     */\n\n    /**\n     * @name orion.Deferred\n     * @borrows orion.Promise#then as #then\n     * @borrows orion.Promise#cancel as #cancel\n     * @class Provides abstraction over asynchronous operations.\n     * @description Deferred provides abstraction over asynchronous operations.\n     *\n     * <p>Because Deferred implements the {@link orion.Promise} interface, a Deferred may be used anywhere a Promise is called for.\n     * However, in most such cases it is recommended to use the Deferred's {@link #promise} field instead, which exposes a \n     * simplified, minimally <a href=\"https://github.com/promises-aplus/promises-spec\">Promises/A+</a>-compliant interface to callers.</p>\n     */\n    function Deferred() {\n        var result, state, listeners = [],\n            _this = this;\n\n        function notify() {\n            var listener;\n            while ((listener = listeners.shift())) {\n                var deferred = listener.deferred;\n                var methodName = state === \"fulfilled\" ? \"resolve\" : \"reject\"; //$NON-NLS-0$ //$NON-NLS-1$ //$NON-NLS-2$\n                var fn = listener[methodName];\n                if (typeof fn === \"function\") { //$NON-NLS-0$\n                \tsettleDeferred(fn, result, deferred);\n                } else {\n                    deferred[methodName](result);\n                }\n            }\n        }\n\n        function _reject(error) {\n            delete _this._parentCancel;\n            state = \"rejected\";\n            result = error;\n            if (listeners.length) {\n                enqueue(notify);\n            }\n        }\n\n        function _resolve(value) {\n            function once(fn) {\n                return function(result) {\n                    if (!state || state === \"assumed\") {\n                          fn(result);\n                    }\n                };\n            }\n            delete _this._parentCancel;\n            try {\n                var valueThen = value && (typeof value === \"object\" || typeof value === \"function\") && value.then;\n                if (typeof valueThen === \"function\") {\n                    if (value === _this) {\n                        _reject(new TypeError());\n                    } else {\n                        state = \"assumed\";\n                        var valueCancel = value && value.cancel;\n                        if (typeof valueCancel !== \"function\") {\n                            var deferred = new Deferred();\n                            value = deferred.promise;\n                            try {\n                                valueThen(deferred.resolve, deferred.reject, deferred.progress);\n                            } catch (thenError) {\n                                deferred.reject(thenError);\n                            }\n                            valueCancel = value.cancel;\n                            valueThen = value.then;\n                        }\n                        result = value;\n                        valueThen.call(value, once(_resolve), once(_reject));\n                        _this._parentCancel = valueCancel.bind(value);\n                    }\n                } else {\n                    state = \"fulfilled\";\n                    result = value;\n                    if (listeners.length) {\n                        enqueue(notify);\n                    }\n                }\n            } catch (error) {\n                once(_reject)(error);\n            }\n        }\n\n        function cancel() {\n            var parentCancel = _this._parentCancel;\n            if (parentCancel) {\n                delete _this._parentCancel;\n                parentCancel();\n            } else if (!state) {\n                var cancelError = new Error(\"Cancel\");\n                cancelError.name = \"Cancel\";\n                _reject(cancelError);\n            }\n        }\n\n\n        /**\n         * Resolves this Deferred.\n         * @name resolve\n         * @function\n         * @memberOf orion.Deferred.prototype\n         * @param {Object} value\n         * @returns {orion.Promise}\n         */\n        this.resolve = function(value) {\n            if (!state) {\n                _resolve(value);\n            }\n            return _this;\n        };\n\n        /**\n         * Rejects this Deferred.\n         * @name reject\n         * @function\n         * @memberOf orion.Deferred.prototype\n         * @param {Object} error\n         * @param {Boolean} [strict]\n         * @returns {orion.Promise}\n         */\n        this.reject = function(error) {\n            if (!state) {\n                _reject(error);\n            }\n            return _this;\n        };\n\n        /**\n         * Notifies listeners of progress on this Deferred.\n         * @name progress\n         * @function\n         * @memberOf orion.Deferred.prototype\n         * @param {Object} update The progress update.\n         * @returns {orion.Promise}\n         */\n        this.progress = function(update) {\n            if (!state) {\n                listeners.forEach(function(listener) {\n                    if (listener.progress) {\n                        try {\n                            listener.progress(update);\n                        } catch (ignore) {\n                            // ignore\n                        }\n                    }\n                });\n            }\n            return _this.promise;\n        };\n\n        this.cancel = function() {\n            if (_this._parentCancel) {\n                setTimeout(cancel, 0);\n            } else {\n                cancel();\n            }\n            return _this;\n        };\n\n        // Note: \"then\" ALWAYS returns before having onResolve or onReject called as per http://promises-aplus.github.com/promises-spec/\n        this.then = function(onFulfill, onReject, onProgress) {\n        \tvar deferred = new Deferred();\n            deferred._parentCancel = _this.promise.cancel;\n            listeners.push({\n                resolve: onFulfill,\n                reject: onReject,\n                progress: onProgress,\n                deferred: deferred\n            });\n            if (state === \"fulfilled\" || state === \"rejected\") {\n                enqueue(notify);\n            }\n            return deferred.promise;\n        };\n\n        /**\n         * The promise exposed by this Deferred.\n         * @name promise\n         * @field\n         * @memberOf orion.Deferred.prototype\n         * @type orion.Promise\n         */\n        this.promise = {\n            then: _this.then,\n            cancel: _this.cancel\n        };\n    }\n\n    /**\n     * Returns a promise that represents the outcome of all the input promises.\n     * <p>When <code>all</code> is called with a single parameter, the returned promise has <dfn>eager</dfn> semantics,\n     * meaning that if any input promise rejects, the returned promise immediately rejects, without waiting for the rest of the\n     * input promises to fulfill.</p>\n     *\n     * To obtain <dfn>lazy</dfn> semantics (meaning the returned promise waits for every input promise to fulfill), pass the\n     * optional parameter <code>optOnError</code>.\n     * @name all\n     * @function\n     * @memberOf orion.Deferred\n     * @static\n     * @param {orion.Promise[]} promises The input promises.\n     * @param {Function} [optOnError] Handles a rejected input promise. <code>optOnError</code> is invoked for every rejected\n     * input promise, and is passed the reason the input promise was rejected. <p><code>optOnError</code> can return a value, which\n     * allows it to act as a transformer: the return value serves as the final fulfillment value of the rejected promise in the \n     * results array generated by <code>all</code>.\n     * @returns {orion.Promise} A new promise. The returned promise is generally fulfilled to an <code>Array</code> whose elements\n     * give the fulfillment values of the input promises. <p>However, if an input promise rejects and eager semantics is used, the \n     * returned promise will instead be fulfilled to a single error value.</p>\n     */\n    Deferred.all = function(promises, optOnError) {\n        var count = promises.length,\n            result = [],\n            rejected = false,\n            deferred = new Deferred();\n\n        deferred.then(undefined, function() {\n            rejected = true;\n            promises.forEach(function(promise) {\n                if (promise.cancel) {\n                    promise.cancel();\n                }\n            });\n        });\n\n        function onResolve(i, value) {\n            if (!rejected) {\n                result[i] = value;\n                if (--count === 0) {\n                    deferred.resolve(result);\n                }\n            }\n        }\n\n        function onReject(i, error) {\n            if (!rejected) {\n                if (optOnError) {\n                    try {\n                        onResolve(i, optOnError(error));\n                        return;\n                    } catch (e) {\n                        error = e;\n                    }\n                }\n                deferred.reject(error);\n            }\n        }\n\n        if (count === 0) {\n            deferred.resolve(result);\n        } else {\n            promises.forEach(function(promise, i) {\n                promise.then(onResolve.bind(undefined, i), onReject.bind(undefined, i));\n            });\n        }\n        return deferred.promise;\n    };\n\n    /**\n     * Applies callbacks to a promise or to a regular object.\n     * @name when\n     * @function\n     * @memberOf orion.Deferred\n     * @static\n     * @param {Object|orion.Promise} value Either a {@link orion.Promise}, or a normal value.\n     * @param {Function} onResolve Called when the <code>value</code> promise is resolved. If <code>value</code> is not a promise,\n     * this function is called immediately.\n     * @param {Function} onReject Called when the <code>value</code> promise is rejected. If <code>value</code> is not a promise, \n     * this function is never called.\n     * @param {Function} onProgress Called when the <code>value</code> promise provides a progress update. If <code>value</code> is\n     * not a promise, this function is never called.\n     * @returns {orion.Promise} A new promise.\n     */\n    Deferred.when = function(value, onResolve, onReject, onProgress) {\n        var promise, deferred;\n        if (value && typeof value.then === \"function\") { //$NON-NLS-0$\n            promise = value;\n        } else {\n            deferred = new Deferred();\n            deferred.resolve(value);\n            promise = deferred.promise;\n        }\n        return promise.then(onResolve, onReject, onProgress);\n    };\n\n    return Deferred;\n}));\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n/*eslint-env browser, amd*/\ndefine('orion/webui/littlelib',[\"orion/util\"], function(util) {\n\t/**\n\t * @name orion.webui.littlelib\n\t * @class A small library of DOM and UI helpers.\n\t */\n\n\t/**\n\t * Alias for <code>node.querySelector()</code>.\n\t * @name orion.webui.littlelib.$\n\t * @function\n\t * @static\n\t * @param {String} selectors Selectors to match on.\n\t * @param {Node} [node=document] Node to query under.\n\t * @returns {Element}\n\t */\n\tfunction $(selector, node) {\n\t\tif (!node) {\n\t\t\tnode = document;\n\t\t}\n\t\treturn node.querySelector(selector);\n\t}\n\n\t/**\n\t * Alias for <code>node.querySelectorAll()</code>.\n\t * @name orion.webui.littlelib.$$\n\t * @function\n\t * @static\n\t * @param {String} selectors Selectors to match on.\n\t * @param {Node} [node=document] Node to query under.\n\t * @returns {NodeList}\n\t */\n\tfunction $$(selector, node) {\n\t\tif (!node) {\n\t\t\tnode = document;\n\t\t}\n\t\treturn node.querySelectorAll(selector);\n\t}\n\n\t/**\n\t * Identical to {@link orion.webui.littlelib.$$}, but returns an Array instead of a NodeList.\n\t * @name orion.webui.littlelib.$$array\n\t * @function\n\t * @static\n\t * @param {String} selectors Selectors to match on.\n\t * @param {Node} [node=document] Node to query under.\n\t * @returns {Element[]}\n\t */\n\tfunction $$array(selector, node) {\n\t\treturn Array.prototype.slice.call($$(selector,node));\n\t}\n\n\t/**\n\t * Alias for <code>document.getElementById</code>, but returns the input unmodified when passed a Node (or other non-string).\n\t * @function\n\t * @param {String|Element} elementOrId\n\t * @returns {Element}\n\t */\n\tfunction node(either) {\n\t\tvar theNode = either;\n\t\tif (typeof(either) === \"string\") { //$NON-NLS-0$\n\t\t\ttheNode = document.getElementById(either);\n\t\t}\t\n\t\treturn theNode;\n\t}\n\n\t/**\n\t * Returns whether <code>child</code> is a descendant of <code>parent</code> in the DOM order.\n\t * @function\n\t * @param {Node} parent\n\t * @param {Node} child\n\t * @returns {Boolean}\n\t */\n\tfunction contains(parent, child) {\n\t\tif (!parent || !child) { return false; }\n\t\tif (parent === child) { return true; }\n\t\tvar compare = parent.compareDocumentPosition(child);  // useful to break out for debugging\n\t\treturn Boolean(compare & 16);\n\t}\n\n\t/**\n\t * Returns the bounds of a node. The returned coordinates are absolute (not relative to the viewport).\n\t * @function\n\t * @param {Node} node\n\t * @returns {Object}\n\t */\n\tfunction bounds(node) {\n\t\tvar clientRect = node.getBoundingClientRect();\n\t\tvar scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);\n\t\tvar scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop);\n\t\treturn { \n\t\t\tleft: clientRect.left + scrollLeft,\n\t\t\ttop: clientRect.top + scrollTop,\n\t\t\twidth: clientRect.width,\n\t\t\theight: clientRect.height\n\t\t};\n\t}\n\n\t/**\n\t * Removes all children of the given node.\n\t * @name orion.webui.littlelib.empty\n\t * @function\n\t * @static\n\t * @param {Node} node\n\t */\n\tfunction empty(node) {\n\t\twhile (node.hasChildNodes()) {\n\t\t\tvar child = node.firstChild;\n\t\t\tnode.removeChild(child);\n\t\t}\n\t}\n\n\tfunction _getTabIndex(node) {\n\t\tvar result = node.tabIndex;\n\t\tif (result === 0 && util.isIE) {\n\t\t\t/*\n\t\t\t * The default value of tabIndex is 0 on IE, even for elements that are not focusable\n\t\t\t * by default (http://msdn.microsoft.com/en-us/library/ie/ms534654(v=vs.85).aspx).\n\t\t\t * Handle this browser difference by treating this value as -1 if the node is a type\n\t\t\t * that is not focusable by default according to the MS doc and has not had this\n\t\t\t * attribute value explicitly set on it.\n\t\t\t */\n\t\t\tvar focusableElements = {\n\t\t\t\ta: true,\n\t\t\t\tbody: true,\n\t\t\t\tbutton: true,\n\t\t\t\tframe: true,\n\t\t\t\tiframe: true,\n\t\t\t\timg: true,\n\t\t\t\tinput: true,\n\t\t\t\tisindex: true,\n\t\t\t\tobject: true,\n\t\t\t\tselect: true,\n\t\t\t\ttextarea: true\n\t\t\t};\n\t\t\tif (!focusableElements[node.nodeName.toLowerCase()] && !node.attributes.tabIndex) {\n\t\t\t\tresult = -1;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* \n\t * Inspired by http://brianwhitmer.blogspot.com/2009/05/jquery-ui-tabbable-what.html\n\t */\n\tfunction firstTabbable(node) {\n\t\tif (_getTabIndex(node) >= 0) {\n\t\t\treturn node;\n\t\t}\n\t\tif (node.hasChildNodes()) {\n\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\n\t\t\t\tvar result = firstTabbable(node.childNodes[i]);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tfunction lastTabbable(node) {\n\t\tif (_getTabIndex(node) >= 0) {\n\t\t\treturn node;\n\t\t}\n\t\tif (node.hasChildNodes()) {\n\t\t\tfor (var i=node.childNodes.length - 1; i>=0; i--) {\n\t\t\t\tvar result = lastTabbable(node.childNodes[i]);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tvar variableRegEx = /\\$\\{([^\\}]+)\\}/;\n\t// Internal helper\n\tfunction processNodes(node, replace) {\n\t\tif (node.nodeType === 3) { // TEXT_NODE\n\t\t\tvar matches = variableRegEx.exec(node.nodeValue);\n\t\t\tif (matches && matches.length > 1) {\n\t\t\t\treplace(node, matches);\n\t\t\t}\n\t\t}\n\t\tif (node.hasChildNodes()) {\n\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\n\t\t\t\tprocessNodes(node.childNodes[i], replace);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Performs substitution of strings into textContent within the given node and its descendants. An occurrence of <code>${n}</code>\n\t * in text content will be replaced with the string <code>messages[n]</code>.\n\t * <p>This function is recommended for binding placeholder text in template-created DOM elements to actual display strings.</p>\n\t * @name orion.webui.littlelib.processTextNodes\n\t * @function\n\t * @param {Node} node The node to perform replacement under.\n\t * @param {String[]} messages The replacement strings.\n\t */\n\tfunction processTextNodes(node, messages) {\n\t\tprocessNodes(node, function(targetNode, matches) {\n\t\t\tvar replaceText = messages[matches[1]] || matches[1];\n\t\t\ttargetNode.parentNode.replaceChild(document.createTextNode(replaceText), targetNode);\n\t\t});\n\t}\n\n\t/**\n\t * Performs substitution of DOM nodes into textContent within the given node and its descendants. An occurrence of <code>${n}</code>\n\t * in text content will be replaced by the DOM node <code>replaceNodes[n]</code>.\n\t * <p>This function is recommended for performing rich-text replacement within a localized string. The use of actual DOM nodes\n\t * avoids the need for embedded HTML in strings.</p>\n\t * @name orion.webui.littlelib.processDOMNodes\n\t * @function\n\t * @param {Node} node The node to perform replacement under.\n\t * @param {Node[]} replaceNodes The replacement nodes.\n\t */\n\tfunction processDOMNodes(node, replaceNodes) {\n\t\tprocessNodes(node, function(targetNode, matches) {\n\t\t\tvar replaceNode = replaceNodes[matches[1]];\n\t\t\tif (replaceNode) {\n\t\t\t\tvar range = document.createRange();\n\t\t\t\tvar start = matches.index;\n\t\t\t\trange.setStart(targetNode, start);\n\t\t\t\trange.setEnd(targetNode, start + matches[0].length);\n\t\t\t\trange.deleteContents();\n\t\t\t\trange.insertNode(replaceNode);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Adds auto-dismiss functionality to the document. When a click event occurs whose <code>target</code> is not a descendant of\n\t * one of the <code>excludeNodes</code>, the <code>dismissFunction</code> is invoked.\n\t * @name orion.webui.littlelib.addAutoDismiss\n\t * @function\n\t * @static\n\t * @param {Node[]} excludeNodes Clicks targeting any descendant of these nodes will not trigger the dismissFunction.\n\t * @param {Function} dismissFunction The dismiss handler.\n\t */\n\t\n\tvar autoDismissNodes = null;\n\n\tfunction addAutoDismiss(excludeNodes, dismissFunction) {\n\t\t// auto dismissal.  Click anywhere else means close.\n\t\tfunction onclick(event) {\n\t\t\tautoDismissNodes.forEach(function(autoDismissNode) {\n\t\t\t\tvar excludeNodeInDocument = false;\n\t\t\t\tvar excluded = autoDismissNode.excludeNodes.some(function(excludeNode) {\n\t\t\t\t\tif(document.body.contains(excludeNode)) {\n\t\t\t\t\t\texcludeNodeInDocument = true;\n\t\t\t\t\t\treturn excludeNode.contains(event.target);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t\tif (excludeNodeInDocument && !excluded) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tautoDismissNode.dismiss(event);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (typeof console !== \"undefined\" && console) { //$NON-NLS-0$\n\t\t\t\t\t\t\tconsole.error(e && e.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tautoDismissNodes = autoDismissNodes.filter(function(autoDismissNode) {\n\t\t\t\t// true if at least one excludeNode is in document.body\n\t\t\t\treturn autoDismissNode.excludeNodes.some(function(excludeNode) {\n\t\t\t\t\treturn document.body.contains(excludeNode);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Hook listener only once\n\t\tif (autoDismissNodes === null) {\n\t\t\tautoDismissNodes = [];\n\t\t\tdocument.addEventListener(\"click\", onclick, true); //$NON-NLS-0$\n\t\t\tif (util.isIOS) {\n\t\t\t\tdocument.addEventListener(\"touchend\", function(event){\n\t\t\t\t\tfunction unhook(){\n\t\t\t\t\t\tevent.target.removeEventListener(\"click\", unhook);\n\t\t\t\t\t}\n\t\t\t\t\tif (event.touches.length === 0) {\n\t\t\t\t\t\t// we need a click eventlistener on the target to have ios really trigger a click\n\t\t\t\t\t\tevent.target.addEventListener(\"click\", unhook);\n\t\t\t\t\t}\t\n\t\t\t\t}, false);\n\t\t\t}\n\t\t}\n\t\t\n\t\tautoDismissNodes.push({excludeNodes: excludeNodes, dismiss: dismissFunction});\n\t}\n\t\n\t/**\n\t * Removes all auto-dismiss nodes which trigger the specified dismiss function.\n\t * \n\t * @name orion.webui.littlelib.removeAutoDismiss\n\t * @function\n\t * @static\n\t * @param {Function} dismissFunction The dismiss function to look for.\n\t */\n\tfunction removeAutoDismiss(dismissFunction) {\n\t\tautoDismissNodes = autoDismissNodes.filter(function(autoDismissNode) {\n\t\t\treturn dismissFunction !== autoDismissNode.dismiss;\n\t\t});\n\t}\n\t\n\t/**\n\t * Returns the parent of the node that has the vertical scroll bar.\n\t * \n\t * @name orion.webui.littlelib.getOffsetParent\n\t * @function\n\t * @static\n\t * @param {Element} node The node to lookup the offset parent\n\t */\n\tfunction getOffsetParent(node) {\n\t\tvar offsetParent = node.parentNode, documentElement = document.documentElement;\n\t\twhile (offsetParent && offsetParent !== documentElement) {\n\t\t\tvar style = window.getComputedStyle(offsetParent, null);\n\t\t\tif (!style) { break; }\n\t\t\tvar overflow = style.getPropertyValue(\"overflow-y\"); //$NON-NLS-0$\n\t\t\tif (overflow === \"auto\" || overflow === \"scroll\") { break; } //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\toffsetParent = offsetParent.parentNode;\n\t\t}\n\t\treturn offsetParent;\n\t}\n\t\n\t/**\n\t * Cancels the default behavior of an event and stops its propagation.\n\t * @name orion.webui.littlelib.stop\n\t * @function\n\t * @static\n\t * @param {Event} event\n\t */\n\tfunction stop(event) {\n\t\tif (window.document.all) { \n\t\t\tevent.keyCode = 0;\n\t\t}\n\t\tif (event.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\t\n\tfunction setFramesEnabled(enable) {\n\t\tvar frames = document.getElementsByTagName(\"iframe\"); //$NON-NLS-0$\n\t\tfor (var i = 0; i<frames.length; i++) {\n\t\t\tframes[i].parentNode.style.pointerEvents = enable ? \"\" : \"none\"; //$NON-NLS-0$\n\t\t}\n\t}\n\n\t/**\n\t * Holds useful <code>keyCode</code> values.\n\t * @name orion.webui.littlelib.KEY\n\t * @static\n\t */\n\tvar KEY = {\n\t\tBKSPC: 8,\n\t\tTAB: 9,\n\t\tENTER: 13,\n\t\tESCAPE: 27,\n\t\tSPACE: 32,\n\t\tPAGEUP: 33,\n\t\tPAGEDOWN: 34,\n\t\tEND: 35,\n\t\tHOME: 36,\n\t\tLEFT: 37,\n\t\tUP: 38,\n\t\tRIGHT: 39,\n\t\tDOWN: 40,\n\t\tINSERT: 45,\n\t\tDEL: 46\n\t};\n\t/**\n\t * Maps a <code>keyCode</code> to <tt>KEY</tt> name. This is the inverse of {@link orion.webui.littlelib.KEY}.\n\t * @private\n\t */\n\tvar KEY_CODE = Object.create(null);\n\tObject.keys(KEY).forEach(function(name) {\n\t\tKEY_CODE[KEY[name]] = name;\n\t});\n\n\t/**\n\t * @param {Number} keyCode\n\t * @returns The name of the <code>lib.KEY</code> entry for keyCode, or null.\n\t */\n\tfunction keyName(keyCode) {\n\t\treturn KEY_CODE[keyCode] || null;\n\t}\n\n\t/**\n\t * Creates DOM nodes from the specified template string.\n\t * \n\t * @param {String} templateString \tA string containing the HTML template to use\n\t * @param {Node} parentNode \t\tOptional. The parent node to insert the new nodes into. \n\t * \t\t\t\t\t\t\t\t\tThe parent's contents will be completely replaced.\n\t * @returns If the template string contains a single node or a wrapper node which\n\t * \t\t\twraps all the other nodes that single DOM node will be returned. \n\t * \t\t\tOtherwise if the template string contains multiple top-level nodes an\n\t * \t\t\t{HTMLCollection} object containing all the top-level nodes will be returned.\n\t */\n\tfunction createNodes(templateString, parentNode) {\n\t\tvar parent = parentNode;\n\t\tvar newNodes = null;\n\t\t\n\t\tif (undefined === parent) {\n\t\t\tparent = document.createElement(\"div\"); //$NON-NLS-0$\n\t\t}\n\n\t\tparent.innerHTML = templateString;\t\n\t\tif (parent.children.length > 1) {\n\t\t\tnewNodes = parent.children;\n\t\t} else {\n\t\t\tnewNodes = parent.firstChild;\n\t\t}\n\t\t\n\t\treturn newNodes;\n\t}\n\n\t//return module exports\n\treturn {\n\t\t$: $,\n\t\t$$: $$,\n\t\t$$array: $$array,\n\t\tnode: node,\n\t\tcontains: contains,\n\t\tbounds: bounds,\n\t\tempty: empty,\n\t\tfirstTabbable: firstTabbable,\n\t\tlastTabbable: lastTabbable,\n\t\tstop: stop,\n\t\tprocessTextNodes: processTextNodes,\n\t\tprocessDOMNodes: processDOMNodes,\n\t\taddAutoDismiss: addAutoDismiss,\n\t\tsetFramesEnabled: setFramesEnabled,\n\t\tgetOffsetParent: getOffsetParent,\n\t\tremoveAutoDismiss: removeAutoDismiss,\n\t\tkeyName: keyName,\n\t\tKEY: KEY,\n\t\tcreateNodes: createNodes\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2015 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd, node*/\ndefine(\"orion/editor/tooltip\", [ //$NON-NLS-0$\n\t'i18n!orion/editor/nls/messages', //$NON-NLS-0$\n\t'orion/editor/textView', //$NON-NLS-0$\n\t'orion/editor/projectionTextModel', //$NON-NLS-0$\n\t'orion/Deferred', //$NON-NLS-0$\n\t'orion/editor/util', //$NON-NLS-0$\n\t'orion/webui/littlelib', //$NON-NLS-0$\n\t'orion/util' //$NON-NLS-0$\n], function(messages, mTextView, mProjectionTextModel, Deferred, textUtil, lib, util) {\n\n/**\n * @name Tooltip\n * @description Tooltip support for text views\n * \n * show() - Opens the tooltip\n * update() - Updates the content of the open tooltip\n * onHover() - Checks if the x,y coordinates are outside the current tooltip area and updates the tooltip if necessary\n * hide() - Closes the tooltip\n * isVisible() - Returns whether the tooltip is currently showing\n * \n * The methods above ask for a tooltipInfo object, which must contain a callback function getTooltipInfo()\n * This function must return an info object with the following contents:\n * \n * Info {\n * \tContents {string, html element, annotation array, etc.} Contents to display, if undefined, the hover service will be asked for content\n * \tContext {source, offset, offsetStart, offsetEnd}} Information used to modify the tooltip position or contents\n * \tPosition {String} One of left, right, top, bottom used to position the tooltip relative to the anchor area\n * \tAnchorArea {x, y, width, height} rectangle defining the source of the tooltip and where to position relative to\n * \tTooltipArea {x, y, width, height} rectangle to define the tooltip's exact placement rather than a relative position to the anchor\n * \tTooltipOffsetX {Number} Hint to move the tooltip position horizontally\n * \tTooltipOffsetY {Number} Hint to move the tooltip position vertically\n * \n * @param view\n */\nfunction Tooltip (view) {\n\t\tthis._view = view;\n\t\tvar parent = view.getOptions(\"parent\"); //$NON-NLS-0$\n\t\tthis._create(parent ? parent.ownerDocument : document);\n\t}\n\tTooltip.getTooltip = function(view) {\n\t\tif (!view._tooltip) {\n\t\t\t view._tooltip = new Tooltip(view);\n\t\t}\n\t\treturn view._tooltip;\n\t};\n\tTooltip.prototype = /** @lends orion.editor.Tooltip.prototype */ {\n\t\t_create: function(document) {\n\t\t\tif (this._tooltipDiv) { return; }\n\t\t\tvar tooltipDiv = this._tooltipDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\ttooltipDiv.tabIndex = 0;\n\t\t\ttooltipDiv.className = \"textviewTooltip\"; //$NON-NLS-0$\n\t\t\ttooltipDiv.setAttribute(\"aria-live\", \"assertive\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttooltipDiv.setAttribute(\"aria-atomic\", \"true\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tthis._tooltipDiv.style.visibility = \"hidden\"; //$NON-NLS-0$\n\t\t\tdocument.body.appendChild(tooltipDiv);\n\t\t\tvar self = this;\n\t\t\ttextUtil.addEventListener(document, \"mousedown\", this._mouseDownHandler = function(event) { //$NON-NLS-0$\n\t\t\t\tif (!self.isVisible()) { return; }\n\t\t\t\tif (textUtil.contains(tooltipDiv, event.target || event.srcElement)) { return; }\n\t\t\t\tif (!self._locked){\n\t\t\t\t\tself.hide();\n\t\t\t\t}\n\t\t\t}, true);\n\t\t\ttextUtil.addEventListener(document, \"mousemove\", this._mouseMoveHandler = function(event) { //$NON-NLS-0$\n\t\t\t\tif (!self.isVisible() || self._locked || self._hasFocus()) { return; }\n\t\t\t\tif (self._isInRect(self._outerArea, event.clientX, event.clientY)){ return; }\n\t\t\t\tself.hide();\n\t\t\t}, true);\n\t\t\ttextUtil.addEventListener(tooltipDiv, \"focus\", /* @callback */ function(event) { //$NON-NLS-0$\n\t\t\t\tif (!self._locked){\n\t\t\t\t\tself._tooltipDiv.classList.add('textViewTooltipOnFocus'); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}, false);\n\t\t\ttextUtil.addEventListener(tooltipDiv, \"blur\", /* @callback */ function(event) { //$NON-NLS-0$\n\t\t\t\tself._tooltipDiv.classList.remove('textViewTooltipOnFocus'); //$NON-NLS-0$\n\t\t\t}, false);\n\t\t\ttextUtil.addEventListener(tooltipDiv, \"mouseenter\", /* @callback */ function(event) { //$NON-NLS-0$\n\t\t\t\tif (!self._locked){\n\t\t\t\t\tself._tooltipDiv.classList.add('textViewTooltipOnHover'); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}, false);\n\t\t\ttextUtil.addEventListener(tooltipDiv, \"mouseleave\", /* @callback */ function(event) { //$NON-NLS-0$\n\t\t\t\tif (!self._hasFocus()){\n\t\t\t\t\tself._tooltipDiv.classList.remove('textViewTooltipOnHover'); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}, false);\n\t\t\ttextUtil.addEventListener(tooltipDiv, \"keydown\", function(event) { //$NON-NLS-0$\n\t\t\t\tif (event.keyCode === 27) {\n\t\t\t\t\tif (!self._locked){\n\t\t\t\t\t\tself.hide();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, false);\n\t\t\tthis._view.addEventListener(\"Destroy\", function() { //$NON-NLS-0$\n\t\t\t\tself.destroy();\n\t\t\t});\n\t\t},\n\t\tdestroy: function() {\n\t\t\tif (!this._tooltipDiv) { return; }\n\t\t\tthis.hide();\n\t\t\tvar parent = this._tooltipDiv.parentNode;\n\t\t\tif (parent) { parent.removeChild(this._tooltipDiv); }\n\t\t\tvar doc = this._tooltipDiv.ownerDocument;\n\t\t\ttextUtil.removeEventListener(doc, \"mousedown\", this._mouseDownHandler, true); //$NON-NLS-0$\n\t\t\ttextUtil.removeEventListener(doc, \"mousemove\", this._mouseMoveHandler, true); //$NON-NLS-0$\n\t\t\tthis._tooltipDiv = null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name show\n\t\t * @description Show the tooltip using the given target information\n\t\t * @function\n\t\t * @param target The target through which the info is obtained\n\t\t * @param locked If true locks the tooltip (never hides unless 'hide' is called)\n\t\t * @param giveFocus If true forces the focus onto the tooltip (used for F2 processing)\n\t\t */\n\t\tshow: function(tooltipInfo, locked, giveFocus) {\n\t\t\tthis._locked = locked;\n\t\t\tthis._giveFocus = giveFocus;\n\t\t\tthis._processInfo(tooltipInfo.getTooltipInfo());\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name update\n\t\t * @description Updates the information in an already visible tooltip\n\t\t * @function\n\t\t * @param target The target through which the info is obtained\n\t\t * @param locked If true locks the tooltip (never hides unless 'hide' is called)\n\t\t * @param giveFocus If true forces the focus onto the tooltip (used for F2 processing)\n\t\t */\n\t\tupdate: function(tooltipInfo) {\n\t\t\tif (!tooltipInfo){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._processInfo(tooltipInfo.getTooltipInfo(), true);\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name onHover\n\t\t * @description Show the tooltip using the given target information. Only called for hover events.\n\t\t * @function\n\t\t * @param target\n\t\t * @param giveFocus\n\t\t */\n\t\tonHover: function(tooltipInfo, x, y) {\n\t\t\tif (!tooltipInfo) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Don't process if we're in the anchor or tooltip\n\t\t\tif (this._isInRect(this._anchorArea, x, y)\n\t\t\t\t\t|| this._isInRect(this._tooltipArea, x, y)\n\t\t\t\t\t|| this._locked\n\t\t\t\t\t|| this._hasFocus()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis._processInfo(tooltipInfo.getTooltipInfo());\n\t\t},\t\t\n\t\n\t\t/**\n\t\t * @name hide\n\t\t * @description Hides the current tooltip (if it's showing)\n\t\t * @function\n\t\t * @public\n\t\t*/\n\t\thide: function() {\n\t\t\tif (!this.isVisible()){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\t\n\t\t\tif (this.hover) {\n\t\t\t\tthis.hover.clearQuickFixes();\n\t\t\t}\n\n\t\t\tif (this._hasFocus()) {\n\t\t\t\tthis._view.focus();\n\t\t\t}\n\t\t\tif (this._contentsView) {\n\t\t\t\tthis._contentsView.destroy();\n\t\t\t\tthis._contentsView = null;\n\t\t\t}\n\t\t\tif (this._tooltipContents) {\n\t\t\t\tthis._tooltipDiv.removeChild(this._tooltipContents);\n\t\t\t\tthis._tooltipContents = null;\n\t\t\t}\n\t\t\t\n\t\t\t// Code projections are displayed using the editor theme colors\n\t\t\tthis._tooltipDiv.classList.remove(\"textviewTooltipCodeProjection\"); //$NON-NLS-0$\n\t\t\tthis._tooltipDiv.classList.remove(\"textviewTooltipOnHover\"); //$NON-NLS-0$\n\t\t\tthis._tooltipDiv.classList.remove(\"textviewTooltipOnFocus\"); //$NON-NLS-0$\n\t\t\t\n\t\t\tthis._tooltipDiv.style.visibility = \"hidden\"; //$NON-NLS-0$\n\t\t\tthis._tooltipDiv.style.left = \"\";\n\t\t\tthis._tooltipDiv.style.right = \"\";\n\t\t\tthis._tooltipDiv.style.top = \"\";\n\t\t\tthis._tooltipDiv.style.bottom = \"\";\n\t\t\tthis._tooltipDiv.style.width = \"auto\";\t\t //$NON-NLS-0$\n\t\t\tthis._tooltipDiv.style.maxWidth = \"\";\n\t\t\tthis._tooltipDiv.style.height = \"auto\";\t\t //$NON-NLS-0$\t\n\t\t\tthis._tooltipDiv.style.maxHeight = \"\";\t\t //$NON-NLS-0$\n\t\t\tthis._tooltipDiv.style.overflowX = \"\";\t\t //$NON-NLS-0$\t\n\t\t\tthis._tooltipDiv.style.overflowY = \"\";\t\t //$NON-NLS-0$\t\n\t\t\t\n\t\t\tthis._giveFocus = undefined;\n\t\t\tthis._locked = undefined;\n\t\t\t\n\t\t\tthis._anchorArea = undefined;  // Area of text/ruler/etc. we are showing a tooltip for\n\t\t\tthis._tooltipArea = undefined;  // The area the tooltip covers\n\t\t\tthis._outerArea = undefined; // The rectangle encapsulating both anchor and tooltip areas where we want to keep the tooltip open\n\t\t\t\n\t\t\t// cancel any outstanding defers\n\t\t\tif (this._hoverPromises) {\n\t\t\t\tthis._hoverPromises.forEach(function(info) {\n\t\t\t\t\tif (!info.resolved) {\n\t\t\t\t\t\tinfo.cancel();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis._hoverPromises = undefined;\n\t\t\t\n\t\t\t// values that are calculated\n\t\t\tthis._tipRect = undefined;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name isVisible\n\t\t * @description Returns a boolean indicating whether the tooltip is currently visible\n\t\t * @function\n\t\t * @public\n\t\t * @returns {boolean} 'true' iff the tooltip is currently visible\n\t\t*/\n\t\tisVisible: function() {\n\t\t\treturn this._tooltipDiv && this._tooltipDiv.style.visibility === \"visible\"; //$NON-NLS-0$\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name _processInfo\n\t\t * @description Renders the content, positions the tooltip then makes the tooltip visible\n\t\t * @function\n\t\t * @private\n\t\t * @param info {Object} The info object passed by the caller\n\t\t * \n\t\t * Info:\n\t\t * 1) Contents\n\t\t * 2) Context\n\t\t * 3) Position string left, right, top, bottom\n\t\t * 4) AnchorArea x, y, width, height\n\t\t * 5) TooltipArea x, y, width, height\n\t\t * 6) TooltipOffsetX\n\t\t * 7) TooltipOffsetY\n\t\t * 8) AllowFullWidth\n\t\t * \n\t\t * @param update Whether to update the existing tooltip contents or open a new tooltip\n\t\t */\n\t\t_processInfo: function(info, update) {\n\t\t\tif (!this._tooltipDiv){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvar newTooltipContents;\n\t\t\tif (update && this._tooltipContents) {\n\t\t\t\tthis._tooltipContents.innerHTML = \"\";\n\t\t\t\tnewTooltipContents = this._tooltipContents;\n\t\t\t} else {\n \t\t\t\tnewTooltipContents = util.createElement(this._tooltipDiv.ownerDocument, \"div\"); //$NON-NLS-0$\n \t\t\t}\n \t\t\t\n\t\t\tif (info) {\n\t\t\t\t// Render provided content\n\t\t\t\tif (info.contents) {\n\t\t\t\t\tif (this._renderImmediateInfo(newTooltipContents, info.contents, info.context)) {\n\t\t\t\t\t\tthis._showContents(newTooltipContents, info, update);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// If no immediate content, check if hover service plug-ins have content\n\t\t\t\tif (this.hover && info.context){\n\t\t\t\t\tthis._hoverPromises = this.hover.computeHoverInfo(info.context);\n\t\t\t\t\tif (this._hoverPromises) {\n\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\tvar promises = this._hoverPromises.slice(0);\n\t\t\t\t\t\tpromises.forEach(function(hoverPromise) {\n\t\t\t\t\t\t\tDeferred.when(hoverPromise, function (data) {\n\t\t\t\t\t\t\t\t// Remove this promise from the list so we don't try cancelling it while processing (see hide())\n\t\t\t\t\t\t\t\tif (self._hoverPromises){\n\t\t\t\t\t\t\t\t\tvar index = self._hoverPromises.indexOf(hoverPromise);\n\t\t\t\t\t\t\t\t\tif (index >= 0){\n\t\t\t\t\t\t\t\t\t\tself._hoverPromises.splice(index, 1);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\t\t\tif (self._renderPluginContent(newTooltipContents, data)) {\n\t\t\t\t\t\t\t\t\t\tif (data.offsetStart){\n\t\t\t\t\t\t\t\t\t\t\tinfo.context.offsetStart = data.offsetStart;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (data.offsetEnd){\n\t\t\t\t\t\t\t\t\t\t\tinfo.context.offsetEnd = data.offsetEnd;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (data.allowFullWidth){\n\t\t\t\t\t\t\t\t\t\t\tinfo.allowFullWidth = data.allowFullWidth;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tself._showContents(newTooltipContents, info, update);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, function(error) {\n\t\t\t\t\t\t\t\tif (console && error && error.name !== 'Cancel') { //$NON-NLS-0$ //$NON-NLS-1$\n\t\t\t\t\t\t\t\t\tconsole.log(\"Error computing hover tooltip\"); //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\tconsole.log(error && error.stack);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @name _showContents\n\t\t * @description Takes the rendered contents, positions the tooltip, opens the tooltip\n\t\t * @function\n\t\t * @private\n\t\t * @param newContentsDiv\n\t\t * @param info\n\t\t * @param update\n\t\t */\n\t\t_showContents: function _showContents(newContentsDiv, info, update) {\n\t\t\tif (!update){\n\t\t\t\tthis.hide();\n\t\t\t} else {\n\t\t\t\t// If update is called but the set tooltip area is different, recreate the tooltip with the new sizing (ex: content assist resizing)\n\t\t\t\t// We could also check if the set anchor area is different, but no one would be using it\n\t\t\t\tif (this._tooltipArea && info.tooltipArea){\n\t\t\t\t\tif (this._tooltipArea.left !== info.tooltipArea.left || this._tooltipArea.top !== info.tooltipArea.top || this._tooltipArea.width !== info.tooltipArea.width || this._tooltipArea.height !== info.tooltipArea.height){\n\t\t\t\t\t\tthis._anchorArea = null;\n\t\t\t\t\t\tthis._tooltipArea = null;\n\t\t\t\t\t\tthis._outerArea = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis._tooltipContents = newContentsDiv;\n\t\t\tthis._tooltipDiv.appendChild(newContentsDiv);\n\t\t\t\n\t\t\tif (!this._anchorArea){\n\t\t\t\tthis._anchorArea = this._computeAnchorArea(info);\n\t\t\t}\n\t\t\tif (!this._tooltipArea){\n\t\t\t\t// This function performs two tasks, computing the rectangle and setting all the style properties\n\t\t\t\tthis._tooltipArea = this._computeTooltipArea(info, this._anchorArea, this._tooltipDiv);\n\t\t\t}\n\t\t\tif (!this._outerArea){\n\t\t\t\tthis._outerArea = this._computeOuterArea(this._anchorArea, this._tooltipArea);\n\t\t\t}\n\n\t\t\tthis._tooltipDiv.style.visibility = \"visible\"; //$NON-NLS-0$\n\t\t\t\n\t\t\tif (this._giveFocus) {\n\t\t\t\tthis._setInitialFocus(this._tooltipDiv);\n\t\t\t\tthis._giveFocus = undefined;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name _computeAnchorArea\n\t\t * @description Computes and returns the rectangle that the tooltip is anchored to.  For example the anchor for an annotation \n\t\t * \t\t\t\tmay be its text range.\n\t\t * @function\n\t\t * @private\n\t\t * @param info {Object} the info object passed by the caller.\n\t\t * @returns returns the computed rectangle anchor area\n\t\t */\n\t\t_computeAnchorArea: function _computeAnchorArea(info){\n\t\t\tif (info.anchorArea){\n\t\t\t\tif (info.anchorArea.top && info.anchorArea.left && info.anchorArea.height && info.anchorArea.width){\n\t\t\t\t\treturn info.anchorArea;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (info.context){\n\t\t\t\tif (info.context.offsetStart && info.context.offsetEnd){\n\t\t\t\t\treturn this._computeRectangleFromOffset(info.context.offsetStart, info.context.offsetEnd);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (info.context.offset >= 0){\n\t\t\t\t\t// Use the enclosing word\n\t\t\t\t\tvar start = this._view.getNextOffset(info.context.offset, { unit: \"word\", count: -1}); //$NON-NLS-0$\n\t\t\t\t\tvar end = this._view.getNextOffset(info.context.offset, { unit: \"word\", count: 0}); //$NON-NLS-0$\n\t\t\t\t\treturn this._computeRectangleFromOffset(start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn {top: 0, left: 0, height: 0, width: 0};\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name _computeTooltipPosition\n\t\t * @description Defines the tooltip area and placement.  Returns the rectangle defining the tooltip area and sets the tooltipDiv\n\t\t * \t\t\t\tstyle to match the rectangles values.\n\t\t * @param info the tooltip info object passed by the caller\n\t\t * @param anchorArea the computed tooltip anchor area to which the tooltip will be positioned\n\t\t * @param tooltipDiv the div for the tooltip, this function will modify its style to match the computed position/size\n\t\t * @returns returns the computed tooltip area rectangle\n\t\t * @function\n\t\t * @private\n\t\t */\n\t\t_computeTooltipArea: function _computeTooltipArea(info, anchorArea, tooltipDiv){\n\t\t\tvar documentElement = tooltipDiv.ownerDocument.documentElement;\n\t\t\t\n\t\t\t// TODO This padding must match what is in tooltip.css\n\t\t\tvar padding = 16;\n\t\t\t\n\t\t\t// Callers can specify the exact placement of the tooltip\n\t\t\tif (info.tooltipArea && info.tooltipArea.top && info.tooltipArea.left && info.tooltipArea.height && info.tooltipArea.width){\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\ttooltipDiv.style.overflowY = \"auto\"; //$NON-NLS-0$ // If caller specifies a height, allow scrolling\n\t\t\t\t\ttooltipDiv.style.resize = \"none\"; //$NON-NLS-0$\n\t\t\t\t\ttooltipDiv.style.top = (info.tooltipArea.top) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\ttooltipDiv.style.left = (info.tooltipArea.left) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\ttooltipDiv.style.height = (info.tooltipArea.height - padding) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\ttooltipDiv.style.width = (info.tooltipArea.width - padding) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\treturn info.tooltipArea;\n\t\t\t}\n\t\t\t\n\t\t\tvar divBounds = tooltipDiv.getBoundingClientRect();\n\t\t\tvar tipRect = {\n\t\t\t\twidth: divBounds.width,\n\t\t\t\theight: divBounds.height\n\t\t\t};\n\t\t\t\n\t\t\tvar position = info.position ? info.position : \"below\"; //$NON-NLS-0$\n\t\t\t\n\t\t\tvar viewBounds = (this._view._rootDiv ? this._view._rootDiv : documentElement).getBoundingClientRect();\n\t\t\tvar viewportLeft = viewBounds.left;\n\t\t\tvar viewportTop = viewBounds.top;\n\t\t\tvar viewportWidth = viewBounds.width;\n\t\t\tvar viewportHeight = viewBounds.height;\n\t\t\t\n\t\t\t// Set a default size for the tooltip\n\t\t\tvar defWidth = viewportWidth;\n\t\t\tif (!info.allowFullWidth){\n\t\t\t\tdefWidth = Math.min(viewportWidth/2, 600);\n\t\t\t\tvar defHeight = Math.min(viewportHeight/2, 400);\n\t\t\t\ttipRect.width = Math.min(tipRect.width, defWidth);\n\t\t\t\ttipRect.height = Math.min(tipRect.height, defHeight);\n\t\t\t}\n\t\t\t\n\t\t\t// Hack for single line tooltips that wrap, set a minimum height to make them show 2 lines without scrolling\n\t\t\t// The largest line height was MacOS Chrome with 20px+padding.  So 25 is the minimum height we are sure we are one two lines\n\t\t\t// Similarly, the minimum height for the tooltip is two lines (20px x 2 + padding) (this will actually show three lines on Win7 Chrome)\n\t\t\tif ((25+padding) > tipRect.height && tipRect.width > (defWidth-padding)){\n\t\t\t\ttipRect.height = 40+padding;\n\t\t\t}\n\n\t\t\tvar spaceBelow = viewportHeight - (anchorArea.top + anchorArea.height - viewportTop);\n\t\t\tvar spaceAbove = anchorArea.top - viewportTop;\n\t\t\tvar spaceRight = viewportWidth - (anchorArea.left + anchorArea.width - viewportLeft);\n\t\t\t\n\t\t\t// If there is not enough space above or below, swap the position.  Can't do the same for right/left because rulers are at client bounds\n\t\t\tif (position === \"above\" && tipRect.height > spaceAbove && tipRect.height <= spaceBelow){ //$NON-NLS-0$\n\t\t\t\tposition = \"below\"; //$NON-NLS-0$\n\t\t\t} else if (position === \"below\" && tipRect.height > spaceBelow && tipRect.height <= spaceAbove){ //$NON-NLS-0$\n\t\t\t\tposition = \"above\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\t\n\t\t\tvar offsetX = info.tooltipOffsetX ? info.tooltipOffsetX : 0;\n\t\t\tvar offsetY = info.tooltipOffsetY ? info.tooltipOffsetY : 0;\n\t\t\t\n\t\t\t// Attempt to line up tooltip with the anchor area\n\t\t\t// If not enough space, shift the tooltip horiz (above/below) or vert (left/right) until it fits\n\t\t\t// Force the tooltip to start within the viewport area\n\t\t\t// Set maximum sizes for remaining area in the viewport area\n\t\t\tswitch (position){\n\t\t\t\tcase \"left\": //$NON-NLS-0$\n\t\t\t\t\tif ((tipRect.height + offsetY) > (spaceBelow + anchorArea.height)){\n\t\t\t\t\t\t// Shift the top of the tooltip upwards to fit, ignore the offset value\n\t\t\t\t\t\ttipRect.top = viewportHeight + viewportTop - tipRect.height;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttipRect.top = anchorArea.top + offsetY;\n\t\t\t\t\t}\n\t\t\t\t\ttipRect.top = Math.max(tipRect.top, viewportTop);\n\t\t\t\t\ttipRect.left = Math.max(anchorArea.left - tipRect.width + offsetX, viewportLeft);\n\t\t\t\tbreak;\n\t\t\t\tcase \"right\": //$NON-NLS-0$\n\t\t\t\t\tif ((tipRect.height + offsetY) > (spaceBelow + anchorArea.height)){\n\t\t\t\t\t\t// Shift the top of the tooltip upwards to fit, ignore the offset value\n\t\t\t\t\t\ttipRect.top = viewportHeight + viewportTop - tipRect.height;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttipRect.top = anchorArea.top + offsetY;\n\t\t\t\t\t}\n\t\t\t\t\ttipRect.top = Math.max(tipRect.top, viewportTop);\n\t\t\t\t\ttipRect.left = Math.max(anchorArea.left + anchorArea.width + offsetX, viewportLeft);\n\t\t\t\tbreak;\n\t\t\t\tcase \"above\": //$NON-NLS-0$\n\t\t\t\t\tif ((tipRect.width + offsetX) > (spaceRight + anchorArea.width)){\n\t\t\t\t\t\t// Shift the left side of the tooltip to the left, ignore the offset value\n\t\t\t\t\t\ttipRect.left = viewportWidth + viewportLeft - tipRect.width;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttipRect.left = anchorArea.left + offsetX;\n\t\t\t\t\t}\n\t\t\t\t\ttipRect.left = Math.max(tipRect.left, viewportLeft);\n\t\t\t\t\ttipRect.top = Math.max(anchorArea.top - tipRect.height + offsetY, viewportTop);\n\t\t\t\tbreak;\n\t\t\t\tcase \"below\": //$NON-NLS-0$\n\t\t\t\t\tif ((tipRect.width + offsetX) > (spaceRight + anchorArea.width)){\n\t\t\t\t\t\t// Shift the left side of the tooltip to the left, ignore the offset value\n\t\t\t\t\t\ttipRect.left = viewportWidth + viewportLeft - tipRect.width;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttipRect.left = anchorArea.left + offsetX;\n\t\t\t\t\t}\n\t\t\t\t\ttipRect.left = Math.max(tipRect.left, viewportLeft);\n\t\t\t\t\ttipRect.top = Math.max(anchorArea.top + anchorArea.height + offsetY, viewportTop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ttipRect.maxWidth = Math.min(viewportWidth + viewportLeft - tipRect.left, viewportWidth);\n\t\t\ttipRect.maxHeight = Math.min(viewportHeight + viewportTop - tipRect.top, viewportHeight);\n\t\t\t\n\t\t\t// Adjust sizes for div padding, but not the actual tooltip box.\n\t\t\ttooltipDiv.style.maxWidth = (tipRect.maxWidth - padding) + \"px\"; //$NON-NLS-0$\n\t\t\ttooltipDiv.style.maxHeight = (tipRect.maxHeight - padding) + \"px\"; //$NON-NLS-0$\n\t\t\ttooltipDiv.style.width = (tipRect.width - padding) + \"px\"; //$NON-NLS-1$\n\t\t\ttooltipDiv.style.height = (tipRect.height - padding) + \"px\"; //$NON-NLS-1$\n\t\t\ttooltipDiv.style.left = tipRect.left + \"px\"; //$NON-NLS-0$\n\t\t\ttooltipDiv.style.top = tipRect.top + \"px\"; //$NON-NLS-0$\n\t\t\treturn tipRect;\n\t\t},\n\t\t\n\t\t_computeOuterArea: function _computeOuterArea(anchorArea, tooltipArea){\n\t\t\tvar left = Math.min(anchorArea.left, tooltipArea.left);\n\t\t\tvar top = Math.min(anchorArea.top, tooltipArea.top);\n\t\t\tvar positionRight = anchorArea.left + anchorArea.width;\n\t\t\tvar tipRight = tooltipArea.left + tooltipArea.width;\n\t\t\tvar right = Math.max(positionRight, tipRight);\n\t\t\tvar positionBottom = anchorArea.top + anchorArea.height;\n\t\t\tvar tipBottom = tooltipArea.top + tooltipArea.height;\n\t\t\tvar bottom = Math.max(positionBottom, tipBottom);\n\t\t\t\t\n\t\t\treturn {\n\t\t\t\t\tleft: left,\n\t\t\t\t\ttop : top,\n\t\t\t\t\twidth: right - left,\n\t\t\t\t\theight: bottom - top\n\t\t\t\t};\n\t\t},\n\t\t\n\t\t/*\n\t\t ******************************************************************************************************************* \n\t\t * Utility: This section contains various utility methods\n\t\t ******************************************************************************************************************* \n\t\t */\n\t\t_hasFocus: function() {\n\t\t\tvar tooltipDiv = this._tooltipDiv;\n\t\t\tif (!tooltipDiv) { return false; }\n\t\t\treturn textUtil.contains(tooltipDiv, tooltipDiv.ownerDocument.activeElement);\n\t\t},\n\t\t_isNode: function (obj) {\n\t\t\treturn typeof Node === \"object\" ? obj instanceof Node : //$NON-NLS-0$\n\t\t\t\tobj && typeof obj === \"object\" && typeof obj.nodeType === \"number\" && typeof obj.nodeName === \"string\"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t},\n\t\t_setInitialFocus: function(tooltipDiv) {\n\t\t\t// Any buttons ?\n\t\t\tvar button = lib.$(\"button\", tooltipDiv); //$NON-NLS-0$\n\t\t\tif (button) {\n\t\t\t\tbutton.focus();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Any links ?\n\t\t\tvar link = lib.$(\"a\", tooltipDiv); //$NON-NLS-0$\n\t\t\tif (link) {\n\t\t\t\tlink.focus();\n\t\t\t\tvar self = this;\n\t\t\t\tlink.addEventListener(\"click\", function() { //$NON-NLS-0$\n\t\t\t\t\tself.hide();\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Give up and focus on the first tabbable\n\t\t\tvar toFocus = lib.firstTabbable(tooltipDiv);\n\t\t\tif (toFocus) {\n\t\t\t\ttoFocus.focus();\n\t\t\t}\n\t\t},\n\t\t_isInRect: function(rect, x, y) {\n\t\t\tif (!rect){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar xOK = x >= rect.left && x <= (rect.left + rect.width);\n\t\t\tvar yOK = y >= rect.top && y <= (rect.top + rect.height);\n\t\t\treturn xOK && yOK;\n\t\t},\n\t\tmapOffset: function(offset, parent) {\n\t\t\tvar textView = this._view;\n\t\t\tvar model = textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\toffset = model.mapOffset(offset, parent);\n\t\t\t}\n\t\t\treturn offset;\n\t\t},\n\t\t_computeRectangleFromOffset: function(start, end) {\n\t\t\t// The offsets from annotations/hovering don't account for the projection model (folded comments) Bug 456715\n\t\t\tstart = this.mapOffset(start);\n\t\t\tend = this.mapOffset(end);\n\t\t\t\n\t\t\tvar tv = this._view;\n\t\t\tvar curLine = tv.getLineAtOffset(start);\n\t\t\tvar endLine = tv.getLineAtOffset(end);\n\t\t\t\n\t\t\t// Adjust start / end to be on the current line if necessary\n\t\t\tif (curLine !== endLine) {\n\t\t\t\t// 'getLineEnd' isn't API in textView but is in textModel...\n\t\t\t\tend = tv.getModel().getLineEnd(curLine);\n\t\t\t}\n\t\t\t\n\t\t\tvar height = tv.getLineHeight(curLine);\n\t\t\tvar startPos = tv.getLocationAtOffset(start);\n\t\t\tvar endPos = tv.getLocationAtOffset(end);\n\t\t\t\n\t\t\tvar viewRect = { x: startPos.x, y: startPos.y, \n\t\t\t\t\t\t\t\twidth: endPos.x - startPos.x, height: height};\n\t\t\t\t\t\t\t\t\n\t\t\tviewRect = this._view.convert(viewRect, \"document\", \"page\"); //$NON-NLS-0$ //$NON-NLS-1$\n\t\t\treturn {left: viewRect.x, top: viewRect.y, width: viewRect.width, height: viewRect.height};\n\t\t},\n\t\t/*\n\t\t ******************************************************************************************************************* \n\t\t * Rendering: This section deals with rendering supplied data into HTML for inclusion into the Info Popup.\n\t\t ******************************************************************************************************************* \n\t\t */\n\t\t_renderPluginContent: function(contentsDiv, data) {\n\t\t\tvar document = this._tooltipDiv.ownerDocument;\n\t\t\t// data object should be an object containing the type and content.  If no type or unknown type, default to string.\n\t\t\tif (typeof data !== 'string' && typeof data.content === 'undefined') { //$NON-NLS-0$ //$NON-NLS-1$\n\t\t\t    return false;\n\t\t\t}\n\t\t\t\n\t\t\tvar sectionDiv = util.createElement(document, \"div\"); //$NON-NLS-0$;\n\t\t\t// render the title, if any\n\t\t\tif (data.title) {\n\t\t\t\tvar titleDiv = util.createElement(document, \"div\"); //$NON-NLS-0$;\n\t\t\t\ttitleDiv.innerHTML = this.hover.renderMarkDown ? this.hover.renderMarkDown(data.title) : data.title;\n\t\t\t\tsectionDiv.appendChild(titleDiv);\n\t\t\t}\n\t\t\tvar contentDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\n\t\t\tif (typeof data === 'string'){ //$NON-NLS-0$\n\t\t\t\tcontentDiv.appendChild(document.createTextNode(data));\n\t\t\t} else {\n\t\t\t\tswitch(data.type) { //$NON-NLS-0$\n\t\t\t\t\tcase 'delegatedUI': { //$NON-NLS-0$\n\t\t\t\t\t\t// The delegated UI is not included in the 8.0 release, see Bug 449240.\n\t\t\t\t\t}\n\t\t\t\t\tcase 'html': { //$NON-NLS-0$\n\t\t\t\t\t\tif (data.content){\n\t\t\t\t\t\t\tvar iframe = document.createElement(\"iframe\"); //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.id = 'HtmlHover'; //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.name = 'HTML Hover'; //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.type = \"text/html\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.sandbox = \"allow-scripts allow-same-origin allow-forms\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.style.border = \"none\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.style.width = \"100%\"; //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.style.height = \"100%\"; //$NON-NLS-0$\n\t\t\t\t\t\t\t// TODO The iframe computed height is always 3px smaller than the tooltip, giving the impression of inconsistent padding\n\t\t\t\t\t\t\tthis._tooltipDiv.style.paddingBottom = \"5px\";  //$NON-NLS-0$\n\t\t\t\t\t\t\tiframe.srcdoc = data.content;\n\t\t\t\t\t\t\tif (data.width) {\n\t\t\t\t\t\t\t\tiframe.style.width = data.width;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (data.height) {\n\t\t\t\t\t\t\t\tiframe.style.height = data.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsectionDiv.style.height = '100%';  //$NON-NLS-0$ // Height should grow on resize\n\t\t\t\t\t\t\tcontentsDiv.style.height = '100%';  //$NON-NLS-0$\n\t\t\t\t\t\t\tsectionDiv.appendChild(iframe);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'markdown': { //$NON-NLS-0$\n\t\t\t\t\t\tif (this.hover.renderMarkDown) {\n\t\t\t\t\t\t\tcontentDiv.innerHTML = this.hover.renderMarkDown(data.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tcontentDiv.appendChild(document.createTextNode(data.content));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsectionDiv.appendChild(contentDiv);\n\t\t\tcontentsDiv.appendChild(sectionDiv);\n\t\t\treturn true;\n\t\t},\n\t\t/*\n\t\t * Empty or empty array = call hover service for dynamic content\n\t\t * Array = annotations\n\t\t * String = HTML text\n\t\t * Node = HTML node\n\t\t * ProjectionTextModel = code projection\n\t\t */\n\t\t_renderImmediateInfo: function _renderImmediateInfo(contentsDiv, contents, context) {\t\t\t\t\t\t\n\t\t\t// If it's an annotation then process the annotation(s) to get the actual data\n\t\t\tif (contents instanceof Array) {\n\t\t\t\tcontents = this._getAnnotationContents(contents, context);\t\t\t\n\t\t\t\tif (!contents) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (typeof contents === \"string\") { //$NON-NLS-0$\n\t\t\t\tcontentsDiv.innerHTML = contents;\n\t\t\t\treturn true;\n\t\t\t} else if (this._isNode(contents)) {\n\t\t\t\tcontentsDiv.appendChild(contents);\n\t\t\t\treturn true;\n\t\t\t} else if (contents instanceof mProjectionTextModel.ProjectionTextModel) {\n\t\t\t\tvar view = this._view;\n\t\t\t\tvar options = view.getOptions();\n\t\t\t\toptions.wrapMode = false;\n\t\t\t\toptions.parent = contentsDiv;\n\t\t\t\tvar tooltipTheme = \"tooltipTheme\"; //$NON-NLS-0$\n\t\t\t\tvar theme = options.themeClass;\n\t\t\t\tif (theme) {\n\t\t\t\t\ttheme = theme.replace(tooltipTheme, \"\");\n\t\t\t\t\tif (theme) { theme = \" \" + theme; } //$NON-NLS-0$\n\t\t\t\t\ttheme = tooltipTheme + theme;\n\t\t\t\t} else {\n\t\t\t\t\ttheme = tooltipTheme;\n\t\t\t\t}\n\t\t\t\toptions.themeClass = theme;\n\t\t\t\tvar contentsView = this._contentsView = new mTextView.TextView(options);\n\t\t\t\t//TODO need to find a better way of sharing the styler for multiple views\n\t\t\t\tvar listener = {\n\t\t\t\t\tonLineStyle: function(e) {\n\t\t\t\t\t\tview.onLineStyle(e);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcontentsView.addEventListener(\"LineStyle\", listener.onLineStyle); //$NON-NLS-0$\n\t\t\t\tcontentsView.setModel(contents);\n\t\t\t\t\n\t\t\t\t// TODO This is a hack to compute the projection size we will have in the tooltip, we remove the child after computing\n\t\t\t\tthis._tooltipDiv.appendChild(contentsDiv);\n\t\t\t\t// Use the editor colors with a simple border\n\t\t\t\tthis._tooltipDiv.classList.add(\"textviewTooltipCodeProjection\"); //$NON-NLS-0$\n\t\t\t\tvar size = contentsView.computeSize();\n\t\t\t\t// Adjust the size for the padding\n\t\t\t\tcontentsDiv.style.width = (size.width+8) + \"px\"; //$NON-NLS-0$\n\t\t\t\tcontentsDiv.style.height = (size.height+8) + \"px\"; //$NON-NLS-0$\n\t\t\t\tcontentsView.resize();\n\t\t\t\tthis._tooltipDiv.removeChild(contentsDiv);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @name _getAnnotationContents\n\t\t * @description Takes a list of annotation and renders them in the tooltip\n\t\t * @function\n\t\t * @private\n\t\t * @param annotations the list of annotations to render\n\t\t * @param context optional object containing where the annotations are displayed (ruler, editor, etc.)\n\t\t * @returns returns document node containing rendered tooltip content\n\t\t */\n\t\t_getAnnotationContents: function(annotations, context) {\n\t\t\tvar self = this;\n\t\t\tvar inEditor = self.hover ? true : false;\n\t\t\tif (inEditor && context && context.source && context.source.indexOf('ruler') >= 0){ //$NON-NLS-0$\n\t\t\t\tinEditor = false;\n\t\t\t}\n\t\t\t\n\t\t\tvar annotation;\n\t\t\tvar newAnnotations = [];\n\t\t\tfor (var j = 0; j < annotations.length; j++) {\n\t\t\t\tannotation = annotations[j];\n\t\t\t\tif (annotation.title !== \"\" && !annotation.groupAnnotation) {\n\t\t\t\t\t// Don't display untitled annotations in the editor such as occurrences as the code is already visible\n\t\t\t\t\tif (!inEditor || annotation.title){\n\t\t\t\t\t\tnewAnnotations.push(annotation); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotations = newAnnotations;\n\t\t\tif (annotations.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tvar html;\n\t\t\tvar document = this._tooltipDiv.ownerDocument;\n\t\t\tvar view = this._view;\n\t\t\tvar model = view.getModel();\n\t\t\tvar baseModel = model.getBaseModel ? model.getBaseModel() : model;\n\t\t\t\n\t\t\t// If this is a code folding annotation, display code projection\n\t\t\tif (annotations.length === 1 && annotations[0].type === \"orion.annotation.folding\") {\n\t\t\t\tvar newModel = new mProjectionTextModel.ProjectionTextModel(baseModel);\n\t\t\t\tvar lineStart = baseModel.getLineStart(baseModel.getLineAtOffset(annotations[0].start));\n\t\t\t\tvar charCount = baseModel.getCharCount();\n\t\t\t\tif (annotations[0].end !== charCount) {\n\t\t\t\t\tnewModel.addProjection({start: annotations[0].end, end: charCount});\n\t\t\t\t}\n\t\t\t\tif (lineStart > 0) {\n\t\t\t\t\tnewModel.addProjection({start: 0, end: lineStart});\n\t\t\t\t}\n\t\t\t\treturn newModel;\n\t\t\t}\n\t\t\t\n\t\t\tif (annotations.length === 1) {\n\t\t\t\thtml = getAnnotationHTML(annotations[0], inEditor);\n\t\t\t\tif (html && html.firstChild) {\n\t\t\t\t\tvar className = html.firstChild.className;\n\t\t\t\t\tif (className) { className += \" \"; } //$NON-NLS-0$\n\t\t\t\t\tclassName += \"single\"; //$NON-NLS-0$\n\t\t\t\t\thtml.firstChild.className = className;\n\t\t\t\t}\n\t\t\t\treturn html;\n\t\t\t} else {\n\t\t\t\tvar tooltipHTML = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tvar em = util.createElement(document, \"em\"); //$NON-NLS-0$\n\t\t\t\tem.appendChild(document.createTextNode(messages.multipleAnnotations));\n\t\t\t\ttooltipHTML.appendChild(em);\n\t\t\t\tfor (var i = 0; i < annotations.length; i++) {\n\t\t\t\t\thtml = getAnnotationHTML(annotations[i], inEditor);\n\t\t\t\t\tif (html) {\n\t\t\t\t\t\ttooltipHTML.appendChild(html);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn tooltipHTML;\n\t\t\t}\n\t\t\t\n\t\t\tfunction getAnnotationHTML(annotation, inEditor) {\n\t\t\t\tvar title = annotation.title;\n\t\t\t\tvar result = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tresult.className = \"tooltipRow\"; //$NON-NLS-0$\n\t\t\t\tif (annotation.html) {\n\t\t\t\t\tvar htmlHolder = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\t\thtmlHolder.className = \"tooltipImage\"; //$NON-NLS-0$\n\t\t\t\t\thtmlHolder.innerHTML = annotation.html;\n\t\t\t\t\tif (htmlHolder.lastChild) {\n\t\t\t\t\t\ttextUtil.addEventListener(htmlHolder.lastChild, \"click\", function() { //$NON-NLS-0$\n\t\t\t\t\t\t\tvar start = annotation.start, end = annotation.end;\n\t\t\t\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\t\t\t\t\tend = model.mapOffset(end, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tview.setSelection(start, end, 1 / 3, function() { self.hide(); });\n\t\t\t\t\t\t}, false);\n\t\t\t\t\t}\n\t\t\t\t\tresult.appendChild(htmlHolder); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (!title) {\n\t\t\t\t\tvar textStart = baseModel.getLineStart(baseModel.getLineAtOffset(annotation.start));\n\t\t\t\t\tvar textEnd = baseModel.getLineEnd(baseModel.getLineAtOffset(annotation.end), true);\n\t\t\t\t\ttitle = baseModel.getText(textStart, textEnd);\n\t\t\t\t}\n\t\t\t\tif (typeof title === \"function\") { //$NON-NLS-0$\n\t\t\t\t\ttitle = annotation.title();\n\t\t\t\t}\n\t\t\t\tif (typeof title === \"string\") { //$NON-NLS-0$\n\t\t\t\t\tvar span = util.createElement(document, \"span\"); //$NON-NLS-0$\n\t\t\t\t\tspan.className = \"tooltipTitle\"; //$NON-NLS-0$\n\t\t\t\t\tspan.appendChild(document.createTextNode(title));\n\t\t\t\t\ttitle = span;\n\t\t\t\t}\n\t\t\t\tresult.appendChild(title);\n\t\t\t\t\n\t\t\t\t// Handle quick fixes\n\t\t\t\tif (inEditor) {\n\t\t\t\t\tself.hover.renderQuickFixes(annotation, result);\n\t\t\t\t}\n\t\t\t\tif (context){\t\n\t\t\t\t\t// Set the hover area to the annotation if it's not already set\n\t\t\t\t\tcontext.offsetStart = annotation.start;\n\t\t\t\t\tcontext.offsetEnd = annotation.end;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t};\n\treturn {Tooltip: Tooltip};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2014 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License v1.0\n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution\n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html).\n *\n * Contributors:\n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/annotations\", ['i18n!orion/editor/nls/messages', 'orion/editor/eventTarget'], function(messages, mEventTarget) { //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\n\t/**\n\t * @class This object represents a regitry of annotation types.\n\t * @name orion.editor.AnnotationType\n\t */\n\tfunction AnnotationType() {\n\t}\n\t\n\t/**\n\t * @class This object represents a decoration attached to a range of text. Annotations are added to a\n\t * <code>AnnotationModel</code> which is attached to a <code>TextModel</code>.\n\t * <p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.AnnotationModel}<br/>\n\t * {@link orion.editor.Ruler}<br/>\n\t * </p>\n\t * @name orion.editor.Annotation\n\t *\n\t * @property {String} type The annotation type (for example, orion.annotation.error).\n\t * @property {Number} start The start offset of the annotation in the text model.\n\t * @property {Number} end The end offset of the annotation in the text model.\n\t * @property {String} html The HTML displayed for the annotation.\n\t * @property {String} title The text description for the annotation.\n\t * @property {orion.editor.Style} style The style information for the annotation used in the annotations ruler and tooltips.\n\t * @property {orion.editor.Style} overviewStyle The style information for the annotation used in the overview ruler.\n\t * @property {orion.editor.Style} rangeStyle The style information for the annotation used in the text view to decorate a range of text.\n\t * @property {orion.editor.Style} lineStyle The style information for the annotation used in the text view to decorate a line of text.\n\t */\n\t/**\n\t * Constructs a new folding annotation.\n\t *\n\t * @param {Number} start The start offset of the annotation in the text model.\n\t * @param {Number} end The end offset of the annotation in the text model.\n\t * @param {orion.editor.ProjectionTextModel} projectionModel The projection text model.\n\t *\n\t * @class This object represents a folding annotation.\n\t * @name orion.editor.FoldingAnnotation\n\t */\n\tfunction FoldingAnnotation (start, end, projectionModel) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis._projectionModel = projectionModel;\n\t\tthis.html = this._expandedHTML;\n\t\tthis.style = this._expandedStyle;\n\t\tthis.expanded = true;\n\t}\n\n\tFoldingAnnotation.prototype = /** @lends orion.editor.FoldingAnnotation.prototype */ {\n\t\t_expandedHTML: \"<div class='annotationHTML expanded'></div>\", //$NON-NLS-0$\n\t\t_expandedStyle: {styleClass: \"annotation expanded\"}, //$NON-NLS-0$\n\t\t_collapsedHTML: \"<div class='annotationHTML collapsed'></div>\", //$NON-NLS-0$\n\t\t_collapsedStyle: {styleClass: \"annotation collapsed\"}, //$NON-NLS-0$\n\t\t_collapse: function() {\n\t\t\tif (!this.expanded) { return false; }\n\t\t\tthis.expanded = false;\n\t\t\tthis.html = this._collapsedHTML;\n\t\t\tthis.style = this._collapsedStyle;\n\t\t\tif (this._annotationModel) {\n\t\t\t\tthis._annotationModel.modifyAnnotation(this);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_expand: function() {\n\t\t\tif (this.expanded) { return false; }\n\t\t\tthis.expanded = true;\n\t\t\tthis.html = this._expandedHTML;\n\t\t\tthis.style = this._expandedStyle;\n\t\t\tif (this._annotationModel) {\n\t\t\t\tthis._annotationModel.modifyAnnotation(this);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_collapseImpl: function (checkOverlaping) {\n\t\t\tif (this._collapse()) {\n\t\t\t\tif (checkOverlaping) {\n\t\t\t\t\tthis._forEachOverlaping(function(annotation) {\n\t\t\t\t\t\tif (!annotation.expanded) {\n\t\t\t\t\t\t\tannotation._expandImpl(false);\n\t\t\t\t\t\t\tannotation._recollapse = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tvar projectionModel = this._projectionModel;\n\t\t\t\tvar baseModel = projectionModel.getBaseModel();\n\t\t\t\tthis._projection = {\n\t\t\t\t\tannotation: this,\n\t\t\t\t\tstart: baseModel.getLineStart(baseModel.getLineAtOffset(this.start) + 1),\n\t\t\t\t\tend: baseModel.getLineEnd(baseModel.getLineAtOffset(this.end), true)\n\t\t\t\t};\n\t\t\t\tprojectionModel.addProjection(this._projection);\n\t\t\t}\n\t\t},\n\t\t_expandImpl: function(checkOverlaping) {\n\t\t\tif (this._expand()) {\n\t\t\t\tthis._projectionModel._removeProjection(this._projection, !this._annotationModel);\n\t\t\t\tif (checkOverlaping) {\n\t\t\t\t\tthis._forEachOverlaping(function(annotation) {\n\t\t\t\t\t\tif (annotation._recollapse) {\n\t\t\t\t\t\t\tannotation._collapseImpl(false);\n\t\t\t\t\t\t\tannotation._recollapse = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_forEachOverlaping: function(callback) {\n\t\t\tif (!this._annotationModel) { return; }\n\t\t\tvar annotations = this._annotationModel.getAnnotations(this.start, this.end);\n\t\t\twhile (annotations.hasNext()) {\n\t\t\t\tvar annotation = annotations.next();\n\t\t\t\tif (annotation !== this && annotation.type === AnnotationType.ANNOTATION_FOLDING) {\n\t\t\t\t\tcallback.call(this, annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Collapses the annotation.\n\t\t */\n\t\tcollapse: function () {\n\t\t\tthis._recollapse = false;\n\t\t\tthis._collapseImpl(true);\n\t\t},\n\t\t/**\n\t\t * Expands the annotation.\n\t\t */\n\t\texpand: function () {\n\t\t\tthis._recollapse = false;\n\t\t\tthis._expandImpl(true);\n\t\t}\n\t};\n\t \n\t/**\n\t * Error annotation type.\n\t */\n\tAnnotationType.ANNOTATION_ERROR = \"orion.annotation.error\"; //$NON-NLS-0$\n\t/**\n\t * Warning annotation type.\n\t */\n\tAnnotationType.ANNOTATION_WARNING = \"orion.annotation.warning\"; //$NON-NLS-0$\n\t/**\n\t * Task annotation type.\n\t */\n\tAnnotationType.ANNOTATION_TASK = \"orion.annotation.task\"; //$NON-NLS-0$\n\t/**\n\t * Breakpoint annotation type.\n\t */\n\tAnnotationType.ANNOTATION_BREAKPOINT = \"orion.annotation.breakpoint\"; //$NON-NLS-0$\n\t/**\n\t * Bookmark annotation type.\n\t */\n\tAnnotationType.ANNOTATION_BOOKMARK = \"orion.annotation.bookmark\"; //$NON-NLS-0$\n\t/**\n\t * Folding annotation type.\n\t */\n\tAnnotationType.ANNOTATION_FOLDING = \"orion.annotation.folding\"; //$NON-NLS-0$\n\t/**\n\t * Curent bracket annotation type.\n\t */\n\tAnnotationType.ANNOTATION_CURRENT_BRACKET = \"orion.annotation.currentBracket\"; //$NON-NLS-0$\n\t/**\n\t * Matching bracket annotation type.\n\t */\n\tAnnotationType.ANNOTATION_MATCHING_BRACKET = \"orion.annotation.matchingBracket\"; //$NON-NLS-0$\n\t/**\n\t * Current line annotation type.\n\t */\n\tAnnotationType.ANNOTATION_CURRENT_LINE = \"orion.annotation.currentLine\"; //$NON-NLS-0$\n\t/**\n\t * Current search annotation type.\n\t */\n\tAnnotationType.ANNOTATION_CURRENT_SEARCH = \"orion.annotation.currentSearch\"; //$NON-NLS-0$\n\t/**\n\t * Matching search annotation type.\n\t */\n\tAnnotationType.ANNOTATION_MATCHING_SEARCH = \"orion.annotation.matchingSearch\"; //$NON-NLS-0$\n\t/**\n\t * Read Occurrence annotation type.\n\t */\n\tAnnotationType.ANNOTATION_READ_OCCURRENCE = \"orion.annotation.readOccurrence\"; //$NON-NLS-0$\n\t/**\n\t * Write Occurrence annotation type.\n\t */\n\tAnnotationType.ANNOTATION_WRITE_OCCURRENCE = \"orion.annotation.writeOccurrence\"; //$NON-NLS-0$\n\t/**\n\t * Selected linked group annotation type.\n\t */\n\tAnnotationType.ANNOTATION_SELECTED_LINKED_GROUP = \"orion.annotation.selectedLinkedGroup\"; //$NON-NLS-0$\n\t/**\n\t * Current linked group annotation type.\n\t */\n\tAnnotationType.ANNOTATION_CURRENT_LINKED_GROUP = \"orion.annotation.currentLinkedGroup\"; //$NON-NLS-0$\n\t/**\n\t * Linked group annotation type.\n\t */\n\tAnnotationType.ANNOTATION_LINKED_GROUP = \"orion.annotation.linkedGroup\"; //$NON-NLS-0$\n\t/**\n\t* Blame annotation type.\n\t*/\n\tAnnotationType.ANNOTATION_BLAME = \"orion.annotation.blame\"; //$NON-NLS-0$\n\t/**\n\t* Current Blame annotation type.\n\t*/\n\tAnnotationType.ANNOTATION_CURRENT_BLAME = \"orion.annotation.currentBlame\"; //$NON-NLS-0$\n\t/**\n\t * Diff Added annotation type.\n\t */\n\tAnnotationType.ANNOTATION_DIFF_ADDED = \"orion.annotation.diffAdded\"; //$NON-NLS-0$\n\t/**\n\t * Diff Deleted annotation type.\n\t */\n\tAnnotationType.ANNOTATION_DIFF_DELETED = \"orion.annotation.diffDeleted\"; //$NON-NLS-0$\n\t/**\n\t * Diff Modification annotation type.\n\t */\n\tAnnotationType.ANNOTATION_DIFF_MODIFIED = \"orion.annotation.diffModified\"; //$NON-NLS-0$\n\n\t/** @private */\n\tvar annotationTypes = {};\n\n\t/**\n\t * Register an annotation type.\n\t *\n\t * @param {String} type The annotation type (for example, orion.annotation.error).\n\t * @param {Object|Function} properties The common annotation properties of the registered\n\t *\t\tannotation type. All annotations create with this annotation type will expose these\n\t *\t\tproperties.\n\t */\n\tAnnotationType.registerType = function(type, properties) {\n\t\tvar constructor = properties;\n\t\tif (typeof constructor !== \"function\") { //$NON-NLS-0$\n\t\t\tconstructor = function(start, end, title) {\n\t\t\t\tthis.start = start;\n\t\t\t\tthis.end = end;\n\t\t\t\tif (title !== undefined) { this.title = title; }\n\t\t\t};\n\t\t\tconstructor.prototype = properties;\n\t\t}\n\t\tconstructor.prototype.type = type;\n\t\tannotationTypes[type] = constructor;\n\t\treturn type;\n\t};\n\n\t/**\n\t * Creates an annotation of a given type with the specified start end end offsets.\n\t *\n\t * @param {String} type The annotation type (for example, orion.annotation.error).\n\t * @param {Number} start The start offset of the annotation in the text model.\n\t * @param {Number} end The end offset of the annotation in the text model.\n\t * @param {String} [title] The text description for the annotation if different then the type description.\n\t * @return {orion.editor.Annotation} the new annotation\n\t */\n\tAnnotationType.createAnnotation = function(type, start, end, title) {\n\t\treturn new (this.getType(type))(start, end, title);\n\t};\n\n\t/**\n\t * Gets the registered annotation type with specified type. The returned\n\t * value is a constructor that can be used to create annotations of the\n\t * speficied type.  The constructor takes the start and end offsets of\n\t * the annotation.\n\t *\n\t * @param {String} type The annotation type (for example, orion.annotation.error).\n\t * @return {Function} The annotation type constructor ( i.e function(start, end, title) ).\n\t */\n\tAnnotationType.getType = function(type) {\n\t\treturn annotationTypes[type];\n\t};\n\n\t/** @private */\n\tfunction registerType(type, lineStyling) {\n\t\tvar index = type.lastIndexOf('.'); //$NON-NLS-0$\n\t\tvar suffix = type.substring(index + 1);\n\t\tvar properties = {\n\t\t\ttitle: messages[suffix],\n\t\t\tstyle: {styleClass: \"annotation \" + suffix}, //$NON-NLS-0$\n\t\t\thtml: \"<div class='annotationHTML \" + suffix + \"'></div>\", //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\toverviewStyle: {styleClass: \"annotationOverview \" + suffix} //$NON-NLS-0$\n\t\t};\n\t\tif (lineStyling) {\n\t\t\tproperties.lineStyle = {styleClass: \"annotationLine \" + suffix}; //$NON-NLS-0$\n\t\t} else {\n\t\t\tproperties.rangeStyle = {styleClass: \"annotationRange \" + suffix}; //$NON-NLS-0$\n\t\t}\n\t\tAnnotationType.registerType(type, properties);\n\t}\n\tregisterType(AnnotationType.ANNOTATION_ERROR);\n\tregisterType(AnnotationType.ANNOTATION_WARNING);\n\tregisterType(AnnotationType.ANNOTATION_TASK);\n\tregisterType(AnnotationType.ANNOTATION_BREAKPOINT);\n\tregisterType(AnnotationType.ANNOTATION_BOOKMARK);\n\tregisterType(AnnotationType.ANNOTATION_CURRENT_BRACKET);\n\tregisterType(AnnotationType.ANNOTATION_MATCHING_BRACKET);\n\tregisterType(AnnotationType.ANNOTATION_CURRENT_SEARCH);\n\tregisterType(AnnotationType.ANNOTATION_MATCHING_SEARCH);\n\tregisterType(AnnotationType.ANNOTATION_READ_OCCURRENCE);\n\tregisterType(AnnotationType.ANNOTATION_WRITE_OCCURRENCE);\n\tregisterType(AnnotationType.ANNOTATION_SELECTED_LINKED_GROUP);\n\tregisterType(AnnotationType.ANNOTATION_CURRENT_LINKED_GROUP);\n\tregisterType(AnnotationType.ANNOTATION_LINKED_GROUP);\n\tregisterType(AnnotationType.ANNOTATION_CURRENT_LINE, true);\n\tregisterType(AnnotationType.ANNOTATION_BLAME, true);\n\tregisterType(AnnotationType.ANNOTATION_CURRENT_BLAME, true);\n\tregisterType(AnnotationType.ANNOTATION_DIFF_ADDED);\n\tregisterType(AnnotationType.ANNOTATION_DIFF_DELETED);\n\tregisterType(AnnotationType.ANNOTATION_DIFF_MODIFIED);\n\n\tAnnotationType.registerType(AnnotationType.ANNOTATION_FOLDING, FoldingAnnotation);\n\n\t/**\n\t * Constructs a new AnnotationTypeList object.\n\t *\n\t * @class This represents an interface of prioritized annotation types.\n\t * @name orion.editor.AnnotationTypeList\n\t */\n\tfunction AnnotationTypeList () {\n\t}\n\t/**\n\t * Adds in the annotation type interface into the specified object.\n\t *\n\t * @param {Object} object The object to add in the annotation type interface.\n\t */\n\tAnnotationTypeList.addMixin = function(object) {\n\t\tvar proto = AnnotationTypeList.prototype;\n\t\tfor (var p in proto) {\n\t\t\tif (proto.hasOwnProperty(p)) {\n\t\t\t\tobject[p] = proto[p];\n\t\t\t}\n\t\t}\n\t};\n\tAnnotationTypeList.prototype = /** @lends orion.editor.AnnotationTypeList.prototype */ {\n\t\t/**\n\t\t * Adds an annotation type to the receiver.\n\t\t * <p>\n\t\t * Only annotations of the specified types will be shown by\n\t\t * the receiver.\n\t\t * </p>\n\t\t * <p>\n\t\t * If the priority is not specified, the annotation type will be added\n\t\t * to the end of the receiver's list (lowest pririoty).\n\t\t * </p>\n\t\t *\n\t\t * @param {Object} type the annotation type to be shown\n\t\t * @param {Number} priority the priority for the annotation type\n\t\t * \n\t\t * @see orion.editor.AnnotationTypeList#removeAnnotationType\n\t\t * @see orion.editor.AnnotationTypeList#isAnnotationTypeVisible\n\t\t * @see orion.editor.AnnotationTypeList#getAnnotationTypePriority\n\t\t */\n\t\taddAnnotationType: function(type, priority) {\n\t\t\tif (!this._annotationTypes) { this._annotationTypes = []; }\n\t\t\tvar index = priority - 1;\n\t\t\tif (priority == undefined || !(0 <= index && index < this._annotationTypes.length)) {\n\t\t\t\tthis._annotationTypes.push(type);\n\t\t\t} else {\n\t\t\t\tthis._annotationTypes.splice(index, 0, type);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Gets the annotation type priority.  The priority is determined by the\n\t\t * order the annotation type is added to the receiver.  Annotation types\n\t\t * added first have higher priority.\n\t\t * <p>\n\t\t * Returns <code>0</code> if the annotation type is not added.\n\t\t * </p>\n\t\t *\n\t\t * @param {Object} type the annotation type\n\t\t *\n\t\t * @see orion.editor.AnnotationTypeList#addAnnotationType\n\t\t * @see orion.editor.AnnotationTypeList#removeAnnotationType\n\t\t * @see orion.editor.AnnotationTypeList#isAnnotationTypeVisible\n\t\t */\n\t\tgetAnnotationTypePriority: function(type) {\n\t\t\tif (this._annotationTypes) {\n\t\t\t\tfor (var i = 0; i < this._annotationTypes.length; i++) {\n\t\t\t\t\tif (this._annotationTypes[i] === type) {\n\t\t\t\t\t\treturn i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\t/**\n\t\t * Returns an array of annotations in the specified annotation model for the given range of text sorted by type.\n\t\t *\n\t\t * @param {orion.editor.AnnotationModel} annotationModel the annotation model.\n\t\t * @param {Number} start the start offset of the range.\n\t\t * @param {Number} end the end offset of the range.\n\t\t * @return {orion.editor.Annotation[]} an annotation array.\n\t\t */\n\t\tgetAnnotationsByType: function(annotationModel, start, end) {\n\t\t\tvar iter = annotationModel.getAnnotations(start, end);\n\t\t\tvar annotation, annotations = [];\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tannotation = iter.next();\n\t\t\t\tvar priority = this.getAnnotationTypePriority(annotation.type);\n\t\t\t\tif (priority === 0) { continue; }\n\t\t\t\tannotations.push(annotation);\n\t\t\t}\n\t\t\tvar self = this;\n\t\t\tannotations.sort(function(a, b) {\n\t\t\t\treturn self.getAnnotationTypePriority(a.type) - self.getAnnotationTypePriority(b.type);\n\t\t\t});\n\t\t\treturn annotations;\n\t\t},\n\t\t/**\n\t\t * Returns whether the receiver shows annotations of the specified type.\n\t\t *\n\t\t * @param {Object} type the annotation type\n\t\t * @returns {Boolean} whether the specified annotation type is shown\n\t\t *\n\t\t * @see orion.editor.AnnotationTypeList#addAnnotationType\n\t\t * @see orion.editor.AnnotationTypeList#removeAnnotationType\n\t\t */\n\t\tisAnnotationTypeVisible: function(type) {\n\t\t\treturn this.getAnnotationTypePriority(type) !== 0;\n\t\t},\n\t\t/**\n\t\t * Removes an annotation type from the receiver.\n\t\t *\n\t\t * @param {Object} type the annotation type to be removed\n\t\t *\n\t\t * @see orion.editor.AnnotationTypeList#addAnnotationType\n\t\t * @see orion.editor.AnnotationTypeList#isAnnotationTypeVisible\n\t\t */\n\t\tremoveAnnotationType: function(type) {\n\t\t\tif (!this._annotationTypes) { return; }\n\t\t\tfor (var i = 0; i < this._annotationTypes.length; i++) {\n\t\t\t\tif (this._annotationTypes[i] === type) {\n\t\t\t\t\tthis._annotationTypes.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\t/** @private */\n\tfunction binarySearch(array, offset, inclusive, low, high) {\n\t\tvar index;\n\t\tif (low === undefined) { low = -1; }\n\t\tif (high === undefined) { high = array.length; }\n\t\twhile (high - low > 1) {\n\t\t\tindex = Math.floor((high + low) / 2);\n\t\t\tif (offset <= array[index].start) {\n\t\t\t\thigh = index;\n\t\t\t} else if (inclusive && offset < array[index].end) {\n\t\t\t\thigh = index;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlow = index;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t}\n\t\n\t/**\n\t * Constructs an annotation model.\n\t * \n\t * @param {orion.editor.TextModel} textModel The text model.\n\t * \n\t * @class This object manages annotations for a <code>TextModel</code>.\n\t * <p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.Annotation}<br/>\n\t * {@link orion.editor.TextModel}<br/> \n\t * </p>\t\n\t * @name orion.editor.AnnotationModel\n\t * @borrows orion.editor.EventTarget#addEventListener as #addEventListener\n\t * @borrows orion.editor.EventTarget#removeEventListener as #removeEventListener\n\t * @borrows orion.editor.EventTarget#dispatchEvent as #dispatchEvent\n\t */\n\tfunction AnnotationModel(textModel) {\n\t\tthis._annotations = [];\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonChanged: function(modelChangedEvent) {\n\t\t\t\tself._onChanged(modelChangedEvent);\n\t\t\t}\n\t\t};\n\t\tthis.setTextModel(textModel);\n\t}\n\n\tAnnotationModel.prototype = /** @lends orion.editor.AnnotationModel.prototype */ {\n\t\t/**\n\t\t * Adds an annotation to the annotation model.\n\t\t * <p>The annotation model listeners are notified of this change.</p>\n\t\t *\n\t\t * @param {orion.editor.Annotation} annotation the annotation to be added.\n\t\t *\n\t\t * @see orion.editor.AnnotationModel#removeAnnotation\n\t\t */\n\t\taddAnnotation: function(annotation) {\n\t\t\tif (!annotation) { return; }\n\t\t\tvar annotations = this._annotations;\n\t\t\tvar index = binarySearch(annotations, annotation.start);\n\t\t\tannotations.splice(index, 0, annotation);\n\t\t\tannotation._annotationModel = this;\n\t\t\tvar e = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tadded: [annotation],\n\t\t\t\tremoved: [],\n\t\t\t\tchanged: []\n\t\t\t};\n\t\t\tthis.onChanged(e);\n\t\t},\n\t\t/**\n\t\t * Returns the text model.\n\t\t *\n\t\t * @return {orion.editor.TextModel} The text model.\n\t\t *\n\t\t * @see orion.editor.AnnotationModel#setTextModel\n\t\t */\n\t\tgetTextModel: function() {\n\t\t\treturn this._model;\n\t\t},\n\t\t/**\n\t\t * @class This object represents an annotation iterator.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.AnnotationModel#getAnnotations}<br/>\n\t\t * </p>\n\t\t * @name orion.editor.AnnotationIterator\n\t\t *\n\t\t * @property {Function} hasNext Determines whether there are more annotations in the iterator.\n\t\t * @property {Function} next Returns the next annotation in the iterator.\n\t\t */\n\t\t/**\n\t\t * Returns an iterator of annotations for the given range of text. If called with no parameters,\n\t\t * returns all annotations in the model.\n\t\t *\n\t\t * @param {Number} start the start offset of the range.\n\t\t * @param {Number} end the end offset of the range.\n\t\t * @return {orion.editor.AnnotationIterator} an annotation iterartor.\n\t\t */\n\t\tgetAnnotations: function(start, end) {\n\t\t\tvar annotations = this._annotations, current;\n\t\t\tvar i = 0, skip;\n\t\t\tif (start === undefined && end === undefined) {\n\t\t\t\tskip = function() {\n\t\t\t\t\treturn (i < annotations.length) ? annotations[i++] : null;\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t//TODO binary search does not work for range intersection when there are overlaping ranges, need interval search tree for this\n\t\t\t\tskip = function() {\n\t\t\t\t\twhile (i < annotations.length) {\n\t\t\t\t\t\tvar a =  annotations[i++];\n\t\t\t\t\t\tif ((start === a.start) || (start > a.start ? start < a.end : a.start < end)) {\n\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a.start >= end) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t}\n\t\t\tcurrent = skip();\n\t\t\treturn {\n\t\t\t\tnext: function() {\n\t\t\t\t\tvar result = current;\n\t\t\t\t\tif (result) { current = skip(); }\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn current !== null;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * Notifies the annotation model that the given annotation has been modified.\n\t\t * <p>The annotation model listeners are notified of this change.</p>\n\t\t *\n\t\t * @param {orion.editor.Annotation} annotation the modified annotation.\n\t\t *\n\t\t * @see orion.editor.AnnotationModel#addAnnotation\n\t\t */\n\t\tmodifyAnnotation: function(annotation) {\n\t\t\tif (!annotation) { return; }\n\t\t\tvar index = this._getAnnotationIndex(annotation);\n\t\t\tif (index < 0) { return; }\n\t\t\tvar e = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tadded: [],\n\t\t\t\tremoved: [],\n\t\t\t\tchanged: [annotation]\n\t\t\t};\n\t\t\tthis.onChanged(e);\n\t\t},\n\t\t/**\n\t\t * Notifies all listeners that the annotation model has changed.\n\t\t *\n\t\t * @param {orion.editor.Annotation[]} added The list of annotation being added to the model.\n\t\t * @param {orion.editor.Annotation[]} changed The list of annotation modified in the model.\n\t\t * @param {orion.editor.Annotation[]} removed The list of annotation being removed from the model.\n\t\t * @param {ModelChangedEvent} textModelChangedEvent the text model changed event that trigger this change, can be null if the change was trigger by a method call (for example, {@link #addAnnotation}).\n\t\t */\n\t\tonChanged: function(e) {\n\t\t\treturn this.dispatchEvent(e);\n\t\t},\n\t\t/**\n\t\t * Removes all annotations of the given <code>type</code>. All annotations\n\t\t * are removed if the type is not specified.\n\t\t * <p>The annotation model listeners are notified of this change.  Only one changed event is generated.</p>\n\t\t *\n\t\t * @param {Object} type the type of annotations to be removed.\n\t\t *\n\t\t * @see orion.editor.AnnotationModel#removeAnnotation\n\t\t */\n\t\tremoveAnnotations: function(type) {\n\t\t\tvar annotations = this._annotations;\n\t\t\tvar removed, i;\n\t\t\tif (type) {\n\t\t\t\tremoved = [];\n\t\t\t\tfor (i = annotations.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar annotation = annotations[i];\n\t\t\t\t\tif (annotation.type === type) {\n\t\t\t\t\t\tannotations.splice(i, 1);\n\t\t\t\t\t\tremoved.splice(0, 0, annotation);\n\t\t\t\t\t\tannotation._annotationModel = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tremoved = annotations;\n\t\t\t\tannotations = [];\n\t\t\t}\n\t\t\tvar e = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tremoved: removed,\n\t\t\t\tadded: [],\n\t\t\t\tchanged: []\n\t\t\t};\n\t\t\tthis.onChanged(e);\n\t\t},\n\t\t/**\n\t\t * Removes an annotation from the annotation model.\n\t\t * <p>The annotation model listeners are notified of this change.</p>\n\t\t *\n\t\t * @param {orion.editor.Annotation} annotation the annotation to be removed.\n\t\t *\n\t\t * @see orion.editor.AnnotationModel#addAnnotation\n\t\t */\n\t\tremoveAnnotation: function(annotation) {\n\t\t\tif (!annotation) { return; }\n\t\t\tvar index = this._getAnnotationIndex(annotation);\n\t\t\tif (index < 0) { return; }\n\t\t\tannotation._annotationModel = null;\n\t\t\tvar e = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tremoved: this._annotations.splice(index, 1),\n\t\t\t\tadded: [],\n\t\t\t\tchanged: []\n\t\t\t};\n\t\t\tthis.onChanged(e);\n\t\t},\n\t\t/**\n\t\t * Removes and adds the specifed annotations to the annotation model.\n\t\t * <p>The annotation model listeners are notified of this change.  Only one changed event is generated.</p>\n\t\t *\n\t\t * @param {orion.editor.Annotation} remove the annotations to be removed.\n\t\t * @param {orion.editor.Annotation} add the annotations to be added.\n\t\t *\n\t\t * @see orion.editor.AnnotationModel#addAnnotation\n\t\t * @see orion.editor.AnnotationModel#removeAnnotation\n\t\t */\n\t\treplaceAnnotations: function(remove, add) {\n\t\t\tvar annotations = this._annotations, i, index, annotation, removed = [];\n\t\t\tif (remove) {\n\t\t\t\tfor (i = remove.length - 1; i >= 0; i--) {\n\t\t\t\t\tannotation = remove[i];\n\t\t\t\t\tindex = this._getAnnotationIndex(annotation);\n\t\t\t\t\tif (index < 0) { continue; }\n\t\t\t\t\tannotation._annotationModel = null;\n\t\t\t\t\tannotations.splice(index, 1);\n\t\t\t\t\tremoved.splice(0, 0, annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!add) { add = []; }\n\t\t\tfor (i = 0; i < add.length; i++) {\n\t\t\t\tannotation = add[i];\n\t\t\t\tindex = binarySearch(annotations, annotation.start);\n\t\t\t\tannotation._annotationModel = this;\n\t\t\t\tannotations.splice(index, 0, annotation);\n\t\t\t}\n\t\t\tvar e = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tremoved: removed,\n\t\t\t\tadded: add,\n\t\t\t\tchanged: []\n\t\t\t};\n\t\t\t\n\t\t\tthis.onChanged(e);\n\t\t},\n\t\t/**\n\t\t * Sets the text model of the annotation model.  The annotation\n\t\t * model listens for changes in the text model to update and remove\n\t\t * annotations that are affected by the change.\n\t\t *\n\t\t * @param {orion.editor.TextModel} textModel the text model.\n\t\t *\n\t\t * @see orion.editor.AnnotationModel#getTextModel\n\t\t */\n\t\tsetTextModel: function(textModel) {\n\t\t\tif (this._model) {\n\t\t\t\tthis._model.removeEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._model = textModel;\n\t\t\tif (this._model) {\n\t\t\t\tthis._model.addEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t/** @ignore */\n\t\t_getAnnotationIndex: function(annotation) {\n\t\t\tvar annotations = this._annotations;\n\t\t\tvar index = binarySearch(annotations, annotation.start);\n\t\t\twhile (index < annotations.length && annotations[index].start === annotation.start) {\n\t\t\t\tif (annotations[index] === annotation) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t/** @ignore */\n\t\t_onChanged: function(modelChangedEvent) {\n\t\t\tvar start = modelChangedEvent.start;\n\t\t\tvar addedCharCount = modelChangedEvent.addedCharCount;\n\t\t\tvar removedCharCount = modelChangedEvent.removedCharCount;\n\t\t\tvar annotations = this._annotations, end = start + removedCharCount;\n\t\t\t//TODO binary search does not work for range intersection when there are overlaping ranges, need interval search tree for this\n\t\t\tvar startIndex = 0;\n\t\t\tif (!(0 <= startIndex && startIndex < annotations.length)) { return; }\n\t\t\tvar e = {\n\t\t\t\ttype: \"Changed\", //$NON-NLS-0$\n\t\t\t\tadded: [],\n\t\t\t\tremoved: [],\n\t\t\t\tchanged: [],\n\t\t\t\ttextModelChangedEvent: modelChangedEvent\n\t\t\t};\n\t\t\tvar changeCount = addedCharCount - removedCharCount, i;\n\t\t\tfor (i = startIndex; i < annotations.length; i++) {\n\t\t\t\tvar annotation = annotations[i];\n\t\t\t\tif (annotation.start >= end) {\n\t\t\t\t\tannotation._oldStart = annotation.start;\n\t\t\t\t\tannotation._oldEnd = annotation.end;\n\t\t\t\t\tannotation.start += changeCount;\n\t\t\t\t\tannotation.end += changeCount;\n\t\t\t\t\te.changed.push(annotation);\n\t\t\t\t} else if (annotation.end <= start) {\n\t\t\t\t\t//nothing\n\t\t\t\t} else if (annotation.start < start && end < annotation.end) {\n\t\t\t\t\tannotation._oldStart = annotation.start;\n\t\t\t\t\tannotation._oldEnd = annotation.end;\n\t\t\t\t\tannotation.end += changeCount;\n\t\t\t\t\te.changed.push(annotation);\n\t\t\t\t} else {\n\t\t\t\t\tannotations.splice(i, 1);\n\t\t\t\t\te.removed.push(annotation);\n\t\t\t\t\tannotation._annotationModel = null;\n\t\t\t\t\tif (annotation.expand) {\n\t\t\t\t\t\tannotation.expand();\n\t\t\t\t\t}\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.added.length > 0 || e.removed.length > 0 || e.changed.length > 0) {\n\t\t\t\tthis.onChanged(e);\n\t\t\t}\n\t\t}\n\t};\n\tmEventTarget.EventTarget.addMixin(AnnotationModel.prototype);\n\n\t/**\n\t * Constructs a new styler for annotations.\n\t *\n\t * @param {orion.editor.TextView} view The styler view.\n\t * @param {orion.editor.AnnotationModel} view The styler annotation model.\n\t *\n\t * @class This object represents a styler for annotation attached to a text view.\n\t * @name orion.editor.AnnotationStyler\n\t * @borrows orion.editor.AnnotationTypeList#addAnnotationType as #addAnnotationType\n\t * @borrows orion.editor.AnnotationTypeList#getAnnotationTypePriority as #getAnnotationTypePriority\n\t * @borrows orion.editor.AnnotationTypeList#getAnnotationsByType as #getAnnotationsByType\n\t * @borrows orion.editor.AnnotationTypeList#isAnnotationTypeVisible as #isAnnotationTypeVisible\n\t * @borrows orion.editor.AnnotationTypeList#removeAnnotationType as #removeAnnotationType\n\t */\n\tfunction AnnotationStyler (view, annotationModel) {\n\t\tthis._view = view;\n\t\tthis._annotationModel = annotationModel;\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonDestroy: function(e) {\n\t\t\t\tself._onDestroy(e);\n\t\t\t},\n\t\t\tonLineStyle: function(e) {\n\t\t\t\tself._onLineStyle(e);\n\t\t\t},\n\t\t\tonChanged: function(e) {\n\t\t\t\tself._onAnnotationModelChanged(e);\n\t\t\t}\n\t\t};\n\t\tview.addEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\tview.addEventListener(\"postLineStyle\", this._listener.onLineStyle); //$NON-NLS-0$\n\t\tannotationModel.addEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t}\n\tAnnotationStyler.prototype = /** @lends orion.editor.AnnotationStyler.prototype */ {\n\t\t/**\n\t\t * Destroys the styler.\n\t\t * <p>\n\t\t * Removes all listeners added by this styler.\n\t\t * </p>\n\t\t */\n\t\tdestroy: function() {\n\t\t\tvar view = this._view;\n\t\t\tif (view) {\n\t\t\t\tview.removeEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\t\t\tview.removeEventListener(\"LineStyle\", this._listener.onLineStyle); //$NON-NLS-0$\n\t\t\t\tthis.view = null;\n\t\t\t}\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tif (annotationModel) {\n\t\t\t\tannotationModel.removeEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t\t\t\tannotationModel = null;\n\t\t\t}\n\t\t},\n\t\t_mergeStyle: function(result, style) {\n\t\t\tif (style) {\n\t\t\t\tif (!result) { result = {}; }\n\t\t\t\tif (result.styleClass && style.styleClass && result.styleClass !== style.styleClass) {\n\t\t\t\t\tresult.styleClass += \" \" + style.styleClass; //$NON-NLS-0$\n\t\t\t\t} else {\n\t\t\t\t\tresult.styleClass = style.styleClass;\n\t\t\t\t}\n\t\t\t\tvar prop;\n\t\t\t\tif (style.tagName) {\n\t\t\t\t\tif (!result.tagName) {\n\t\t\t\t\t\tresult.tagName = style.tagName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (style.style) {\n\t\t\t\t\tif (!result.style) { result.style  = {}; }\n\t\t\t\t\tfor (prop in style.style) {\n\t\t\t\t\t\tif (!result.style[prop]) {\n\t\t\t\t\t\t\tresult.style[prop] = style.style[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (style.attributes) {\n\t\t\t\t\tif (!result.attributes) { result.attributes  = {}; }\n\t\t\t\t\tfor (prop in style.attributes) {\n\t\t\t\t\t\tif (!result.attributes[prop]) {\n\t\t\t\t\t\t\tresult.attributes[prop] = style.attributes[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t_mergeStyleRanges: function(ranges, styleRange) {\n\t\t\tif (!ranges) {\n\t\t\t\tranges = [];\n\t\t\t}\n\t\t\tvar mergedStyle, i = binarySearch(ranges, styleRange.start, true);\n\t\t\tfor (; i<ranges.length && styleRange; i++) {\n\t\t\t\tvar range = ranges[i];\n\t\t\t\tif (styleRange.end <= range.start) { break; }\n\t\t\t\tif (styleRange.start >= range.end) { continue; }\n\t\t\t\tmergedStyle = this._mergeStyle({}, range.style);\n\t\t\t\tmergedStyle = this._mergeStyle(mergedStyle, styleRange.style);\n\t\t\t\tvar args = [];\n\t\t\t\targs.push(i, 1);\n\t\t\t\tif (styleRange.start < range.start) {\n\t\t\t\t\targs.push({start: styleRange.start, end: range.start, style: styleRange.style});\n\t\t\t\t}\n\t\t\t\tif (styleRange.start > range.start) {\n\t\t\t\t\targs.push({start: range.start, end: styleRange.start, style: range.style});\n\t\t\t\t}\n\t\t\t\targs.push({start: Math.max(range.start, styleRange.start), end: Math.min(range.end, styleRange.end), style: mergedStyle});\n\t\t\t\tif (styleRange.end < range.end) {\n\t\t\t\t\targs.push({start: styleRange.end, end: range.end, style: range.style});\n\t\t\t\t}\n\t\t\t\tif (styleRange.end > range.end) {\n\t\t\t\t\tstyleRange = {start: range.end, end: styleRange.end, style: styleRange.style};\n\t\t\t\t} else {\n\t\t\t\t\tstyleRange = null;\n\t\t\t\t}\n\t\t\t\tArray.prototype.splice.apply(ranges, args);\n\t\t\t}\n\t\t\tif (styleRange) {\n\t\t\t\tmergedStyle = this._mergeStyle({}, styleRange.style);\n\t\t\t\tranges.splice(i, 0, {start: styleRange.start, end: styleRange.end, style: mergedStyle});\n\t\t\t}\n\t\t\treturn ranges;\n\t\t},\n\t\t_onAnnotationModelChanged: function(e) {\n\t\t\tvar view = this._view;\n\t\t\tif (!view) { return; }\n\t\t\tvar self = this;\n\t\t\tvar model = view.getModel();\n\t\t\tfunction redrawRange(start, end) {\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\t\tend = model.mapOffset(end, true);\n\t\t\t\t}\n\t\t\t\tif (start !== -1 && end !== -1) {\n\t\t\t\t\tview.redrawRange(start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction redraw(changes, changed) {\n\t\t\t\tfor (var i = 0; i < changes.length; i++) {\n\t\t\t\t\tif (!self.isAnnotationTypeVisible(changes[i].type)) { continue; }\n\t\t\t\t\tvar change = changes[i];\n\t\t\t\t\tredrawRange(change.start, change.end);\n\t\t\t\t\tif (changed && change._oldStart !== undefined && change._oldEnd) {\n\t\t\t\t\t\tredrawRange(change._oldStart, change._oldEnd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tredraw(e.added);\n\t\t\tredraw(e.removed);\n\t\t\tredraw(e.changed, true);\n\t\t},\n\t\t_onDestroy: function(e) {\n\t\t\tthis.destroy();\n\t\t},\n\t\t_onLineStyle: function (e) {\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tvar viewModel = e.textView.getModel();\n\t\t\tvar baseModel = annotationModel.getTextModel();\n\t\t\tvar start = e.lineStart;\n\t\t\tvar end = e.lineStart + e.lineText.length;\n\t\t\tif (baseModel !== viewModel) {\n\t\t\t\tstart = viewModel.mapOffset(start);\n\t\t\t\tend = viewModel.mapOffset(end);\n\t\t\t}\n\t\t\tvar annotations = annotationModel.getAnnotations(start, end);\n\t\t\twhile (annotations.hasNext()) {\n\t\t\t\tvar annotation = annotations.next();\n\t\t\t\tif (!this.isAnnotationTypeVisible(annotation.type)) { continue; }\n\t\t\t\tif (annotation.rangeStyle) {\n\t\t\t\t\tvar annotationStart = annotation.start;\n\t\t\t\t\tvar annotationEnd = annotation.end;\n\t\t\t\t\tif (baseModel !== viewModel) {\n\t\t\t\t\t\tannotationStart = viewModel.mapOffset(annotationStart, true);\n\t\t\t\t\t\tannotationEnd = viewModel.mapOffset(annotationEnd, true);\n\t\t\t\t\t}\n\t\t\t\t\te.ranges = this._mergeStyleRanges(e.ranges, {start: annotationStart, end: annotationEnd, style: annotation.rangeStyle});\n\t\t\t\t}\n\t\t\t\tif (annotation.lineStyle) {\n\t\t\t\t\te.style = this._mergeStyle({}, e.style);\n\t\t\t\t\te.style = this._mergeStyle(e.style, annotation.lineStyle);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tAnnotationTypeList.addMixin(AnnotationStyler.prototype);\n\n\treturn {\n\t\tFoldingAnnotation: FoldingAnnotation,\n\t\tAnnotationType: AnnotationType,\n\t\tAnnotationTypeList: AnnotationTypeList,\n\t\tAnnotationModel: AnnotationModel,\n\t\tAnnotationStyler: AnnotationStyler\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n/*eslint-env browser, amd*/\ndefine('orion/objects',[], function() {\n\tfunction mixin(target/*, source..*/) {\n\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\tfor (var j = 1, len = arguments.length; j < len; j++) {\n\t\t\tvar source = arguments[j];\n\t\t\tfor (var key in source) {\n\t\t\t\tif (hasOwnProperty.call(source, key)) {\n\t\t\t\t\ttarget[key] = source[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * @name orion.objects\n\t * @class Object-oriented helpers.\n\t */\n\treturn {\n\t\t/**\n\t\t * Creates a shallow clone of the given <code>object</code>.\n\t\t * @name orion.objects.clone\n\t\t * @function\n\t\t * @static\n\t\t * @param {Object|Array} object The object to clone. Must be a \"normal\" Object or Array. Other built-ins,\n\t\t * host objects, primitives, etc, will not work.\n\t\t * @returns {Object|Array} A clone of <code>object</code>.\n\t\t */\n\t\tclone: function(object) {\n\t\t\tif (Array.isArray(object)) {\n\t\t\t\treturn Array.prototype.slice.call(object);\n\t\t\t}\n\t\t\tvar clone = Object.create(Object.getPrototypeOf(object));\n\t\t\tmixin(clone, object);\n\t\t\treturn clone;\n\t\t},\n\t\t/**\n\t\t * Mixes all <code>source</code>'s own enumerable properties into <code>target</code>. Multiple source objects\n\t\t * can be passed as varargs.\n\t\t * @name orion.objects.mixin\n\t\t * @function\n\t\t * @static\n\t\t * @param {Object} target\n\t\t * @param {Object} source\n\t\t */\n\t\tmixin: mixin,\n\t\t/**\n\t\t * Wraps an object into an Array if necessary.\n\t\t * @name orion.objects.toArray\n\t\t * @function\n\t\t * @static\n\t\t * @param {Object} obj An object.\n\t\t * @returns {Array} Returns <code>obj</code> unchanged, if <code>obj</code> is an Array. Otherwise returns a 1-element Array\n\t\t * whose sole element is <code>obj</code>.\n\t\t */\n\t\ttoArray: function(o) {\n\t\t\treturn Array.isArray(o) ? o : [o];\n\t\t}\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2009, 2015 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License v1.0\n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution\n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html).\n *\n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/editor\", [ //$NON-NLS-0$\n\t'i18n!orion/editor/nls/messages', //$NON-NLS-0$\n\t'orion/editor/eventTarget', //$NON-NLS-0$\n\t'orion/editor/tooltip', //$NON-NLS-0$\n\t'orion/editor/annotations', //$NON-NLS-0$\n\t'orion/objects', //$NON-NLS-0$\n\t'orion/util' //$NON-NLS-0$\n], function(messages, mEventTarget, mTooltip, mAnnotations, objects, util) {\n\t\n\tvar AT = mAnnotations.AnnotationType;\n\n\tvar HIGHLIGHT_ERROR_ANNOTATION = \"orion.annotation.highlightError\"; //$NON-NLS-0$\n\n\t/**\n\t * @name orion.editor.BaseEditor\n\t * @class This is the base interface for text and visual editors based on a text buffer.\n\t *\n\t * @description Creates a new Base Editor with the given options.\n\t * @param {Object} options Creation options for this editor.\n\t * @param {Object} options.domNode\n\t * @param {Object} options.statusReporter\n\t *\n\t * @borrows orion.editor.EventTarget#addEventListener as #addEventListener\n\t * @borrows orion.editor.EventTarget#removeEventListener as #removeEventListener\n\t * @borrows orion.editor.EventTarget#dispatchEvent as #dispatchEvent\n\t */\n\tfunction BaseEditor(options) {\n\t\toptions = options || {};\n\t\tthis._domNode = options.domNode;\n\t\tthis._model = options.model;\n\t\tthis._undoStack = options.undoStack;\n\t\tthis._statusReporter = options.statusReporter;\n\t\tthis._title = null;\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonChanged: function(e) {\n\t\t\t\tself.onChanged(e);\n\t\t\t}\n\t\t};\n\t\tif (this._model) {\n\t\t\tthis._model.addEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t\t}\n\t\tthis.checkDirty();\n\t}\n\tBaseEditor.prototype = /** @lends orion.editor.BaseEditor.prototype */ {\n\t\t/**\n\t\t * Destroys the editor. Uninstall the editor view.\n\t\t */\n\t\tdestroy: function() {\n\t\t\tthis.uninstall();\n\t\t\tthis._statusReporter = this._domNode = null;\n\t\t\tif (this._model) {\n\t\t\t\tthis._model.removeEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\n\t\t/** @private */\n\t\tcheckDirty : function() {\n\t\t\tthis.setDirty(this._undoStack && !this._undoStack.isClean());\n\t\t},\n\t\t/**\n\t\t * Focus the the editor view. The default implementation does nothing.\n\t\t */\n\t\tfocus: function() {\n\t\t},\n\t\t/**\n\t\t * Returns the text model of the editor.\n\t\t *\n\t\t * @returns {orion.editor.TextModel} the text model of the view.\n\t\t */\n\t\tgetModel: function() {\n\t\t\treturn this._model;\n\t\t},\n\t\t/**\n\t\t * Returns the text for the given range.\n\t\t * <p>\n\t\t * The text does not include the character at the end offset.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} [start=0] the start offset of text range.\n\t\t * @param {Number} [end=char count] the end offset of text range.\n\t\t *\n\t\t * @see orion.editor.TextView#setText\n\t\t */\n\t\tgetText: function(start, end) {\n\t\t\treturn this.getModel().getText(start, end);\n\t\t},\n\t\t/**\n\t\t * Returns the editor title.\n\t\t *\n\t\t * @returns {String} the editor title.\n\t\t */\n\t\tgetTitle: function() {\n\t\t\treturn this._title;\n\t\t},\n\t\t/**\n\t\t * Returns the editor undo stack.\n\t\t *\n\t\t * @returns {orion.editor.UndoStack} the editor undo stack.\n\t\t */\n\t\tgetUndoStack: function() {\n\t\t\treturn this._undoStack;\n\t\t},\n\t\t/**\n\t\t * Creates the DOM hierarchy of the editor and add it to the document.\n\t\t */\n\t\tinstall: function() {\n\t\t\tthis.installed = true;\n\t\t},\n\t\t/**\n\t\t * Returns <code>true</code> if the editor is dirty; <code>false</code> otherwise.\n\t\t * @returns {Boolean} whether the editor is dirty\n\t\t */\n\t\tisDirty: function() {\n\t\t\tif (this._undoStack) return !this._undoStack.isClean();\n\t\t\treturn this._dirty;\n\t\t},\n\t\t/**\n\t\t * Marks the current state of the editor as clean. Meaning there are no unsaved modifications.\n\t\t */\n\t\tmarkClean: function() {\n\t\t\tthis.getUndoStack().markClean();\n\t\t\tthis.setDirty(false);\n\t\t},\n\t\t/**\n\t\t * Called when the dirty state of the editor changes.\n\t\t * @param {Event} dirtyChangedEvent\n\t\t */\n\t\tonDirtyChanged: function(dirtyChangedEvent) {\n\t\t\treturn this.dispatchEvent(dirtyChangedEvent);\n\t\t},\n\t\t/**\n\t\t * Called when the editor's contents have been changed or saved.\n\t\t * @param {Event} inputChangedEvent\n\t\t */\n\t\tonInputChanged: function (inputChangedEvent) {\n\t\t\treturn this.dispatchEvent(inputChangedEvent);\n\t\t},\n\t\t/**\n\t\t * Called when the editor's text model has been changed.\n\t\t * @param {Event} inputChangedEvent\n\t\t */\n\t\tonChanged: function (modelChangedEvent) {\n\t\t\tthis.checkDirty();\n\t\t},\n\t\t/**\n\t\t * Report the message to the user.\n\t\t *\n\t\t * @param {String} message the message to show\n\t\t * @param {String} [type] the message type. Either normal or \"progress\" or \"error\";\n\t\t * @param {Boolean} [isAccessible] If <code>true</code>, a screen reader will read this message.\n\t\t * Otherwise defaults to the domNode default.\n\t\t */\n\t\treportStatus: function(message, type, isAccessible) {\n\t\t\tif (this._statusReporter) {\n\t\t\t\tthis._statusReporter(message, type, isAccessible);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Resizes the editor view. The default implementation does nothing.\n\t\t */\n\t\tresize: function() {\n\t\t},\n\t\t/**\n\t\t * Sets whether the editor is dirty.\n\t\t *\n\t\t * @param {Boolean} dirty\n\t\t */\n\t\tsetDirty: function(dirty) {\n\t\t\tif (this._dirty === dirty) { return; }\n\t\t\tthis._dirty = dirty;\n\t\t\tthis.onDirtyChanged({type: \"DirtyChanged\"}); //$NON-NLS-0$\n\t\t},\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_setModelText: function(contents) {\n\t\t\tif (this._model) {\n\t\t\t\tthis._model.setText(contents);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets the editor's contents.\n\t\t *\n\t\t * @param {String} title the editor title\n\t\t * @param {String} message an error message\n\t\t * @param {String} contents the editor contents\n\t\t * @param {Boolean} contentsSaved whether the editor contents was saved.\n\t\t */\n\t\tsetInput: function(title, message, contents, contentsSaved) {\n\t\t\tthis._title = title;\n\t\t\tif (!contentsSaved) {\n\t\t\t\tif (message) {\n\t\t\t\t\tthis.reportStatus(message, \"error\"); //$NON-NLS-0$\n\t\t\t\t} else {\n\t\t\t\t\tif (contents !== null && contents !== undefined) {\n\t\t\t\t\t\tif (typeof contents === \"string\") { //$NON-NLS-0$\n\t\t\t\t\t\t\tthis._setModelText(contents);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._undoStack) {\n\t\t\t\t\t\t\tthis._undoStack.reset();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.checkDirty();\n\t\t\tthis.onInputChanged({\n\t\t\t\ttype: \"InputChanged\", //$NON-NLS-0$\n\t\t\t\ttitle: title,\n\t\t\t\tmessage: message,\n\t\t\t\tcontents: contents,\n\t\t\t\tcontentsSaved: contentsSaved\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Replaces the text in the given range with the given text.\n\t\t * <p>\n\t\t * The character at the end offset is not replaced.\n\t\t * </p>\n\t\t *\n\t\t * @param {String} text the new text.\n\t\t * @param {Number} [start=0] the start offset of text range.\n\t\t * @param {Number} [end=char count] the end offset of text range.\n\t\t */\n\t\tsetText: function(text, start, end) {\n\t\t\tthis.getModel().setText(text, start, end);\n\t\t},\n\t\t/**\n\t\t * Removes the DOM hierarchy of the editor from the document.\n\t\t */\n\t\tuninstall: function() {\n\t\t\tthis.installed = false;\n\t\t}\n\t};\n\tmEventTarget.EventTarget.addMixin(BaseEditor.prototype);\n\n\t/**\n\t * @name orion.editor.Editor\n\t * @augments orion.editor.BaseEditor\n\t * @class An <code>Editor</code> is a user interface for editing text that provides additional features over the basic {@link orion.editor.TextView}.\n\t * Some of <code>Editor</code>'s features include:\n\t * <ul>\n\t * <li>Additional actions and key bindings for editing text</li>\n\t * <li>Content assist</li>\n\t * <li>Find and Incremental Find</li>\n\t * <li>Rulers for displaying line numbers and annotations</li>\n\t * <li>Status reporting</li>\n\t * </ul>\n\t *\n\t * @description Creates a new Editor with the given options.\n\t * @param {Object} options Options controlling the features of this Editor.\n\t * @param {Object} options.annotationFactory\n\t * @param {Object} options.contentAssistFactory\n\t * @param {Object} options.domNode\n\t * @param {Object} options.keyBindingFactory\n\t * @param {Object} options.lineNumberRulerFactory\n\t * @param {Object} options.zoomRulerFactory\n\t * @param {Object} options.foldingRulerFactory\n\t * @param {Object} options.statusReporter\n\t * @param {Object} options.textViewFactory\n\t * @param {Object} options.undoStackFactory\n\t * @param {Object} options.textDNDFactory\n\t * @param {Object} options.hoverFactory\n\t */\n\tfunction Editor(options) {\n\t\toptions = options || {};\n\t\tBaseEditor.call(this, options);\n\t\tthis._textViewFactory = options.textViewFactory;\n\t\tthis._undoStackFactory = options.undoStackFactory;\n\t\tthis._textDNDFactory = options.textDNDFactory;\n\t\tthis._annotationFactory = options.annotationFactory;\n\t\tthis._zoomRulerFactory = options.zoomRulerFactory;\n\t\tthis._foldingRulerFactory = options.foldingRulerFactory;\n\t\tthis._lineNumberRulerFactory = options.lineNumberRulerFactory;\n\t\tthis._contentAssistFactory = options.contentAssistFactory;\n\t\tthis._keyBindingFactory = options.keyBindingFactory;\n\t\tthis._hoverFactory = options.hoverFactory;\n\t\tthis._annotationStyler = null;\n\t\tthis._annotationModel = null;\n\t\tthis._annotationRuler = null;\n\t\tthis._lineNumberRuler = null;\n\t\tthis._overviewRuler = null;\n\t\tthis._zoomRuler = null;\n\t\tthis._foldingRuler = null;\n\t\tthis._contentAssist = null;\n\t}\n\tEditor.prototype = new BaseEditor();\n\tobjects.mixin(Editor.prototype, /** @lends orion.editor.Editor.prototype */ {\n\t\t/**\n\t\t * Destroys the editor.\n\t\t */\n\t\tdestroy: function() {\n\t\t\tBaseEditor.prototype.destroy.call(this);\n\t\t\tthis._textViewFactory = this._undoStackFactory = this._textDNDFactory = \n\t\t\tthis._annotationFactory = this._foldingRulerFactory = this._lineNumberRulerFactory = \n\t\t\tthis._contentAssistFactory = this._keyBindingFactory = this._hoverFactory = this._zoomRulerFactory = null;\n\t\t},\n\t\t/**\n\t\t * Returns the annotation model of the editor.\n\t\t *\n\t\t * @returns {orion.editor.AnnotationModel}\n\t\t */\n\t\tgetAnnotationModel: function() {\n\t\t\treturn this._annotationModel;\n\t\t},\n\t\t/**\n\t\t * Returns the annotation ruler of the editor.\n\t\t *\n\t\t * @returns {orion.editor.AnnotationRuler}\n\t\t */\n\t\tgetAnnotationRuler: function() {\n\t\t\treturn this._annotationRuler;\n\t\t},\n\t\t/**\n\t\t * Returns the annotation styler of the editor.\n\t\t *\n\t\t * @returns {orion.editor.AnnotationStyler}\n\t\t */\n\t\tgetAnnotationStyler: function() {\n\t\t\treturn this._annotationStyler;\n\t\t},\n\t\t/**\n\t\t * Returns the content assist of the editor.\n\t\t *\n\t\t * @returns {orion.editor.LineNumberRuler}\n\t\t */\n\t\tgetContentAssist: function() {\n\t\t\treturn this._contentAssist;\n\t\t},\n\t\t/**\n\t\t * Returns the folding ruler of the editor.\n\t\t *\n\t\t * @returns {orion.editor.FoldingRuler}\n\t\t */\n\t\tgetFoldingRuler: function() {\n\t\t\treturn this._foldingRuler;\n\t\t},\n\t\t/**\n\t\t * Returns the line number ruler of the editor.\n\t\t *\n\t\t * @returns {orion.editor.LineNumberRuler}\n\t\t */\n\t\tgetLineNumberRuler: function() {\n\t\t\treturn this._lineNumberRuler;\n\t\t},\n\t\t/**\n\t\t * Returns the Tooltip instance for this editor\n\t\t *\n\t\t * @returns {orion.editor.Tooltip}\n\t\t*/\n\t\tgetTooltip: function() {\n\t\t\treturn mTooltip.Tooltip.getTooltip(this._textView);\n\t\t},\n\t\t/**\n\t\t * Returns the zoom ruler of the editor.\n\t\t *\n\t\t * @returns {orion.editor.LineNumberRuler}\n\t\t */\n\t\tgetZoomRuler: function() {\n\t\t\treturn this._zoomRuler;\n\t\t},\n\t\t/**\n\t\t * Returns the base text model of this editor.\n\t\t *\n\t\t * @returns {orion.editor.TextModel}\n\t\t */\n\t\tgetModel: function() {\n\t\t\tif (!this._textView) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar model = this._textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\treturn model;\n\t\t},\n\t\t/**\n\t\t * Returns the overview ruler of the editor.\n\t\t *\n\t\t * @returns {orion.editor.OverviewRuler}\n\t\t */\n\t\tgetOverviewRuler: function() {\n\t\t\treturn this._overviewRuler;\n\t\t},\n\t\t/**\n\t\t * Returns the underlying <code>TextView</code> used by this editor.\n\t\t * @returns {orion.editor.TextView} the editor text view.\n\t\t */\n\t\tgetTextView: function() {\n\t\t\treturn this._textView;\n\t\t},\n\t\t/**\n\t\t * Returns the editor's key modes.\n\t\t *\n\t\t * @returns {Array} the editor key modes.\n\t\t */\n\t\tgetKeyModes: function() {\n\t\t\treturn this._textView.getKeyModes();\n\t\t},\n\t\t/**\n\t\t * Returns the editor source code actions.\n\t\t *\n\t\t * @returns {orion.editor.sourceCodeActions}\n\t\t */\n\t\tgetSourceCodeActions: function() {\n\t\t\treturn this._sourceCodeActions;\n\t\t},\n\t\t/**\n\t\t * Returns the editor linked mode.\n\t\t *\n\t\t * @returns {orion.editor.LinkedMode}\n\t\t */\n\t\tgetLinkedMode: function() {\n\t\t\treturn this._linkedMode;\n\t\t},\n\t\t/**\n\t\t * Returns the editor text actions.\n\t\t *\n\t\t * @returns {orion.editor.textActions}\n\t\t */\n\t\tgetTextActions: function() {\n\t\t\treturn this._textActions;\n\t\t},\n\t\t/**\n\t\t * Gives focus to the text view.\n\t\t */\n\t\tfocus: function() {\n\t\t\tif (this._textView) {\n\t\t\t\tthis._textView.focus();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Resizes the text view.\n\t\t */\n\t\tresize: function() {\n\t\t\tif (this._textView) {\n\t\t\t\tthis._textView.resize();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets whether the annotation ruler is visible.\n\t\t *\n\t\t * @param {Boolean} visible <code>true</code> to show ruler, <code>false</code> otherwise\n\t\t */\n\t\tsetAnnotationRulerVisible: function(visible, force) {\n\t\t\tif (this._annotationRulerVisible === visible && !force) { return; }\n\t\t\tthis._annotationRulerVisible = visible;\n\t\t\tif (!this._annotationRuler) { return; }\n\t\t\tvar textView = this._textView;\n\t\t\tif (visible) {\n\t\t\t\ttextView.addRuler(this._annotationRuler, 0);\n\t\t\t} else {\n\t\t\t\ttextView.removeRuler(this._annotationRuler);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets whether the folding ruler is visible.\n\t\t *\n\t\t * @param {Boolean} visible <code>true</code> to show ruler, <code>false</code> otherwise\n\t\t */\n\t\tsetFoldingRulerVisible: function(visible, force) {\n\t\t\tif (this._foldingRulerVisible === visible && !force) { return; }\n\t\t\tthis._foldingRulerVisible = visible;\n\t\t\tif (!this._foldingRuler) { return; }\n\t\t\tvar textView = this._textView;\n\t\t\tif (!textView.getModel().getBaseModel) { return; }\n\t\t\tif (visible) {\n\t\t\t\ttextView.addRuler(this._foldingRuler);\n\t\t\t} else {\n\t\t\t\ttextView.removeRuler(this._foldingRuler);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets whether the line numbering ruler is visible.\n\t\t *\n\t\t * @param {Boolean} visible <code>true</code> to show ruler, <code>false</code> otherwise\n\t\t */\n\t\tsetLineNumberRulerVisible: function(visible, force) {\n\t\t\tif (this._lineNumberRulerVisible === visible && !force) { return; }\n\t\t\tthis._lineNumberRulerVisible = visible;\n\t\t\tif (!this._lineNumberRuler) { return; }\n\t\t\tvar textView = this._textView;\n\t\t\tif (visible) {\n\t\t\t\ttextView.addRuler(this._lineNumberRuler, !this._annotationRulerVisible ? 0 : 1);\n\t\t\t} else {\n\t\t\t\ttextView.removeRuler(this._lineNumberRuler);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets whether the overview ruler is visible.\n\t\t *\n\t\t * @param {Boolean} visible <code>true</code> to show ruler, <code>false</code> otherwise\n\t\t */\n\t\tsetOverviewRulerVisible: function(visible, force) {\n\t\t\tif (this._overviewRulerVisible === visible && !force) { return; }\n\t\t\tthis._overviewRulerVisible = visible;\n\t\t\tif (!this._overviewRuler) { return; }\n\t\t\tvar textView = this._textView;\n\t\t\tif (visible) {\n\t\t\t\ttextView.addRuler(this._overviewRuler);\n\t\t\t} else {\n\t\t\t\ttextView.removeRuler(this._overviewRuler);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets whether the zoom ruler is visible.\n\t\t *\n\t\t * @param {Boolean} visible <code>true</code> to show ruler, <code>false</code> otherwise\n\t\t */\n\t\tsetZoomRulerVisible: function(visible, force) {\n\t\t\tif (this._zoomRulerVisible === visible && !force) { return; }\n\t\t\tthis._zoomRulerVisible = visible;\n\t\t\tif (!this._zoomRuler) { return; }\n\t\t\tvar textView = this._textView;\n\t\t\tif (visible) {\n\t\t\t\ttextView.addRuler(this._zoomRuler);\n\t\t\t} else {\n\t\t\t\ttextView.removeRuler(this._zoomRuler);\n\t\t\t}\n\t\t},\n\n\t\tmapOffset: function(offset, parent) {\n\t\t\tvar textView = this._textView;\n\t\t\tvar model = textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\toffset = model.mapOffset(offset, parent);\n\t\t\t}\n\t\t\treturn offset;\n\t\t},\n\t\t/**\n\t\t * @name getLineAtOffset\n\t\t * @description Returns the line number corresponding to the given offset in the source\n\t\t * @function\n\t\t * @public\n\t\t * @memberof orion.editor.Editor\n\t\t * @param {Number} offset The offset into the source\n\t\t * @returns {Number} The line number corresponding to the given offset or <code>-1</code> if out of range\n\t\t * @since 5.0\n\t\t */\n\t\tgetLineAtOffset: function(offset) {\n\t\t\treturn this.getModel().getLineAtOffset(this.mapOffset(offset));\n\t\t},\n\t\t/**\n\t\t * @name getLineStart\n\t\t * @description Compute the editor start offset of the given line number\n\t\t * @function\n\t\t * @public\n\t\t * @memberof orion.editor.TextView\n\t\t * @param {Number} line The line number in the editor\n\t\t * @returns {Number} Returns the start offset of the given line number in the editor.\n\t\t * @since 5.0\n\t\t */\n\t\tgetLineStart: function(line) {\n\t\t\treturn this.getModel().getLineStart(line);\n\t\t},\n\t\tgetCaretOffset: function() {\n\t\t\treturn this.mapOffset(this._textView.getCaretOffset());\n\t\t},\n\t\t\n\t\tgetSelection: function() {\n\t\t\tvar textView = this._textView;\n\t\t\tvar selection = textView.getSelection();\n\t\t\tvar model = textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tselection.start = model.mapOffset(selection.start);\n\t\t\t\tselection.end = model.mapOffset(selection.end);\n\t\t\t}\n\t\t\treturn selection;\n\t\t},\n\n\t\tgetSelections: function() {\n\t\t\tvar textView = this._textView;\n\t\t\tvar model = textView.getModel();\n\t\t\tvar selections = textView.getSelections();\n\t\t\tselections.forEach(function(selection) {\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tselection.start = model.mapOffset(selection.start);\n\t\t\t\t\tselection.end = model.mapOffset(selection.end);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selections;\n\t\t},\n\n\t\t_expandOffset: function(offset) {\n\t\t\tvar model = this._textView.getModel();\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tif (!annotationModel || !model.getBaseModel) { return; }\n\t\t\tvar annotations = annotationModel.getAnnotations(offset, offset + 1);\n\t\t\twhile (annotations.hasNext()) {\n\t\t\t\tvar annotation = annotations.next();\n\t\t\t\tif (annotation.type === AT.ANNOTATION_FOLDING) {\n\t\t\t\t\tif (annotation.expand) {\n\t\t\t\t\t\tannotation.expand();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsetCaretOffset: function(caretOffset, show, callback) {\n\t\t\tvar textView = this._textView;\n\t\t\tvar model = textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tthis._expandOffset(caretOffset);\n\t\t\t\tcaretOffset = model.mapOffset(caretOffset, true);\n\t\t\t}\n\t\t\ttextView.setCaretOffset(caretOffset, show, callback);\n\t\t},\n\n\t\tsetText: function(text, start, end, show, callback) {\n\t\t\tvar textView = this._textView;\n\t\t\tvar model = textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tif (start !== undefined) {\n\t\t\t\t\tthis._expandOffset(start);\n\t\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\t}\n\t\t\t\tif (end !== undefined) {\n\t\t\t\t\tthis._expandOffset(end);\n\t\t\t\t\tend = model.mapOffset(end, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttextView.setText(text, start, end, show, callback);\n\t\t},\n\n\t\tsetSelection: function(start, end, show, callback) {\n\t\t\tvar textView = this._textView;\n\t\t\tvar model = textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tthis._expandOffset(start);\n\t\t\t\tthis._expandOffset(end);\n\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\tend = model.mapOffset(end, true);\n\t\t\t}\n\t\t\ttextView.setSelection(start, end, show, callback);\n\t\t},\n\t\tsetSelections: function(ranges, show, callback) {\n\t\t\tvar self = this;\n\t\t\tvar textView = this._textView;\n\t\t\tvar model = textView.getModel();\n\t\t\tranges.forEach(function(range) {\n\t\t\t\tvar start = range.start;\n\t\t\t\tvar end = range.end;\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tself._expandOffset(start);\n\t\t\t\t\tself._expandOffset(end);\n\t\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\t\tend = model.mapOffset(end, true);\n\t\t\t\t}\n\t\t\t\trange.start = start;\n\t\t\t\trange.end = end;\n\t\t\t});\n\t\t\ttextView.setSelections(ranges, show, callback);\n\t\t},\n\n\t\t/**\n\t\t * @param {Number} start\n\t\t * @param {Number} [end]\n\t\t * @param {function} [callback] if callback is specified, scrolling to show the selection is animated and callback is called when the animation is done.\n\t\t * @param {Boolean} [focus=true] whether the text view should be focused when the selection is done.\n\t\t * @private\n\t\t * @deprecated use #setSelection instead\n\t\t */\n\t\tmoveSelection: function(start, end, callback, focus) {\n\t\t\tend = end || start;\n\t\t\tvar textView = this._textView;\n\t\t\tthis.setSelection(start, end, 1 / 3, function() {\n\t\t\t\tif (focus === undefined || focus) {\n\t\t\t\t\ttextView.focus();\n\t\t\t\t}\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/** @private */\n\t\t_getTooltipInfo: function(x, y) {\n\t\t\tvar textView = this._textView;\n\t\t\tvar annotationModel = this.getAnnotationModel();\n\t\t\tif (!annotationModel) { return null; }\n\t\t\tvar annotationStyler = this._annotationStyler;\n\t\t\tif (!annotationStyler) { return null; }\n\t\t\tif (!textView.isValidTextPosition(x, y)) { return null; }\n\t\t\tvar offset = textView.getOffsetAtLocation(x, y);\n\t\t\tif (offset === -1) { return null; }\n\t\t\toffset = this.mapOffset(offset);\n\t\t\tvar annotations = annotationStyler.getAnnotationsByType(annotationModel, offset, offset + 1);\n\t\t\tvar rangeAnnotations = [];\n\t\t\tfor (var i = 0; i < annotations.length; i++) {\n\t\t\t\tif (annotations[i].rangeStyle) {\n\t\t\t\t\trangeAnnotations.push(annotations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar info = {\n\t\t\t\tcontents: rangeAnnotations,\n\t\t\t\tposition: \"below\", //$NON-NLS-0$\n\t\t\t\tcontext: {source: \"editor\", offset: offset} //$NON-NLS-0$\n\t\t\t};\n\t\t\treturn info;\n\t\t},\n\n\t\t/** @private */\n\t\t_highlightCurrentLine: function(newSelections, oldSelections) {\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tif (!annotationModel) { return; }\n\t\t\tvar textView = this._textView;\n\t\t\tif (textView.getOptions(\"singleMode\")) { return; } //$NON-NLS-0$\n\t\t\toldSelections = Array.isArray(oldSelections) ? oldSelections : [oldSelections];\n\t\t\tnewSelections = Array.isArray(newSelections) ? newSelections : [newSelections];\n\t\t\tvar model = textView.getModel();\n\t\t\tfunction getHighlightLines(selections) {\n\t\t\t\tvar lines = {};\n\t\t\t\tif (selections && selections.some(function(selection) {\n\t\t\t\t\tif (selection && selection.isEmpty()) {\n\t\t\t\t\t\tlines[model.getLineAtOffset(selection.start).toString()] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t})) return {};\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t\tvar oldLines = getHighlightLines(oldSelections);\n\t\t\tvar newLines = getHighlightLines(newSelections);\n\t\t\tfunction compare(o, n) {\n\t\t\t\tfor (var p1 in o) {\n\t\t\t\t\tif (!n[p1]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!(compare(oldLines, newLines) || compare(newLines, oldLines))) return;\n\t\t\tvar remove = this._currentLineAnnotations;\n\t\t\tvar add = [];\n\t\t\tfor (var p in newLines) {\n\t\t\t\tvar lineIndex = p >> 0;\n\t\t\t\tvar start = model.getLineStart(lineIndex);\n\t\t\t\tvar end = model.getLineEnd(lineIndex);\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tstart = model.mapOffset(start);\n\t\t\t\t\tend = model.mapOffset(end);\n\t\t\t\t}\n\t\t\t\tvar type = AT.ANNOTATION_CURRENT_LINE;\n\t\t\t\tvar annotation = AT.createAnnotation(type, start, end);\n\t\t\t\tadd.push(annotation);\n\t\t\t}\n\t\t\tthis._currentLineAnnotations = add;\n\t\t\tannotationModel.replaceAnnotations(remove, add);\n\t\t},\n\n\t\t/**\n\t\t * Creates the underlying TextView and installs the editor's features.\n\t\t */\n\t\tinstallTextView: function() {\n\t\t\tthis.install();\n\t\t},\n\n\t\tinstall : function() {\n\t\t\tif (this._textView) { return; }\n\n\t\t\t// Create textView and install optional features\n\t\t\tthis._textView = this._textViewFactory();\n\t\t\tif (this._undoStackFactory) {\n\t\t\t\tthis._undoStack = this._undoStackFactory.createUndoStack(this);\n\t\t\t\tthis._textView.setOptions({undoStack: this._undoStack});\n\t\t\t\tthis.checkDirty();\n\t\t\t}\n\t\t\tif (this._textDNDFactory) {\n\t\t\t\tthis._textDND = this._textDNDFactory.createTextDND(this, this._undoStack);\n\t\t\t}\n\t\t\tif (this._contentAssistFactory) {\n\t\t\t\tvar contentAssistMode = this._contentAssistFactory.createContentAssistMode(this);\n\t\t\t\tthis._contentAssist = contentAssistMode.getContentAssist();\n\t\t\t}\n\n\t\t\tvar tooltip = mTooltip.Tooltip.getTooltip(this._textView);\n\t\t\tif (this._hoverFactory) {\n\t\t\t\tthis._hover = this._hoverFactory.createHover(this);\n\t\t\t\ttooltip.hover = this._hover;\n\t\t\t}\n\t\t\t\n\t\t\tvar editor = this, textView = this._textView;\n\n\t\t\tvar self = this;\n\t\t\tthis._listener = {\n\t\t\t\tonModelChanged: function(e) {\n\t\t\t\t\tself.checkDirty();\n\t\t\t\t},\n\t\t\t\tonMouseOver: function(e) {\n\t\t\t\t\tself._listener.onMouseMove(e);\n\t\t\t\t},\n\t\t\t\tonMouseDown: function(e) {\n\t\t\t\t\tself._listener.mouseDown = true;\n\t\t\t\t},\n\t\t\t\tonMouseUp: function(e) {\n\t\t\t\t\tself._listener.mouseDown = false;\n\t\t\t\t},\n\t\t\t\tonMouseMove: function(e) {\n\t\t\t\t\tif (!tooltip || self._listener.mouseDown) { return; }\n\n\t\t\t\t\t// Prevent spurious mouse event (e.g. on a scroll)\t\t\t\t\t\n\t\t\t\t\tif (e.event.clientX === self._listener.lastMouseX\n\t\t\t\t\t\t&& e.event.clientY === self._listener.lastMouseY) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tself._listener.lastMouseX = e.event.clientX;\n\t\t\t\t\tself._listener.lastMouseY = e.event.clientY;\n\n\t\t\t\t\tif (self._hoverTimeout) {\n\t\t\t\t\t\twindow.clearTimeout(self._hoverTimeout);\n\t\t\t\t\t\tself._hoverTimeout = null;\n\t\t\t\t\t}\n\t\t\t\t\tself._hoverTimeout = window.setTimeout(function() {\n\t\t\t\t\t\tself._hoverTimeout = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Re-check incase editor closed...\n\t\t\t\t\t\tif (!self._listener){\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttooltip.onHover({\n\t\t\t\t\t\t\ty: e.y,\n\t\t\t\t\t\t\tx: e.x,\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tgetTooltipInfo: function() {\n\t\t\t\t\t\t\t\treturn self._getTooltipInfo(this.x, this.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, e.x, e.y);\n\t\t\t\t\t}, 175);\n\t\t\t\t},\n\t\t\t\tonMouseOut: function(e) {\n\t\t\t\t\t// When mouse leaves the editor, ignore any pending onMouseMove events\n\t\t\t\t\tif (self._hoverTimeout) {\n\t\t\t\t\t\twindow.clearTimeout(self._hoverTimeout);\n\t\t\t\t\t\tself._hoverTimeout = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonScroll: function(e) {\n\t\t\t\t\tif (!tooltip) { return; }\n\t\t\t\t\ttooltip.hide();\n\t\t\t\t},\n\t\t\t\tonSelection: function(e) {\n\t\t\t\t\tif (tooltip) { tooltip.hide(); }\n\t\t\t\t\tself._updateCursorStatus();\n\t\t\t\t\tself._highlightCurrentLine(e.newValue, e.oldValue);\n\t\t\t\t}\n\t\t\t};\n\t\t\ttextView.addEventListener(\"ModelChanged\", this._listener.onModelChanged); //$NON-NLS-0$\n\t\t\ttextView.addEventListener(\"Selection\", this._listener.onSelection); //$NON-NLS-0$\n\t\t\ttextView.addEventListener(\"MouseOver\", this._listener.onMouseOver); //$NON-NLS-0$\n\t\t\ttextView.addEventListener(\"MouseOut\", this._listener.onMouseOut); //$NON-NLS-0$\n\t\t\ttextView.addEventListener(\"MouseDown\", this._listener.onMouseDown); //$NON-NLS-0$\n\t\t\ttextView.addEventListener(\"MouseUp\", this._listener.onMouseUp); //$NON-NLS-0$\n\t\t\ttextView.addEventListener(\"MouseMove\", this._listener.onMouseMove); //$NON-NLS-0$\n\t\t\ttextView.addEventListener(\"Scroll\", this._listener.onScroll); //$NON-NLS-0$\n\n\t\t\t// Set up keybindings\n\t\t\tif (this._keyBindingFactory) {\n\t\t\t\tvar keyBindings;\n\t\t\t\tif (typeof this._keyBindingFactory === \"function\") { //$NON-NLS-0$\n\t\t\t\t\tkeyBindings = this._keyBindingFactory(this, this.getKeyModes(), this._undoStack, this._contentAssist);\n\t\t\t\t} else {\n\t\t\t\t\tkeyBindings = this._keyBindingFactory.createKeyBindings(editor, this._undoStack, this._contentAssist);\n\t\t\t\t}\n\t\t\t\tif (keyBindings) {\n\t\t\t\t\tthis._textActions = keyBindings.textActions;\n\t\t\t\t\tthis._linkedMode = keyBindings.linkedMode;\n\t\t\t\t\tthis._sourceCodeActions = keyBindings.sourceCodeActions;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar addRemoveBookmark = function(lineIndex, e) {\n\t\t\t\tif (lineIndex === undefined) { return; }\n\t\t\t\tif (lineIndex === -1) { return; }\n\t\t\t\tvar view = this.getView();\n\t\t\t\tvar viewModel = view.getModel();\n\t\t\t\tvar annotationModel = this.getAnnotationModel();\n\t\t\t\tvar lineStart = editor.mapOffset(viewModel.getLineStart(lineIndex));\n\t\t\t\tvar lineEnd = editor.mapOffset(viewModel.getLineEnd(lineIndex));\n\t\t\t\tvar annotations = annotationModel.getAnnotations(lineStart, lineEnd);\n\t\t\t\tvar bookmark = null;\n\t\t\t\twhile (annotations.hasNext()) {\n\t\t\t\t\tvar annotation = annotations.next();\n\t\t\t\t\tif (annotation.type === AT.ANNOTATION_BOOKMARK) {\n\t\t\t\t\t\tbookmark = annotation;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bookmark) {\n\t\t\t\t\tannotationModel.removeAnnotation(bookmark);\n\t\t\t\t} else {\n\t\t\t\t\tbookmark = AT.createAnnotation(AT.ANNOTATION_BOOKMARK, lineStart, lineEnd, editor.getText(lineStart, lineEnd));\n\t\t\t\t\tannotationModel.addAnnotation(bookmark);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Create rulers, annotation model and styler\n\t\t\tif (this._annotationFactory) {\n\t\t\t\tvar textModel = textView.getModel();\n\t\t\t\tif (textModel.getBaseModel) { textModel = textModel.getBaseModel(); }\n\t\t\t\tthis._annotationModel = this._annotationFactory.createAnnotationModel(textModel);\n\t\t\t\tif (this._annotationModel) {\n\t\t\t\t\tvar styler = this._annotationStyler = this._annotationFactory.createAnnotationStyler(textView, this._annotationModel);\n\t\t\t\t\tif (styler) {\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_CURRENT_SEARCH);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_MATCHING_SEARCH);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_ERROR);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_WARNING);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_MATCHING_BRACKET);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_CURRENT_BRACKET);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_CURRENT_LINE);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_READ_OCCURRENCE);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_WRITE_OCCURRENCE);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_SELECTED_LINKED_GROUP);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_CURRENT_LINKED_GROUP);\n\t\t\t\t\t\tstyler.addAnnotationType(AT.ANNOTATION_LINKED_GROUP);\n\t\t\t\t\t\tstyler.addAnnotationType(HIGHLIGHT_ERROR_ANNOTATION);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rulers = this._annotationFactory.createAnnotationRulers(this._annotationModel);\n\t\t\t\tvar ruler = this._annotationRuler = rulers.annotationRuler;\n\t\t\t\tif (ruler) {\n\t\t\t\t\truler.onDblClick = addRemoveBookmark;\n\t\t\t\t\truler.setMultiAnnotationOverlay({html: \"<div class='annotationHTML overlay'></div>\"}); //$NON-NLS-0$\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_ERROR);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_WARNING);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_TASK);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_BOOKMARK);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_DIFF_ADDED);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_DIFF_DELETED);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_DIFF_MODIFIED);\n\t\t\t\t}\n\t\t\t\tthis.setAnnotationRulerVisible(this._annotationRulerVisible || this._annotationRulerVisible === undefined, true);\n\n\t\t\t\t// Overview Ruler Annotation Type\n\t\t\t\truler = this._overviewRuler = rulers.overviewRuler;\n\t\t\t\tif (ruler) {\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_CURRENT_SEARCH);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_MATCHING_SEARCH);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_READ_OCCURRENCE);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_WRITE_OCCURRENCE);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_CURRENT_BLAME);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_ERROR);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_WARNING);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_TASK);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_BOOKMARK);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_MATCHING_BRACKET);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_CURRENT_BRACKET);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_CURRENT_LINE);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_DIFF_ADDED);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_DIFF_DELETED);\n\t\t\t\t\truler.addAnnotationType(AT.ANNOTATION_DIFF_MODIFIED);\n\n\t\t\t\t}\n\t\t\t\tthis.setOverviewRulerVisible(this._overviewRulerVisible || this._overviewRulerVisible === undefined, true);\n\t\t\t}\n\n\t\t\tif (this._zoomRulerFactory) {\n\t\t\t\tthis._zoomRuler = this._zoomRulerFactory.createZoomRuler(this._annotationModel);\n\t\t\t\tthis.setZoomRulerVisible(this._zoomRulerVisible, true);\n\t\t\t}\n\n\t\t\tif (this._lineNumberRulerFactory) {\n\t\t\t\tthis._lineNumberRuler = this._lineNumberRulerFactory.createLineNumberRuler(this._annotationModel);\n\t\t\t\tthis._lineNumberRuler.addAnnotationType(AT.ANNOTATION_CURRENT_BLAME);\n\t\t\t\tthis._lineNumberRuler.addAnnotationType(AT.ANNOTATION_BLAME);\n\t\t        this._lineNumberRuler.addAnnotationType(AT.ANNOTATION_DIFF_ADDED);\n\t\t        this._lineNumberRuler.addAnnotationType(AT.ANNOTATION_DIFF_MODIFIED);\n\t\t        this._lineNumberRuler.addAnnotationType(AT.ANNOTATION_DIFF_DELETED);\n\t\t\t\tthis._lineNumberRuler.onDblClick = addRemoveBookmark;\n\t\t\t\tthis.setLineNumberRulerVisible(this._lineNumberRulerVisible || this._lineNumberRulerVisible === undefined, true);\n\t\t\t}\n\n\t\t\tif (this._foldingRulerFactory) {\n\t\t\t\tthis._foldingRuler = this._foldingRulerFactory.createFoldingRuler(this._annotationModel);\n\t\t\t\tthis._foldingRuler.addAnnotationType(AT.ANNOTATION_FOLDING);\n\t\t\t\tthis.setFoldingRulerVisible(this._foldingRulerVisible || this._foldingRulerVisible === undefined, true);\n\t\t\t}\n\n\t\t\tvar textViewInstalledEvent = {\n\t\t\t\ttype: \"TextViewInstalled\", //$NON-NLS-0$\n\t\t\t\ttextView: textView\n\t\t\t};\n\t\t\tthis.dispatchEvent(textViewInstalledEvent);\n\t\t\tBaseEditor.prototype.install.call(this);\n\t\t},\n\n\t\t/**\n\t\t * Destroys the underlying TextView.\n\t\t */\n\t\tuninstallTextView: function() {\n\t\t\tthis.uninstall();\n\t\t},\n\n\t\tuninstall: function() {\n\t\t\tvar textView = this._textView;\n\t\t\tif (!textView) { return; }\n\n\t\t\ttextView.destroy();\n\n\t\t\tif (this._annotationModel) {\n\t\t\t\tthis._annotationModel.setTextModel(null);\n\t\t\t}\n\t\t\tthis._textView = this._undoStack = this._textDND = this._contentAssist =\n\t\t\t\tthis._listener = this._annotationModel = this._annotationStyler =\n\t\t\t\tthis._annotationRuler = this._overviewRuler = this._zoomRuler = this._lineNumberRuler =\n\t\t\t\tthis._foldingRuler = this._currentLineAnnotations = this._title = null;\n\t\t\tthis._dirty = false;\n\t\t\tthis._foldingRulerVisible = this._overviewRulerVisible = this._zoomRulerVisible =\n\t\t\t\tthis._lineNumberRulerVisible = this._annotationRulerVisible = undefined;\n\n\t\t\tvar textViewUninstalledEvent = {\n\t\t\t\ttype: \"TextViewUninstalled\", //$NON-NLS-0$\n\t\t\t\ttextView: textView\n\t\t\t};\n\t\t\tthis.dispatchEvent(textViewUninstalledEvent);\n\t\t\tBaseEditor.prototype.uninstall.call(this);\n\t\t},\n\n\t\t_updateCursorStatus: function() {\n\t\t\t// If we are in a mode and it owns status reporting, we bail out from reporting the cursor position.\n\t\t\tvar keyModes = this.getKeyModes();\n\t\t\tfor (var i=0; i<keyModes.length; i++) {\n\t\t\t\tvar mode = keyModes[i];\n\t\t\t\tif (mode.isActive() && mode.isStatusActive && mode.isStatusActive()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar status;\n\t\t\tvar model = this.getModel();\n\t\t\tvar selections = this.getSelections();\n\t\t\tif (selections.length > 1) {\n\t\t\t\tstatus = util.formatMessage(messages.multiSelections, selections.length);\n\t\t\t} else {\n\t\t\t\tvar caretOffset = selections[0].getCaret();\n\t\t\t\tvar lineIndex = model.getLineAtOffset(caretOffset);\n\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\tvar offsetInLine = caretOffset - lineStart;\n\t\t\t\tstatus = util.formatMessage(messages.lineColumn, lineIndex + 1, offsetInLine + 1);\n\t\t\t}\n\t\t\tthis.reportStatus(status);\n\t\t},\n\n\t\tshowAnnotations: function(annotations, types, createAnnotation, getType) {\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tif (!annotationModel) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar remove = [], add = [];\n\t\t\tvar model = annotationModel.getTextModel();\n\t\t\tvar iter = annotationModel.getAnnotations(), annotation;\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tannotation = iter.next();\n\t\t\t\tif (types.indexOf(annotation.type) !== -1) {\n\t\t\t\t\tif (annotation.creatorID === this) {\n\t\t\t\t\t\tremove.push(annotation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (annotations) {\n\t\t\t\tfor (var i = 0; i < annotations.length; i++) {\n\t\t\t\t\tannotation = annotations[i];\n\t\t\t\t\tif (!annotation) { continue; }\n\t\t\t\t\tif (createAnnotation) {\n\t\t\t\t\t\tannotation = createAnnotation(annotation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar start, end;\n\t\t\t\t\t\tif (annotation.lineStart && annotation.lineEnd){\n\t\t\t\t\t\t\tstart = model.getLineStart(annotation.lineStart);\n\t\t\t\t\t\t\t// If the closing line number of the modified range is on the last line,\n\t\t\t\t\t\t\t// get the line ending offset of the previous line\n\t\t\t\t\t\t\tend = model.getLineCount() === annotation.lineEnd\n\t\t\t\t\t\t\t\t\t\t? model.getLineEnd(annotation.lineEnd - 1)\n\t\t\t\t\t\t\t\t\t\t: model.getLineStart(annotation.lineEnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof annotation.line === \"number\") { //$NON-NLS-0$\n\t\t\t\t\t\t\t// line/column\n\t\t\t\t\t\t\tvar lineIndex = annotation.line - 1;\n\t\t\t\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\t\t\t\tstart = lineStart + annotation.start - 1;\n\t\t\t\t\t\t\tend = lineStart + annotation.end - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// document offsets\n\t\t\t\t\t\t\tstart = annotation.start;\n\t\t\t\t\t\t\tend = annotation.end;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar type = getType(annotation);\n\t\t\t\t\t\tif (!type) { continue; }\n\t\t\t\t\t\tannotation = AT.createAnnotation(type, start, end, annotation.description);\n\t\t\t\t\t}\n\t\t\t\t\tannotation.id = annotations[i].id; //allow consumers to tag the annotation with their own identifier\n\t\t\t\t\tif(annotations[i].data) {\n\t\t\t\t\t\tannotation.data = annotations[i].data;\n\t\t\t\t\t}\n\t\t\t\t\tannotation.creatorID = this;\n\t\t\t\t\tadd.push(annotation);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotationModel.replaceAnnotations(remove, add);\n\t\t},\n\n\t\tshowProblems: function(problems) {\n\t\t\tthis.showAnnotations(problems, [\n\t\t\t\tAT.ANNOTATION_ERROR,\n\t\t\t\tAT.ANNOTATION_WARNING,\n\t\t\t\tAT.ANNOTATION_TASK\n\t\t\t], null, function(annotation) {\n\t\t\t\tswitch (annotation.severity) {\n\t\t\t\t\tcase \"error\": return AT.ANNOTATION_ERROR; //$NON-NLS-0$\n\t\t\t\t\tcase \"warning\": return AT.ANNOTATION_WARNING; //$NON-NLS-0$\n\t\t\t\t\tcase \"task\": return AT.ANNOTATION_TASK; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t},\n\n\t\tshowOccurrences: function(occurrences) {\n\t\t\tthis.showAnnotations(occurrences, [\n\t\t\t\tAT.ANNOTATION_READ_OCCURRENCE,\n\t\t\t\tAT.ANNOTATION_WRITE_OCCURRENCE\n\t\t\t], null, function(annotation) {\n\t\t\t\treturn annotation.readAccess ? AT.ANNOTATION_READ_OCCURRENCE : AT.ANNOTATION_WRITE_OCCURRENCE;\n\t\t\t});\n\t\t},\n\n\t\tshowBlame : function(blameMarkers) {\n\t\t\tvar blameRGB = this._blameRGB;\n\t\t\tvar document = this.getTextView().getOptions(\"parent\").ownerDocument; //$NON-NLS-0$\n\t\t\tif (!blameRGB) {\n\t\t\t\tvar div = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tdiv.className = \"annotation blame\"; //$NON-NLS-0$\n\t\t\t\tdocument.body.appendChild(div);\n\t\t\t\tvar window = document.defaultView || document.parentWindow;\n\t\t\t\tvar blameStyle = window.getComputedStyle(div);\n\t\t\t\tvar color = blameStyle.getPropertyValue(\"background-color\"); //$NON-NLS-0$\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t\tvar i1 = color.indexOf(\"(\"); //$NON-NLS-0$\n\t\t\t\tvar i2 = color.indexOf(\")\"); //$NON-NLS-0$\n\t\t\t\tcolor = color.substring(i1 + 1, i2);\n\t\t\t\tthis._blameRGB = blameRGB = color.split(\",\").slice(0,3); //$NON-NLS-0$\n\t\t\t}\n\t\t\tvar createGroup = function() {\n\t\t\t\tvar annotation = mAnnotations.AnnotationType.createAnnotation(this.groupType, this.start, this.end, this.title);\n\t\t\t\tannotation.style = objects.mixin({}, annotation.style);\n\t\t\t\tannotation.style.style = objects.mixin({}, annotation.style.style);\n\t\t\t\tannotation.style.style.backgroundColor = \"\";\n\t\t\t\tthis.groupAnnotation = annotation;\n\t\t\t\tannotation.blame = this.blame;\n\t\t\t\tannotation.html = this.html;\n\t\t\t\tannotation.creatorID = this.creatorID;\n\t\t\t\treturn annotation;\n\t\t\t};\n\t\t\tvar title = function() {\n\t\t\t\tvar div = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\tdiv.className = \"tooltipTitle\"; //$NON-NLS-0$\n\t\t\t\tvar index = this.blame.Message.indexOf(\"\\n\"); //$NON-NLS-0$\n\t\t\t\tif (index === -1) { index = this.blame.Message.length; }\n\t\t\t\tvar commitLink = util.createElement(document, \"a\"); //$NON-NLS-0$\n\t\t\t\tcommitLink.href = this.blame.CommitLink;\n\t\t\t\tcommitLink.appendChild(document.createTextNode(this.blame.Message.substring(0, index)));\n\t\t\t\tdiv.appendChild(commitLink);\n\t\t\t\tdiv.appendChild(util.createElement(document, \"br\")); //$NON-NLS-0$\n\t\t\t\tdiv.appendChild(document.createTextNode(util.formatMessage(messages.committerOnTime, this.blame.AuthorName, this.blame.Time)));\n\t\t\t\treturn div;\n\t\t\t};\n\t\t\tvar model = this.getModel();\n\t\t\tthis.showAnnotations(blameMarkers, [\n\t\t\t\tAT.ANNOTATION_BLAME,\n\t\t\t\tAT.ANNOTATION_CURRENT_BLAME\n\t\t\t], function (blameMarker) {\n\t\t\t\tvar start = model.getLineStart(blameMarker.Start - 1);\n\t\t\t\tvar end = model.getLineEnd(blameMarker.End - 1, true);\n\t\t\t\tvar annotation = mAnnotations.AnnotationType.createAnnotation(AT.ANNOTATION_BLAME, start, end, title);\n\t\t\t\tvar blameColor = blameRGB.slice(0);\n\t\t\t\tblameColor.push(blameMarker.Shade);\n\t\t\t\tannotation.style = objects.mixin({}, annotation.style);\n\t\t\t\tannotation.style.style = objects.mixin({}, annotation.style.style);\n\t\t\t\tannotation.style.style.backgroundColor = \"rgba(\" + blameColor.join() + \")\"; //$NON-NLS-0$ //$NON-NLS-1$\n\t\t\t\tannotation.groupId = blameMarker.Name;\n\t\t\t\tannotation.groupType = AT.ANNOTATION_CURRENT_BLAME;\n\t\t\t\tannotation.createGroupAnnotation = createGroup;\n\t\t\t\tannotation.html = '<img class=\"annotationHTML blame\" src=\"' + blameMarker.AuthorImage + '\"/>'; //$NON-NLS-0$ //$NON-NLS-1$\n\t\t\t\tannotation.blame = blameMarker;\n\t\t\t\treturn annotation;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Display git diff annotation on the editor's annotation ruler and overview ruler.\n\t\t *\n\t\t * @param diffs [] with types \"added\", \"modified\", \"deleted\"\n\t\t * \t\tEach property in diffs contains an array of objects { lineStart, lineEnd } that\n\t\t * \t\tprovides the starting and ending line index for the specified property.\n\t\t */\n\t\tshowDiffAnnotations: function(diffs) {\n\t\t\tthis.showAnnotations(diffs, [\n\t\t\t\tAT.ANNOTATION_DIFF_ADDED,\n\t\t\t\tAT.ANNOTATION_DIFF_MODIFIED,\n\t\t\t\tAT.ANNOTATION_DIFF_DELETED\n\t\t\t], null, function(annotation) {\n\t\t\t\tif(annotation.type === \"added\")//$NON-NLS-0$\n\t\t\t\t\treturn AT.ANNOTATION_DIFF_ADDED;\n\t\t\t\telse if (annotation.type === \"modified\")//$NON-NLS-0$\n\t\t\t\t\treturn AT.ANNOTATION_DIFF_MODIFIED;\n\t\t\t\treturn AT.ANNOTATION_DIFF_DELETED; // assume deleted if not added or modified\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Reveals and selects a portion of text.\n\t\t * @param {Number} start\n\t\t * @param {Number} end\n\t\t * @param {Number} line\n\t\t * @param {Number} offset\n\t\t * @param {Number} length\n\t\t */\n\t\tshowSelection: function(start, end, line, offset, length) {\n\t\t\t// We use typeof because we need to distinguish the number 0 from an undefined or null parameter\n\t\t\tif (typeof(start) === \"number\") { //$NON-NLS-0$\n\t\t\t\tif (typeof(end) !== \"number\") { //$NON-NLS-0$\n\t\t\t\t\tend = start;\n\t\t\t\t}\n\t\t\t\tthis.moveSelection(start, end);\n\t\t\t\treturn true;\n\t\t\t} else if (typeof(line) === \"number\") { //$NON-NLS-0$\n\t\t\t\tvar model = this.getModel();\n\t\t\t\tvar pos = model.getLineStart(line-1);\n\t\t\t\tif (typeof(offset) === \"number\") { //$NON-NLS-0$\n\t\t\t\t\tpos = pos + offset;\n\t\t\t\t}\n\t\t\t\tif (typeof(length) !== \"number\") { //$NON-NLS-0$\n\t\t\t\t\tlength = 0;\n\t\t\t\t}\n\t\t\t\tthis.moveSelection(pos, pos+length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_setModelText: function(contents) {\n\t\t\tif (this._textView) {\n\t\t\t\tthis._textView.setText(contents);\n\t\t\t\tthis._textView.getModel().setLineDelimiter(\"auto\"); //$NON-NLS-0$\n\t\t\t\tthis._highlightCurrentLine(this._textView.getSelections());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sets the editor's contents.\n\t\t *\n\t\t * @param {String} title\n\t\t * @param {String} message\n\t\t * @param {String} contents\n\t\t * @param {Boolean} contentsSaved\n\t\t * @param {Boolean} noFocus\n\t\t */\n\t\tsetInput: function(title, message, contents, contentsSaved, noFocus) {\n\t\t\tBaseEditor.prototype.setInput.call(this, title, message, contents, contentsSaved);\n\t\t\tif (this._textView && !contentsSaved && !noFocus) {\n\t\t\t\tthis._textView.focus();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Reveals a line in the editor, and optionally selects a portion of the line.\n\t\t * @param {Number} line - document base line index\n\t\t * @param {Number|String} column\n\t\t * @param {Number} [end]\n\t\t */\n\t\tonGotoLine: function(line, column, end, callback) {\n\t\t\tif (this._textView) {\n\t\t\t\tvar model = this.getModel();\n\t\t\t\tline = Math.max(0, Math.min(line, model.getLineCount() - 1));\n\t\t\t\tvar lineStart = model.getLineStart(line);\n\t\t\t\tvar start = 0;\n\t\t\t\tif (end === undefined) {\n\t\t\t\t\tend = 0;\n\t\t\t\t}\n\t\t\t\tif (typeof column === \"string\") { //$NON-NLS-0$\n\t\t\t\t\tvar index = model.getLine(line).indexOf(column);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tstart = index;\n\t\t\t\t\t\tend = start + column.length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstart = column;\n\t\t\t\t\tvar lineLength = model.getLineEnd(line) - lineStart;\n\t\t\t\t\tstart = Math.min(start, lineLength);\n\t\t\t\t\tend = Math.min(end, lineLength);\n\t\t\t\t}\n\t\t\t\tthis.moveSelection(lineStart + start, lineStart + end, callback);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\tBaseEditor: BaseEditor,\n\t\tEditor: Editor\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/find\", [ //$NON-NLS-0$\n\t'i18n!orion/editor/nls/messages', //$NON-NLS-0$\n\t'orion/keyBinding', //$NON-NLS-0$\n\t'orion/editor/keyModes', //$NON-NLS-0$\n\t'orion/editor/annotations', //$NON-NLS-0$\n\t'orion/regex', //$NON-NLS-0$\n\t'orion/objects', //$NON-NLS-0$\n\t'orion/util' //$NON-NLS-0$\n], function(messages, mKeyBinding, mKeyModes, mAnnotations, mRegex, objects, util) {\n\n\tvar exports = {};\n\t\n\tfunction IncrementalFind(editor) {\n\t\tvar textView = editor.getTextView();\n\t\tmKeyModes.KeyMode.call(this, textView);\n\t\tthis.editor = editor;\n\t\tthis._active = false;\n\t\tthis._success = true;\n\t\tthis._ignoreSelection = false;\n\t\tthis._prefix = \"\";\n\t\t\n\t\ttextView.setAction(\"incrementalFindCancel\", function() { //$NON-NLS-0$\n\t\t\tthis.setActive(false);\n\t\t\treturn true;\n\t\t}.bind(this));\n\t\ttextView.setAction(\"incrementalFindBackspace\", function() { //$NON-NLS-0$\n\t\t\treturn this._backspace();\n\t\t}.bind(this));\n\t\t\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonVerify: function(e){\n\t\t\t\tvar editor = self.editor;\n\t\t\t\tvar model = editor.getModel();\n\t\t\t\tvar start = editor.mapOffset(e.start), end = editor.mapOffset(e.end);\n\t\t\t\tvar txt = model.getText(start, end);\n\t\t\t\tvar prefix = self._prefix;\n\t\t\t\t// TODO: mRegex is pulled in just for this one call so we can get case-insensitive search\n\t\t\t\t// is it really necessary\n\t\t\t\tvar match = prefix.match(new RegExp(\"^\" + mRegex.escape(txt), \"i\")); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tif (match && match.length > 0) {\n\t\t\t\t\tprefix = self._prefix += e.text;\n\t\t\t\t\tself._success = true;\n\t\t\t\t\tself._status();\n\t\t\t\t\tself.find(self._forward, true);\n\t\t\t\t\te.text = null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSelection: function() {\n\t\t\t\tif (!self._ignoreSelection) {\n\t\t\t\t\tself.setActive(false);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tIncrementalFind.prototype = new mKeyModes.KeyMode();\n\tobjects.mixin(IncrementalFind.prototype, {\n\t\tcreateKeyBindings: function() {\n\t\t\tvar KeyBinding = mKeyBinding.KeyBinding;\n\t\t\tvar bindings = [];\n\t\t\tbindings.push({actionID: \"incrementalFindBackspace\", keyBinding: new KeyBinding(8)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"incrementalFindCancel\", keyBinding: new KeyBinding(13)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"incrementalFindCancel\", keyBinding: new KeyBinding(27)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"incrementalFindReverse\", keyBinding: new KeyBinding(38)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"incrementalFind\", keyBinding: new KeyBinding(40)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"incrementalFindReverse\", keyBinding: new KeyBinding('k', true, true)}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"incrementalFind\", keyBinding: new KeyBinding('k', true)}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\treturn bindings;\n\t\t},\n\t\tfind: function(forward, incremental) {\n\t\t\tthis._forward = forward;\n\t\t\tif (!this.isActive()) {\n\t\t\t\tthis.setActive(true);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar prefix = this._prefix;\n\t\t\tif (prefix.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar editor = this.editor;\n\t\t\tvar model = editor.getModel();\n\t\t\tvar start;\n\t\t\tif (forward) {\n\t\t\t\tif (this._success) {\n\t\t\t\t\tstart = incremental ? this._start : editor.getCaretOffset() + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._success) {\n\t\t\t\t\tstart = incremental ? this._start : editor.getCaretOffset();\n\t\t\t\t} else {\n\t\t\t\t\tstart = model.getCharCount() - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar result = editor.getModel().find({\n\t\t\t\tstring: prefix,\n\t\t\t\tstart: start,\n\t\t\t\treverse: !forward,\n\t\t\t\tcaseInsensitive: prefix.toLowerCase() === prefix}).next();\n\t\t\tif (result) {\n\t\t\t\tif (!incremental) {\n\t\t\t\t\tthis._start = start;\n\t\t\t\t}\n\t\t\t\tthis._success = true;\n\t\t\t\tthis._ignoreSelection = true;\n\t\t\t\teditor.moveSelection(forward ? result.start : result.end, forward ? result.end : result.start);\n\t\t\t\tthis._ignoreSelection = false;\n\t\t\t} else {\n\t\t\t\tthis._success = false;\n\t\t\t}\n\t\t\tthis._status();\n\t\t\treturn true;\n\t\t},\n\t\tisActive: function() {\n\t\t\treturn this._active;\n\t\t},\n\t\tisStatusActive: function() {\n\t\t\treturn this.isActive();\n\t\t},\n\t\tsetActive: function(active) {\n\t\t\tif (this._active === active) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._active = active;\n\t\t\tthis._prefix = \"\";\n\t\t\tthis._success = true;\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tthis._start = this.editor.getCaretOffset();\n\t\t\tthis.editor.setCaretOffset(this._start);\n\t\t\tif (this._active) {\n\t\t\t\ttextView.addEventListener(\"Verify\", this._listener.onVerify); //$NON-NLS-0$\n\t\t\t\ttextView.addEventListener(\"Selection\", this._listener.onSelection); //$NON-NLS-0$\n\t\t\t\ttextView.addKeyMode(this);\n\t\t\t} else {\n\t\t\t\ttextView.removeEventListener(\"Verify\", this._listener.onVerify); //$NON-NLS-0$\n\t\t\t\ttextView.removeEventListener(\"Selection\", this._listener.onSelection); //$NON-NLS-0$\n\t\t\t\ttextView.removeKeyMode(this);\n\t\t\t}\n\t\t\tthis._status();\n\t\t},\n\t\t_backspace: function() {\n\t\t\tvar prefix = this._prefix;\n\t\t\tprefix = this._prefix = prefix.substring(0, prefix.length-1);\n\t\t\tif (prefix.length === 0) {\n\t\t\t\tthis._success = true;\n\t\t\t\tthis._ignoreSelection = true;\n\t\t\t\tthis.editor.setCaretOffset(this.editor.getSelection().start);\n\t\t\t\tthis._ignoreSelection = false;\n\t\t\t\tthis._status();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this.find(this._forward, true);\n\t\t},\n\t\t_status: function() {\n\t\t\tif (!this.isActive()) {\n\t\t\t\tthis.editor.reportStatus(\"\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar msg;\n\t\t\tif (this._forward) {\n\t\t\t\tmsg = this._success ? messages.incrementalFindStr : messages.incrementalFindStrNotFound;\n\t\t\t} else {\n\t\t\t\tmsg = this._success ? messages.incrementalFindReverseStr : messages.incrementalFindReverseStrNotFound;\n\t\t\t}\n\t\t\tmsg = util.formatMessage(msg, this._prefix);\n\t\t\tthis.editor.reportStatus(msg, this._success ? \"\" : \"error\"); //$NON-NLS-0$\n\t\t}\n\t});\n\texports.IncrementalFind = IncrementalFind;\n\t\n\t\n\tfunction Find(editor, undoStack, options) {\n\t\tif (!editor) { return; }\t\n\t\tthis._editor = editor;\n\t\tthis._undoStack = undoStack;\n\t\tthis._showAll = true;\n\t\tthis._visible = false;\n\t\tthis._caseInsensitive = true;\n\t\tthis._wrap = true;\n\t\tthis._wholeWord = false;\n\t\tthis._incremental = true;\n\t\tthis._regex = false;\n\t\tthis._findAfterReplace = true;\n\t\tthis._hideAfterFind = false;\n\t\tthis._reverse = false;\n\t\tthis._start = undefined;\n\t\tthis._end = undefined;\n\t\tthis._timer = undefined;\n\t\tthis._lastString = \"\";\n\t\tvar that = this;\n\t\tthis._listeners = {\n\t\t\tonEditorFocus: function(e) {\n\t\t\t\tthat._removeCurrentAnnotation(e);\n\t\t\t}\n\t\t};\n\t\tthis.setOptions(options);\n\t}\n\tFind.prototype = {\n\t\tfind: function (forward, tempOptions, incremental) {\n\t\t\tthis.setOptions({\n\t\t\t\treverse : !forward\n\t\t\t});\n\t\t\tvar string = this.getFindString();\n\t\t\tvar count;\n\t\t\tif (tempOptions) {\n\t\t\t\tstring = tempOptions.findString || string;\n\t\t\t\tcount =  tempOptions.count;\n\t\t\t}\n\t\t\tvar savedOptions = this.getOptions();\n\t\t\tthis.setOptions(tempOptions);\n\t\t\tvar startOffset = incremental ? this._startOffset : this.getStartOffset();\n\t\t\tvar result = this._doFind(string, startOffset, count);\n\t\t\tif (result) {\n\t\t\t\tif (!incremental) {\n\t\t\t\t\tthis._startOffset = result.start;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.setOptions(savedOptions);\n\t\t\tif (this._hideAfterFind) {\n\t\t\t\tthis.hide();\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetStartOffset: function() {\n\t\t\tif (this._start !== undefined) {\n\t\t\t\treturn this._start;\n\t\t\t}\n\t\t\tif (this._reverse) {\n\t\t\t\treturn this._editor.getSelection().start - 1;\n\t\t\t}\n\t\t\treturn this._editor.getCaretOffset();\n\t\t},\n\t\tgetFindString: function() {\n\t\t\tvar selection = this._editor.getSelection();\n\t\t\tvar searchString = this._editor.getText(selection.start, selection.end);\n\t\t\tif (this._regex) {\n\t\t\t\tsearchString = mRegex.escape(searchString);\n\t\t\t}\n\t\t\treturn searchString || this._lastString;\n\t\t},\n\t\tgetOptions: function() {\n\t\t\treturn {\n\t\t\t\tshowAll: this._showAll, \n\t\t\t\tcaseInsensitive: this._caseInsensitive, \n\t\t\t\twrap: this._wrap, \n\t\t\t\twholeWord: this._wholeWord, \n\t\t\t\tincremental: this._incremental,\n\t\t\t\tregex: this._regex,\n\t\t\t\tfindAfterReplace: this._findAfterReplace,\n\t\t\t\thideAfterFind: this._hideAfterFind,\n\t\t\t\treverse: this._reverse,\n\t\t\t\tfindCallback: this._findCallback,\n\t\t\t\tstart: this._start,\n\t\t\t\tend: this._end\n\t\t\t};\n\t\t},\n\t\tgetReplaceString: function() {\n\t\t\treturn \"\";\n\t\t},\n\t\thide: function() {\n\t\t\tthis._visible = false;\n\t\t\tif (this._savedOptions) {\n\t\t\t\tthis.setOptions(this._savedOptions.pop());\n\t\t\t\tif (this._savedOptions.length === 0) {\n\t\t\t\t\tthis._savedOptions = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._removeAllAnnotations();\n\t\t\tvar textView = this._editor.getTextView();\n\t\t\tif (textView) {\n\t\t\t\ttextView.removeEventListener(\"Focus\", this._listeners.onEditorFocus); //$NON-NLS-0$\n\t\t\t\ttextView.focus();\n\t\t\t}\n\t\t},\n\t\t_processReplaceString: function(str) {\n\t\t\tvar newStr = str;\n\t\t\tif (this._regex) {\n\t\t\t\tnewStr = \"\";\n\t\t\t\tvar escape = false;\n\t\t\t\tvar delimiter = this._editor.getModel().getLineDelimiter();\n\t\t\t\tfor (var i=0; i<str.length; i++) {\n\t\t\t\t\tvar c = str.substring(i, i + 1);\n\t\t\t\t\tif (escape) {\n\t\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\t\tcase \"R\": newStr += delimiter; break;\n\t\t\t\t\t\t\tcase \"r\": newStr += \"\\r\"; break;\n\t\t\t\t\t\t\tcase \"n\": newStr += \"\\n\"; break;\n\t\t\t\t\t\t\tcase \"t\": newStr += \"\\t\"; break;\n\t\t\t\t\t\t\tcase \"\\\\\": newStr += \"\\\\\"; break;\n\t\t\t\t\t\t\tdefault: newStr += \"\\\\\" + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tescape = false;\n\t\t\t\t\t} else if (c === \"\\\\\") {\n\t\t\t\t\t\tescape = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewStr += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (escape) {\n\t\t\t\t\tnewStr += \"\\\\\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newStr;\n\t\t},\n\t\tisVisible: function() {\n\t\t\treturn this._visible;\n\t\t},\n\t\treplace: function() {\n\t\t\tvar string = this.getFindString();\n\t\t\tif (string) {\n\t\t\t\tvar editor = this._editor;\n\t\t\t\tvar replaceString = this._processReplaceString(this.getReplaceString());\n\t\t\t\tvar selection = editor.getSelection();\n\t\t\t\tvar start = selection.start;\n\t\t\t\tvar result = editor.getModel().find({\n\t\t\t\t\tstring: string,\n\t\t\t\t\tstart: start,\n\t\t\t\t\treverse: false,\n\t\t\t\t\twrap: this._wrap,\n\t\t\t\t\tregex: this._regex,\n\t\t\t\t\twholeWord: this._wholeWord,\n\t\t\t\t\tcaseInsensitive: this._caseInsensitive\n\t\t\t\t}).next();\n\t\t\t\tif (result) {\n\t\t\t\t\tthis.startUndo();\n\t\t\t\t\tthis._doReplace(result.start, result.end, string, replaceString);\n\t\t\t\t\tthis.endUndo();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._findAfterReplace && string){\n\t\t\t\tthis._doFind(string, this.getStartOffset());\n\t\t\t}\n\t\t},\n\t\treplaceAll : function() {\n\t\t\tvar string = this.getFindString();\n\t\t\tif (string) {\n\t\t\t\tthis._replacingAll = true;\n\t\t\t\tvar editor = this._editor;\n\t\t\t\tvar textView = editor.getTextView();\n\t\t\t\teditor.reportStatus(messages.replacingAll);\n\t\t\t\tvar replaceString = this._processReplaceString(this.getReplaceString());\n\t\t\t\tvar self = this;\n\t\t\t\twindow.setTimeout(function() {\n\t\t\t\t\tvar startPos = 0;\n\t\t\t\t\tvar count = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t//For replace all, we need to ignore the wrap search from the user option\n\t\t\t\t\t\t//Otherwise the loop will be dead, see https://bugs.eclipse.org/bugs/show_bug.cgi?id=411813\n\t\t\t\t\t\tvar result = self._doFind(string, startPos, null, true);\n\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (count === 1) {\n\t\t\t\t\t\t\ttextView.setRedraw(false);\n\t\t\t\t\t\t\tself.startUndo();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself._doReplace(result.start, result.end, string, replaceString);\n\t\t\t\t\t\tstartPos = self.getStartOffset();\n\t\t\t\t\t}\n\t\t\t\t\tif (count > 0) {\n\t\t\t\t\t\tself.endUndo();\n\t\t\t\t\t\ttextView.setRedraw(true);\n\t\t\t\t\t}\n\t\t\t\t\tif (startPos > 0) {\n\t\t\t\t\t\teditor.reportStatus(util.formatMessage(messages.replacedMatches, count));\n\t\t\t\t\t} else {\n\t\t\t\t\t\teditor.reportStatus(messages.nothingReplaced, \"error\"); //$NON-NLS-0$ \n\t\t\t\t\t}\n\t\t\t\t\tself._replacingAll = false;\n\t\t\t\t}, 100);\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @property {String} string the search string to be found.\n\t\t * @property {Boolean} [regex=false] whether or not the search string is a regular expression.\n\t\t * @property {Boolean} [wrap=false] whether or not to wrap search.\n\t\t * @property {Boolean} [wholeWord=false] whether or not to search only whole words.\n\t\t * @property {Boolean} [caseInsensitive=false] whether or not search is case insensitive.\n\t\t * @property {Boolean} [reverse=false] whether or not to search backwards.\n\t\t * @property {Number} [start=0] The start offset to start searching\n\t\t * @property {Number} [end=charCount] The end offset of the search. Used to search in a given range.\t\n\t\t */\n\t\tsetOptions : function(options) {\n\t\t\tif (options) {\n\t\t\t\tif ((options.showAll === true || options.showAll === false) && this._showAll !== options.showAll) {\n\t\t\t\t\tthis._showAll = options.showAll;\n\t\t\t\t\tif (this.isVisible()) {\n\t\t\t\t\t\tif (this._showAll) {\n\t\t\t\t\t\t\tthis._markAllOccurrences();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar annotationModel = this._editor.getAnnotationModel();\n\t\t\t\t\t\t\tif (annotationModel) {\n\t\t\t\t\t\t\t\tannotationModel.removeAnnotations(mAnnotations.AnnotationType.ANNOTATION_MATCHING_SEARCH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (options.caseInsensitive === true || options.caseInsensitive === false) {\n\t\t\t\t\tthis._caseInsensitive = options.caseInsensitive;\n\t\t\t\t}\n\t\t\t\tif (options.wrap === true || options.wrap === false) {\n\t\t\t\t\tthis._wrap = options.wrap;\n\t\t\t\t}\n\t\t\t\tif (options.wholeWord === true || options.wholeWord === false) {\n\t\t\t\t\tthis._wholeWord = options.wholeWord;\n\t\t\t\t}\n\t\t\t\tif (options.incremental === true || options.incremental === false) {\n\t\t\t\t\tthis._incremental = options.incremental;\n\t\t\t\t}\n\t\t\t\tif (options.regex === true || options.regex === false) {\n\t\t\t\t\tthis._regex = options.regex;\n\t\t\t\t}\n\t\t\t\tif (options.findAfterReplace === true || options.findAfterReplace === false) {\n\t\t\t\t\tthis._findAfterReplace = options.findAfterReplace;\n\t\t\t\t}\n\t\t\t\tif (options.hideAfterFind === true || options.hideAfterFind === false) {\n\t\t\t\t\tthis._hideAfterFind = options.hideAfterFind;\n\t\t\t\t}\n\t\t\t\tif (options.reverse === true || options.reverse === false) {\n\t\t\t\t\tthis._reverse = options.reverse;\n\t\t\t\t}\n\t\t\t\tif (options.hasOwnProperty(\"findCallback\")) { //$NON-NLS-0$\n\t\t\t\t\tthis._findCallback = options.findCallback;\n\t\t\t\t}\n\t\t\t\tif (options.hasOwnProperty(\"start\")) { //$NON-NLS-0$\t\n\t\t\t\t\tthis._start = options.start;\n\t\t\t\t}\n\t\t\t\tif (options.hasOwnProperty(\"end\")) { //$NON-NLS-0$\n\t\t\t\t\tthis._end = options.end;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tshow: function(tempOptions) {\n\t\t\tthis._visible = true;\n\t\t\tif (tempOptions) {\n\t\t\t\tif (!this._savedOptions) {\n\t\t\t\t\tthis._savedOptions = [];\n\t\t\t\t}\t\n\t\t\t\tthis._savedOptions.push(this.getOptions());\n\t\t\t\tthis.setOptions(tempOptions);\n\t\t\t}\n\t\t\tthis._startOffset = this._editor.getSelection().start;\n\t\t\tthis._editor.getTextView().addEventListener(\"Focus\", this._listeners.onEditorFocus); //$NON-NLS-0$\n\t\t\tvar self = this;\n\t\t\twindow.setTimeout(function() {\n\t\t\t\tif (self._incremental) {\n\t\t\t\t\tself.find(true, null, true);\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t},\n\t\tstartUndo: function() {\n\t\t\tif (this._undoStack) {\n\t\t\t\tthis._undoStack.startCompoundChange();\n\t\t\t}\n\t\t}, \n\t\tendUndo: function() {\n\t\t\tif (this._undoStack) {\n\t\t\t\tthis._undoStack.endCompoundChange();\n\t\t\t}\n\t\t},\n\t\t_find: function(string, startOffset, noWrap) {\n\t\t\treturn this._editor.getModel().find({\n\t\t\t\tstring: string,\n\t\t\t\tstart: startOffset,\n\t\t\t\tend: this._end,\n\t\t\t\treverse: this._reverse,\n\t\t\t\twrap: (noWrap ? false: this._wrap),\n\t\t\t\tregex: this._regex,\n\t\t\t\twholeWord: this._wholeWord,\n\t\t\t\tcaseInsensitive: this._caseInsensitive\n\t\t\t});\n\t\t},\n\t\t_doFind: function(string, startOffset, count, noWrap) {\n\t\t\tcount = count || 1;\n\t\t\tvar editor = this._editor;\n\t\t\tif (!string) {\n\t\t\t\tthis._removeAllAnnotations();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._lastString = string;\n\t\t\tvar result, iterator;\n\t\t\tif (this._regex) {\n\t\t\t\ttry {\n\t\t\t\t\titerator = this._find(string, startOffset, noWrap);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\teditor.reportStatus(ex.message, \"error\"); //$NON-NLS-0$\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\titerator = this._find(string, startOffset, noWrap);\n\t\t\t}\n\t\t\tfor (var i=0; i<count && iterator.hasNext(); i++) {\n\t\t\t\tresult = iterator.next();\n\t\t\t}\n\t\t\tif (!this._replacingAll) {\n\t\t\t\tif (result) {\n\t\t\t\t\tthis._editor.reportStatus(\"\");\n\t\t\t\t} else {\n\t\t\t\t\tthis._editor.reportStatus(messages.notFound, \"error\"); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tif (this.isVisible()) {\n\t\t\t\t\tvar type = mAnnotations.AnnotationType.ANNOTATION_CURRENT_SEARCH;\n\t\t\t\t\tvar annotationModel = editor.getAnnotationModel();\n\t\t\t\t\tif (annotationModel) {\n\t\t\t\t\t\tannotationModel.removeAnnotations(type);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tannotationModel.addAnnotation(mAnnotations.AnnotationType.createAnnotation(type, result.start, result.end));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._showAll) {\n\t\t\t\t\t\tif (this._timer) {\n\t\t\t\t\t\t\twindow.clearTimeout(this._timer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar that = this;\n\t\t\t\t\t\tthis._timer = window.setTimeout(function(){\n\t\t\t\t\t\t\tthat._markAllOccurrences();\n\t\t\t\t\t\t\tthat._timer = null;\n\t\t\t\t\t\t}, 500);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this._findCallback) {\n\t\t\t\t\tthis._findCallback(result);\n\t\t\t\t}\n\t\t\t\telse if (result) {\n\t\t\t\t\teditor.moveSelection(result.start, result.end, null, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t_doReplace: function(start, end, searchStr, newStr) {\n\t\t\tvar editor = this._editor;\n\t\t\tif (this._regex) {\n\t\t\t\tnewStr = editor.getText(start, end).replace(new RegExp(searchStr, this._caseInsensitive ? \"i\" : \"\"), newStr); //$NON-NLS-0$\n\t\t\t}\n\t\t\teditor.setText(newStr, start, end);\n\t\t\teditor.setSelection(start, start + newStr.length, true);\n\t\t},\n\t\t_markAllOccurrences: function() {\n\t\t\tvar annotationModel = this._editor.getAnnotationModel();\n\t\t\tif (!annotationModel) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar type = mAnnotations.AnnotationType.ANNOTATION_MATCHING_SEARCH;\n\t\t\tvar iter = annotationModel.getAnnotations();\n\t\t\tvar remove = [], add;\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tvar annotation = iter.next();\n\t\t\t\tif (annotation.type === type) {\n\t\t\t\t\tremove.push(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.isVisible()) {\n\t\t\t\tvar string = this.getFindString();\n\t\t\t\titer = this._editor.getModel().find({\n\t\t\t\t\tstring: string,\n\t\t\t\t\tregex: this._regex,\n\t\t\t\t\twholeWord: this._wholeWord,\n\t\t\t\t\tcaseInsensitive: this._caseInsensitive\n\t\t\t\t});\n\t\t\t\tadd = [];\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tvar range = iter.next();\n\t\t\t\t\tadd.push(mAnnotations.AnnotationType.createAnnotation(type, range.start, range.end));\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotationModel.replaceAnnotations(remove, add);\n\t\t},\n\t\t_removeAllAnnotations: function() {\n\t\t\tvar annotationModel = this._editor.getAnnotationModel();\n\t\t\tif (annotationModel) {\n\t\t\t\tannotationModel.removeAnnotations(mAnnotations.AnnotationType.ANNOTATION_CURRENT_SEARCH);\n\t\t\t\tannotationModel.removeAnnotations(mAnnotations.AnnotationType.ANNOTATION_MATCHING_SEARCH);\n\t\t\t}\n\t\t},\n\t\t_removeCurrentAnnotation: function(evt){\n\t\t\tvar annotationModel = this._editor.getAnnotationModel();\n\t\t\tif (annotationModel) {\n\t\t\t\tannotationModel.removeAnnotations(mAnnotations.AnnotationType.ANNOTATION_CURRENT_SEARCH);\n\t\t\t}\n\t\t}\n\t};\n\texports.Find = Find;\n\t\n\treturn exports;\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2014 IBM Corporation and others. All rights reserved.\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v1.0\n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution\n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html).\n * \n * Contributors: \n *\tIBM Corporation - initial API and implementation\n ******************************************************************************/\n/*eslint-env browser, amd*/\ndefine('orion/editor/findUI',[\n\t'i18n!orion/editor/nls/messages',\n\t'orion/editor/find',\n\t'orion/objects',\n\t'orion/editor/util',\n\t'orion/util', \n], function(messages, mFind, objects, textUtil, util) {\n\t\n\tfunction FindUI(editor, undoStack, options) {\n\t\tmFind.Find.call(this, editor, undoStack, options);\n\t}\n\t\n\tFindUI.prototype = new mFind.Find();\n\t\n\tobjects.mixin(FindUI.prototype, {\n\t\tgetFindString: function() {\n\t\t\tvar input = this._findInput;\n\t\t\tif (!input) {\n\t\t\t\treturn mFind.Find.prototype.getFindString.call(this);\n\t\t\t}\n\t\t\treturn input.value;\n\t\t},\n\t\tgetReplaceString: function() {\n\t\t\tvar input = this._replaceInput;\n\t\t\tif (!input) {\n\t\t\t\treturn mFind.Find.prototype.getReplaceString(this);\n\t\t\t}\n\t\t\treturn input.value;\n\t\t},\n\t\thide: function() {\n\t\t\tvar visible = this.isVisible();\n\t\t\tmFind.Find.prototype.hide.call(this);\n\t\t\tif (visible) {\n\t\t\t\tthis._rootDiv.className = \"textViewFind\"; //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\tshow: function(options) {\n\t\t\tmFind.Find.prototype.show.call(this, options);\n\t\t\tvar findString = options.findString;\n\t\t\tvar replaceString = options.replaceString;\n\t\t\tvar input = this._findInput;\n\t\t\tif (!input) {\n\t\t\t\tthis._create();\n\t\t\t\tinput = this._findInput;\n\t\t\t}\n\t\t\tif (findString) {\n\t\t\t\tinput.value = findString;\n\t\t\t}\n\t\t\tif (replaceString) {\n\t\t\t\tvar replaceInput = this._replaceInput;\n\t\t\t\treplaceInput.value = replaceString;\n\t\t\t}\n\t\t\tvar that = this;\n\t\t\twindow.setTimeout(function() {\n\t\t\t\tthat._rootDiv.className = \"textViewFind show\"; //$NON-NLS-0$\n\t\t\t\tinput.select();\n\t\t\t\tinput.focus();\n\t\t\t}, 0);\n\t\t},\n\t\t_create: function() {\n\t\t\tvar that = this;\n\t\t\tvar view = this._editor.getTextView();\n\t\t\tvar parent = view.getOptions(\"parent\"); //$NON-NLS-0$\n\t\t\tvar document = parent.ownerDocument; //$NON-NLS-0$\n\t\t\tvar root = util.createElement(document, 'div'); //$NON-NLS-0$\n\t\t\troot.className = \"textViewFind\"; //$NON-NLS-0$\n\t\t\ttextUtil.addEventListener(root, \"keydown\", function(e) { that._handleKeyDown(e); }); //$NON-NLS-0$\n\t\t\tthis._rootDiv = root;\n\t\t\tthis._createContents(document, root);\n\t\t\tview._rootDiv.insertBefore(root, view._rootDiv.firstChild);\n\t\t},\n\t\t_createContents: function(document, parent) {\n\t\t\tvar that = this;\n\t\t\tvar fintInput = util.createElement(document, 'input'); //$NON-NLS-0$\n\t\t\tfintInput.className = \"textViewFindInput\"; //$NON-NLS-0$\n\t\t\tthis._findInput = fintInput;\n\t\t\tfintInput.type = \"text\"; //$NON-NLS-0$\n\t\t\tfintInput.placeholder = messages.findWith;\n\t\t\ttextUtil.addEventListener(fintInput, \"input\", function(evt) { //$NON-NLS-0$\n\t\t\t\treturn that._handleInput(evt);\n\t\t\t});\n\t\t\tparent.appendChild(fintInput);\n\n\t\t\tvar group = util.createElement(document, 'span'); //$NON-NLS-0$\n\t\t\tthat._createButton(document, group, messages.next, function() { that.find(true); });\n\t\t\tthat._createButton(document, group, messages.previous, function() { that.find(false); });\n\t\t\tparent.appendChild(group);\n\t\t\t\n\t\t\tvar readonly = that._editor.getTextView().getOptions(\"readonly\"); //$NON-NLS-0$\n\t\t\tif (!readonly) {\n\t\t\t\t// create replace text\n\t\t\t\tvar replaceInput = util.createElement(document, 'input'); //$NON-NLS-0$\n\t\t\t\treplaceInput.className = \"textViewReplaceInput\"; //$NON-NLS-0$\n\t\t\t\tthis._replaceInput = replaceInput;\n\t\t\t\treplaceInput.type = \"text\"; //$NON-NLS-0$\n\t\t\t\treplaceInput.placeholder = messages.replaceWith;\n\t\t\t\tparent.appendChild(replaceInput);\n\t\t\t\tgroup = util.createElement(document, 'span'); //$NON-NLS-0$\n\t\t\t\tthat._createButton(document, group, messages.replace, function() { that.replace(); });\n\t\t\t\tthat._createButton(document, group, messages.replaceAll, function() { that.replaceAll(); });\n\t\t\t\tparent.appendChild(group);\n\t\t\t}\n\n\t\t\tgroup = util.createElement(document, 'span'); //$NON-NLS-0$\n\t\t\tthat._createButton(document, group, messages.regex, function(evt) { that._toggle(\"regex\", evt.target); }, this._regex, messages.regexTooltip); //$NON-NLS-0$\n\t\t\tthat._createButton(document, group, messages.caseInsensitive, function(evt) { that._toggle(\"caseInsensitive\", evt.target); }, this._caseInsensitive, messages.caseInsensitiveTooltip); //$NON-NLS-0$\n\t\t\tthat._createButton(document, group, messages.wholeWord, function(evt) { that._toggle(\"wholeWord\", evt.target); }, this._wholeWord, messages.wholeWordTooltip); //$NON-NLS-0$\n\t\t\tparent.appendChild(group);\n\n\t\t\tvar close = that._createButton(document, parent, \"\", function() { that.hide(); }); //$NON-NLS-0$\n\t\t\tclose.className = \"textViewFindCloseButton\"; //$NON-NLS-0$\n\t\t\tclose.title = messages.closeTooltip;\n\t\t},\n\t\t_createButton: function(document, parent, text, callback, checked, tooltip) {\n\t\t\tvar button  = document.createElement(\"button\"); //$NON-NLS-0$\n\t\t\tthis._checked(checked, button);\n\t\t\tif (tooltip) button.title = tooltip;\n\t\t\ttextUtil.addEventListener(button, \"click\", function(evt) { callback.call(this, evt); }, false); //$NON-NLS-0$\n\t\t\tif (text) {\n\t\t\t\tbutton.appendChild(document.createTextNode(text)); //$NON-NLS-0$\n\t\t\t}\n\t\t\tparent.appendChild(button);\n\t\t\treturn button;\n\t\t},\n\t\t_toggle: function(prop, button) {\n\t\t\tvar options = {};\n\t\t\toptions[prop] = !this[\"_\" + prop]; //$NON-NLS-0$\n\t\t\tthis.setOptions(options);\n\t\t\tthis._checked(options[prop], button);\n\t\t},\n\t\t_checked: function(checked, button) {\n\t\t\tbutton.className = \"textViewFindButton\"; //$NON-NLS-0$\n\t\t\tif (checked) {\n\t\t\t\tbutton.className += \" checked\"; //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_handleInput: function() {\n\t\t\tif (this._incremental) {\n\t\t\t\tthis.find(true, null, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t_handleKeyDown: function(evt) {\n\t\t\tvar handled;\n\t\t\tvar ctrlKeyOnly = (util.isMac ? evt.metaKey : evt.ctrlKey) && !evt.altKey && !evt.shiftKey;\n\t\t\tif (ctrlKeyOnly && evt.keyCode === 70/*\"f\"*/ ) {\n\t\t\t\thandled = true;\n\t\t\t}\n\t\t\t//We can't use ctrlKeyOnly on \"k\" because ctrl+shift+k means find previous match when the find bar gets focus\n\t\t\tif (((util.isMac ? evt.metaKey : evt.ctrlKey) && !evt.altKey && evt.keyCode === 75/*\"k\"*/) || evt.keyCode === 13/*enter*/){\n\t\t\t\tif (evt.keyCode === 13) {\n\t\t\t\t\tthis.find(this._reverse ? evt.shiftKey : !evt.shiftKey);\n\t\t\t\t} else {\n\t\t\t\t\tthis.find(!evt.shiftKey);\n\t\t\t\t}\n\t\t\t\thandled = true;\n\t\t\t}\n\t\t\tif (ctrlKeyOnly &&  evt.keyCode === 82 /*\"r\"*/){\n\t\t\t\tthis.replace();\n\t\t\t\thandled = true;\n\t\t\t}\n\t\t\tif (evt.keyCode === 27/*ESC*/){\n\t\t\t\tthis.hide();\n\t\t\t\thandled = true;\n\t\t\t}\n\t\t\tif (handled) {\n\t\t\t\tif (evt.stopPropagation) { \n\t\t\t\t\tevt.stopPropagation(); \n\t\t\t\t}\n\t\t\t\tif (evt.preventDefault) { \n\t\t\t\t\tevt.preventDefault(); \n\t\t\t\t}\n\t\t\t\tevt.cancelBubble = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t});\n\n\treturn {FindUI: FindUI};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License v1.0\n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution\n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html).\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/actions\", [ //$NON-NLS-0$\n\t'i18n!orion/editor/nls/messages', //$NON-NLS-0$\n\t'orion/keyBinding', //$NON-NLS-0$\n\t'orion/editor/annotations', //$NON-NLS-0$\n\t'orion/editor/tooltip', //$NON-NLS-0$\n\t'orion/editor/find', //$NON-NLS-0$\n\t'orion/editor/findUI', //$NON-NLS-0$\n\t'orion/util' //$NON-NLS-0$\n], function(messages, mKeyBinding, mAnnotations, mTooltip, mFind, mFindUI, util) {\n\n\tvar AT = mAnnotations.AnnotationType;\n\n\tvar exports = {};\n\t\n\tfunction forEachSelection(actions, compound, callback, noUndo) {\n\t\tvar offset = 0;\n\t\tvar editor = actions.editor;\n\t\tvar selections = editor.getSelections();\n\t\tif (!noUndo && (compound || selections.length > 1)) actions.startUndo();\n\t\tfunction setText(text, start, end) {\n\t\t\teditor.setText(text, start, end);\n\t\t\toffset += (start - end) + text.length;\n\t\t}\n\t\tselections.forEach(function(selection) {\n\t\t\tselection.start += offset;\n\t\t\tselection.end += offset;\n\t\t\tcallback(selection, setText);\n\t\t});\n\t\teditor.setSelections(selections);\n\t\tif (!noUndo && (compound || selections.length > 1)) actions.endUndo();\n\t}\n\n\t/**\n\t * TextActions connects common text editing keybindings onto an editor.\n\t */\n\tfunction TextActions(editor, undoStack, find) {\n\t\tthis.editor = editor;\n\t\tthis.undoStack = undoStack;\n\t\tthis._incrementalFind = new mFind.IncrementalFind(editor);\n\t\tthis._find = find ? find : new mFindUI.FindUI(editor, undoStack);\n\t\tthis._lastEditLocation = null;\n\t\tthis.init();\n\t}\n\n\tTextActions.prototype = {\n\t\tinit: function() {\n\t\t\tvar textView = this.editor.getTextView();\n\n\t\t\tthis._lastEditListener = {\n\t\t\t\tonModelChanged: function(e) {\n\t\t\t\t\tif (this.editor.isDirty()) {\n\t\t\t\t\t\tthis._lastEditLocation = e.start + e.addedCharCount;\n\t\t\t\t\t}\n\t\t\t\t}.bind(this)\n\t\t\t};\n\t\t\ttextView.addEventListener(\"ModelChanged\", this._lastEditListener.onModelChanged); //$NON-NLS-0$\n\n\t\t\ttextView.setAction(\"undo\", function(data) { //$NON-NLS-0$\n\t\t\t\tif (this.undoStack) {\n\t\t\t\t\tvar count = 1;\n\t\t\t\t\tif (data && data.count) {\n\t\t\t\t\t\tcount = data.count;\n\t\t\t\t\t}\n\t\t\t\t\twhile (count > 0) {\n\t\t\t\t\t\tthis.undoStack.undo();\n\t\t\t\t\t\t--count;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}.bind(this), {name: messages.undo});\n\n\t\t\ttextView.setAction(\"redo\", function(data) { //$NON-NLS-0$\n\t\t\t\tif (this.undoStack) {\n\t\t\t\t\tvar count = 1;\n\t\t\t\t\tif (data && data.count) {\n\t\t\t\t\t\tcount = data.count;\n\t\t\t\t\t}\n\t\t\t\t\twhile (count > 0) {\n\t\t\t\t\t\tthis.undoStack.redo();\n\t\t\t\t\t\t--count;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}.bind(this), {name: messages.redo});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"f\", true), \"find\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"find\", function() { //$NON-NLS-0$\n\t\t\t\tif (this._find) {\n\t\t\t\t\tvar selection = this.editor.getSelection();\n\t\t\t\t\tthis._find.show({findString:this.editor.getText(selection.start, selection.end)});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}.bind(this), {name: messages.find});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"k\", true), \"findNext\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"findNext\", function(options) { //$NON-NLS-0$\n\t\t\t\tif (this._find){\n\t\t\t\t\tthis._find.find(true, options);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}.bind(this), {name: messages.findNext});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"k\", true, true), \"findPrevious\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"findPrevious\", function(options) { //$NON-NLS-0$\n\t\t\t\tif (this._find){\n\t\t\t\t\tthis._find.find(false, options);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}.bind(this), {name: messages.findPrevious});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"j\", true), \"incrementalFind\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"incrementalFind\", function() { //$NON-NLS-0$\n\t\t\t\tif (this._incrementalFind) {\n\t\t\t\t\tthis._incrementalFind.find(true);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}.bind(this), {name: messages.incrementalFind});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"j\", true, true), \"incrementalFindReverse\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"incrementalFindReverse\", function() { //$NON-NLS-0$\n\t\t\t\tif (this._incrementalFind) {\n\t\t\t\t\tthis._incrementalFind.find(false);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}.bind(this), {name: messages.incrementalFindReverse});\n\n\t\t\ttextView.setAction(\"tab\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.indentLines();\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setAction(\"shiftTab\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.unindentLines();\n\t\t\t}.bind(this), {name: messages.unindentLines});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(38, false, false, true), \"moveLinesUp\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"moveLinesUp\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.moveLinesUp();\n\t\t\t}.bind(this), {name: messages.moveLinesUp});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(40, false, false, true), \"moveLinesDown\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"moveLinesDown\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.moveLinesDown();\n\t\t\t}.bind(this), {name: messages.moveLinesDown});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(38, true, false, true), \"copyLinesUp\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"copyLinesUp\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.copyLinesUp();\n\t\t\t}.bind(this), {name: messages.copyLinesUp});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(40, true, false, true), \"copyLinesDown\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"copyLinesDown\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.copyLinesDown();\n\t\t\t}.bind(this), {name: messages.copyLinesDown});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding('d', true, false, false), \"deleteLines\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"deleteLines\", function(data) { //$NON-NLS-0$\n\t\t\t\treturn this.deleteLines(data);\n\t\t\t}.bind(this), {name: messages.deleteLines});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"l\", !util.isMac, false, false, util.isMac), \"gotoLine\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"gotoLine\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.gotoLine();\n\t\t\t}.bind(this), {name: messages.gotoLine});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(190, true), \"nextAnnotation\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"nextAnnotation\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.nextAnnotation(true);\n\t\t\t}.bind(this), {name: messages.nextAnnotation});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(188, true), \"previousAnnotation\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"previousAnnotation\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.nextAnnotation(false);\n\t\t\t}.bind(this), {name: messages.prevAnnotation});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"e\", true, false, true, false), \"expand\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"expand\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.expandAnnotation(true);\n\t\t\t}.bind(this), {name: messages.expand});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"c\", true, false, true, false), \"collapse\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"collapse\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.expandAnnotation(false);\n\t\t\t}.bind(this), {name: messages.collapse});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"e\", true, true, true, false), \"expandAll\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"expandAll\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.expandAnnotations(true);\n\t\t\t}.bind(this), {name: messages.expandAll});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"c\", true, true, true, false), \"collapseAll\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"collapseAll\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.expandAnnotations(false);\n\t\t\t}.bind(this), {name: messages.collapseAll});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"q\", !util.isMac, false, false, util.isMac), \"lastEdit\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"lastEdit\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.gotoLastEdit();\n\t\t\t}.bind(this), {name: messages.lastEdit});\n\t\t},\n\t\tcopyLinesDown: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tvar lastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\tvar lineEnd = model.getLineEnd(lastLine, true);\n\t\t\t\tvar lineCount = model.getLineCount();\n\t\t\t\tvar delimiter = \"\";\n\t\t\t\tvar text = model.getText(lineStart, lineEnd);\n\t\t\t\tif (lastLine === lineCount-1) {\n\t\t\t\t\ttext = (delimiter = model.getLineDelimiter()) + text;\n\t\t\t\t}\n\t\t\t\tvar insertOffset = lineEnd;\n\t\t\t\tsetText(text, insertOffset, insertOffset);\n\t\t\t\tselection.start = insertOffset + delimiter.length;\n\t\t\t\tselection.end = insertOffset + text.length;\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\tcopyLinesUp: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tvar lastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\tvar lineEnd = model.getLineEnd(lastLine, true);\n\t\t\t\tvar lineCount = model.getLineCount();\n\t\t\t\tvar delimiter = \"\";\n\t\t\t\tvar text = model.getText(lineStart, lineEnd);\n\t\t\t\tif (lastLine === lineCount-1) {\n\t\t\t\t\ttext += (delimiter = model.getLineDelimiter());\n\t\t\t\t}\n\t\t\t\tvar insertOffset = lineStart;\n\t\t\t\tsetText(text, insertOffset, insertOffset);\n\t\t\t\tselection.start = insertOffset;\n\t\t\t\tselection.end = insertOffset + text.length - delimiter.length;\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\tdeleteLines: function(data) {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar count = 1;\n\t\t\tif (data && data.count) {\n\t\t\t\tcount = data.count;\n\t\t\t}\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\tvar lastLine;\n\t\t\t\tif (selection.start !== selection.end || count === 1) {\n\t\t\t\t\tlastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\t} else {\n\t\t\t\t\tlastLine = Math.min(firstLine + count - 1, model.getLineCount() - 1);\n\t\t\t\t}\t\n\t\t\t\tvar lineEnd = model.getLineEnd(lastLine, true);\n\t\t\t\tsetText(\"\", lineStart, lineEnd);\n\t\t\t\tselection.start = selection.end = lineStart;\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\texpandAnnotation: function(expand) {\n\t\t\tvar editor = this.editor;\n\t\t\tvar annotationModel = editor.getAnnotationModel();\n\t\t\tif(!annotationModel) { return true; }\n\t\t\tvar model = editor.getModel();\n\t\t\tvar currentOffset = editor.getCaretOffset();\n\t\t\tvar lineIndex = model.getLineAtOffset(currentOffset);\n\t\t\tvar start = model.getLineStart(lineIndex);\n\t\t\tvar end = model.getLineEnd(lineIndex, true);\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tstart = model.mapOffset(start);\n\t\t\t\tend = model.mapOffset(end);\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\tvar annotation, iter = annotationModel.getAnnotations(start, end);\n\t\t\twhile (!annotation && iter.hasNext()) {\n\t\t\t\tvar a = iter.next();\n\t\t\t\tif (a.type !== mAnnotations.AnnotationType.ANNOTATION_FOLDING) { continue; }\n\t\t\t\tannotation = a;\n\t\t\t}\n\t\t\tif (annotation) {\n\t\t\t\tif (expand !== annotation.expanded) {\n\t\t\t\t\tif (expand) {\n\t\t\t\t\t\tannotation.expand();\n\t\t\t\t\t} else {\n\t\t\t\t\t\teditor.setCaretOffset(annotation.start);\n\t\t\t\t\t\tannotation.collapse();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\texpandAnnotations: function(expand) {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tvar annotationModel = editor.getAnnotationModel();\n\t\t\tif(!annotationModel) { return true; }\n\t\t\tvar annotation, iter = annotationModel.getAnnotations();\n\t\t\ttextView.setRedraw(false);\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tannotation = iter.next();\n\t\t\t\tif (annotation.type !== mAnnotations.AnnotationType.ANNOTATION_FOLDING) { continue; }\n\t\t\t\tif (expand !== annotation.expanded) {\n\t\t\t\t\tif (expand) {\n\t\t\t\t\t\tannotation.expand();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tannotation.collapse();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttextView.setRedraw(true);\n\t\t\treturn true;\n\t\t},\n\t\tindentLines: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tif(!textView.getOptions(\"tabMode\")) { return; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tvar offset = 0;\n\t\t\tvar selections = editor.getSelections();\n\t\t\tif (selections.length > 1) this.startUndo();\n\t\t\tif (selections.some(function(selection) {\n\t\t\t\tselection.start += offset;\n\t\t\t\tselection.end += offset;\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tvar lastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\tif (firstLine !== lastLine || selections.length > 1) {\n\t\t\t\t\tvar lines = [];\n\t\t\t\t\tlines.push(\"\");\n\t\t\t\t\tfor (var i = firstLine; i <= lastLine; i++) {\n\t\t\t\t\t\tlines.push(model.getLine(i, true));\n\t\t\t\t\t}\n\t\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\t\tvar lineEnd = model.getLineEnd(lastLine, true);\n\t\t\t\t\tvar options = textView.getOptions(\"tabSize\", \"expandTab\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\tvar tab = options.expandTab ? new Array(options.tabSize + 1).join(\" \") : \"\\t\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\tvar text = lines.join(tab);\n\t\t\t\t\teditor.setText(text, lineStart, lineEnd);\n\t\t\t\t\tvar start = lineStart === selection.start ? selection.start : selection.start + tab.length;\n\t\t\t\t\tvar end = selection.end + ((lastLine - firstLine + 1) * tab.length);\n\t\t\t\t\toffset += (lineStart - lineEnd) + text.length;\n\t\t\t\t\tselection.start = start;\n\t\t\t\t\tselection.end = end;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t})) return false;\n\t\t\teditor.setSelections(selections);\n\t\t\tif (selections.length > 1) this.endUndo();\n\t\t\treturn true;\n\t\t},\n\t\tgotoLastEdit: function() {\n\t\t\tif (typeof this._lastEditLocation === \"number\")  { //$NON-NLS-0$\n\t\t\t\tthis.editor.showSelection(this._lastEditLocation);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tgotoLine: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar model = editor.getModel();\n\t\t\tvar line = model.getLineAtOffset(editor.getCaretOffset());\n\t\t\tline = prompt(messages.gotoLinePrompty, line + 1);\n\t\t\tif (line) {\n\t\t\t\tline = parseInt(line, 10);\n\t\t\t\teditor.onGotoLine(line - 1, 0);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tmoveLinesDown: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, true, function(selection, setText) {\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tvar lastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\tvar lineCount = model.getLineCount();\n\t\t\t\tif (lastLine !== lineCount-1) {\n\t\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\t\tvar lineEnd = model.getLineEnd(lastLine, true);\n\t\t\t\t\tvar insertOffset = model.getLineEnd(lastLine+1, true) - (lineEnd - lineStart);\n\t\t\t\t\tvar text, delimiterLength = 0;\n\t\t\t\t\tif (lastLine !== lineCount-2) {\n\t\t\t\t\t\ttext = model.getText(lineStart, lineEnd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Move delimiter following selection to front of the text\n\t\t\t\t\t\tvar lineEndNoDelimiter = model.getLineEnd(lastLine);\n\t\t\t\t\t\ttext = model.getText(lineEndNoDelimiter, lineEnd) + model.getText(lineStart, lineEndNoDelimiter);\n\t\t\t\t\t\tdelimiterLength += lineEnd - lineEndNoDelimiter;\n\t\t\t\t\t}\n\t\t\t\t\tsetText(\"\", lineStart, lineEnd);\n\t\t\t\t\tsetText(text, insertOffset, insertOffset);\n\t\t\t\t\tselection.start = insertOffset + delimiterLength;\n\t\t\t\t\tselection.end = insertOffset + delimiterLength + text.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\tmoveLinesUp: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, true, function(selection, setText) {\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tif (firstLine !== 0) {\n\t\t\t\t\tvar lastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\t\tvar lineCount = model.getLineCount();\n\t\t\t\t\tvar insertOffset = model.getLineStart(firstLine - 1);\n\t\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\t\tvar lineEnd = model.getLineEnd(lastLine, true);\n\t\t\t\t\tvar text = model.getText(lineStart, lineEnd);\n\t\t\t\t\tvar delimiterLength = 0;\n\t\t\t\t\tif (lastLine === lineCount-1) {\n\t\t\t\t\t\t// Move delimiter preceding selection to end of text\n\t\t\t\t\t\tvar delimiterStart = model.getLineEnd(firstLine - 1);\n\t\t\t\t\t\tvar delimiterEnd = model.getLineEnd(firstLine - 1, true);\n\t\t\t\t\t\ttext += model.getText(delimiterStart, delimiterEnd);\n\t\t\t\t\t\tlineStart = delimiterStart;\n\t\t\t\t\t\tdelimiterLength = delimiterEnd - delimiterStart;\n\t\t\t\t\t}\n\t\t\t\t\tsetText(\"\", lineStart, lineEnd);\n\t\t\t\t\tsetText(text, insertOffset, insertOffset);\n\t\t\t\t\tselection.start = insertOffset;\n\t\t\t\t\tselection.end = insertOffset + text.length - delimiterLength;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\tnextAnnotation: function (forward) {\n\t\t\tvar editor = this.editor;\n\t\t\tvar annotationModel = editor.getAnnotationModel();\n\t\t\tif (!annotationModel) { return true; }\n\t\t\tvar list = editor.getOverviewRuler() || editor.getAnnotationStyler();\n\t\t\tif (!list) { return true; }\n\t\t\tfunction ignore(annotation) {\n\t\t\t\treturn !!annotation.lineStyle ||\n\t\t\t\t\tannotation.type === AT.ANNOTATION_MATCHING_BRACKET ||\n\t\t\t\t\tannotation.type === AT.ANNOTATION_CURRENT_BRACKET ||\n\t\t\t\t\t!list.isAnnotationTypeVisible(annotation.type);\n\t\t\t}\n\t\t\tvar model = editor.getModel();\n\t\t\tvar currentOffset = editor.getCaretOffset();\n\t\t\tvar annotations = annotationModel.getAnnotations(forward ? currentOffset : 0, forward ? model.getCharCount() : currentOffset);\n\t\t\tvar foundAnnotation = null;\n\t\t\twhile (annotations.hasNext()) {\n\t\t\t\tvar annotation = annotations.next();\n\t\t\t\tif (forward) {\n\t\t\t\t\tif (annotation.start <= currentOffset) { continue; }\n\t\t\t\t} else {\n\t\t\t\t\tif (annotation.start >= currentOffset) { continue; }\n\t\t\t\t}\n\t\t\t\tif (ignore(annotation)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfoundAnnotation = annotation;\n\t\t\t\tif (forward) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (foundAnnotation) {\n\t\t\t\tvar foundAnnotations = [foundAnnotation];\n\t\t\t\tannotations = annotationModel.getAnnotations(foundAnnotation.start, foundAnnotation.start);\n\t\t\t\twhile (annotations.hasNext()) {\n\t\t\t\t\tannotation = annotations.next();\n\t\t\t\t\tif (annotation !== foundAnnotation && !ignore(annotation)) {\n\t\t\t\t\t\tfoundAnnotations.push(annotation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar view = editor.getTextView();\n\t\t\t\tvar nextLine = model.getLineAtOffset(foundAnnotation.start);\n\t\t\t\tvar tooltip = mTooltip.Tooltip.getTooltip(view);\n\t\t\t\tif (!tooltip) {\n\t\t\t\t\teditor.moveSelection(foundAnnotation.start);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\teditor.moveSelection(foundAnnotation.start, foundAnnotation.start, function() {\n\t\t\t\t\ttooltip.setTarget({\n\t\t\t\t\t\tgetTooltipInfo: function() {\n\t\t\t\t\t\t\tvar tooltipCoords = view.convert({\n\t\t\t\t\t\t\t\tx: view.getLocationAtOffset(foundAnnotation.start).x,\n\t\t\t\t\t\t\t\ty: view.getLocationAtOffset(model.getLineStart(nextLine)).y\n\t\t\t\t\t\t\t}, \"document\", \"page\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcontents: foundAnnotations,\n\t\t\t\t\t\t\t\tx: tooltipCoords.x,\n\t\t\t\t\t\t\t\ty: tooltipCoords.y + Math.floor(view.getLineHeight(nextLine) * 1.33)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tunindentLines: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tif(!textView.getOptions(\"tabMode\")) { return; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tvar lastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\tvar tabSize = textView.getOptions(\"tabSize\"); //$NON-NLS-0$\n\t\t\t\tvar spaceTab = new Array(tabSize + 1).join(\" \"); //$NON-NLS-0$\n\t\t\t\tvar lines = [], removeCount = 0, firstRemoveCount = 0;\n\t\t\t\tfor (var i = firstLine; i <= lastLine; i++) {\n\t\t\t\t\tvar line = model.getLine(i, true);\n\t\t\t\t\tif (model.getLineStart(i) !== model.getLineEnd(i)) {\n\t\t\t\t\t\tif (line.indexOf(\"\\t\") === 0) { //$NON-NLS-0$\n\t\t\t\t\t\t\tline = line.substring(1);\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t} else if (line.indexOf(spaceTab) === 0) {\n\t\t\t\t\t\t\tline = line.substring(tabSize);\n\t\t\t\t\t\t\tremoveCount += tabSize;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i === firstLine) {\n\t\t\t\t\t\tfirstRemoveCount = removeCount;\n\t\t\t\t\t}\n\t\t\t\t\tlines.push(line);\n\t\t\t\t}\n\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\tvar lineEnd = model.getLineEnd(lastLine, true);\n\t\t\t\tvar lastLineStart = model.getLineStart(lastLine);\n\t\t\t\tvar text = lines.join(\"\");\n\t\t\t\tsetText(text, lineStart, lineEnd);\n\t\t\t\tvar start = lineStart === selection.start ? selection.start : selection.start - firstRemoveCount;\n\t\t\t\tvar end = Math.max(start, selection.end - removeCount + (selection.end === lastLineStart+1 && selection.start !== selection.end ? 1 : 0));\n\t\t\t\tselection.start = start;\n\t\t\t\tselection.end = end;\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\tstartUndo: function() {\n\t\t\tif (this.undoStack) {\n\t\t\t\tthis.undoStack.startCompoundChange();\n\t\t\t}\n\t\t},\n\t\tendUndo: function() {\n\t\t\tif (this.undoStack) {\n\t\t\t\tthis.undoStack.endCompoundChange();\n\t\t\t}\n\t\t}\n\t};\n\texports.TextActions = TextActions;\n\n\t/**\n\t * @param {orion.editor.Editor} editor\n\t * @param {orion.editor.UndoStack} undoStack\n\t * @param {orion.editor.ContentAssist} [contentAssist]\n\t * @param {orion.editor.LinkedMode} [linkedMode]\n\t */\n\tfunction SourceCodeActions(editor, undoStack, contentAssist, linkedMode) {\n\t\tthis.editor = editor;\n\t\tthis.undoStack = undoStack;\n\t\tthis.contentAssist = contentAssist;\n\t\tthis.linkedMode = linkedMode;\n\t\tif (this.contentAssist) {\n\t\t\tthis.contentAssist.addEventListener(\"ProposalApplied\", this.contentAssistProposalApplied.bind(this)); //$NON-NLS-0$\n\t\t}\n\t\tthis.init();\n\t}\n\tSourceCodeActions.prototype = {\n\t\tinit: function() {\n\t\t\tvar textView = this.editor.getTextView();\n\n\t\t\ttextView.setAction(\"lineStart\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.lineStart();\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setAction(\"enter\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.autoIndent();\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"t\", true, false, true), \"trimTrailingWhitespaces\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"trimTrailingWhitespaces\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.trimTrailingWhitespaces();\n\t\t\t}.bind(this), {name: messages.trimTrailingWhitespaces});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(191, true), \"toggleLineComment\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"toggleLineComment\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.toggleLineComment();\n\t\t\t}.bind(this), {name: messages.toggleLineComment});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(191, true, !util.isMac, false, util.isMac), \"addBlockComment\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"addBlockComment\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.addBlockComment();\n\t\t\t}.bind(this), {name: messages.addBlockComment});\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(220, true, !util.isMac, false, util.isMac), \"removeBlockComment\"); //$NON-NLS-0$\n\t\t\ttextView.setAction(\"removeBlockComment\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.removeBlockComment();\n\t\t\t}.bind(this), {name: messages.removeBlockComment});\n\n\t\t\t// Autocomplete square brackets []\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"[\", false, false, false, false, \"keypress\"), \"autoPairSquareBracket\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"autoPairSquareBracket\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.autoPairBrackets(\"[\", \"]\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(']', false, false, false, false, \"keypress\"), \"skipClosingSquareBracket\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"skipClosingSquareBracket\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.skipClosingBracket(']'); //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\t// Autocomplete angle brackets <>\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"<\", false, false, false, false, \"keypress\"), \"autoPairAngleBracket\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"autoPairAngleBracket\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.autoPairBrackets(\"<\", \">\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding('>', false, false, false, false, \"keypress\"), \"skipClosingAngleBracket\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"skipClosingAngleBracket\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.skipClosingBracket('>'); //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\t// Autocomplete parentheses ()\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"(\", false, false, false, false, \"keypress\"), \"autoPairParentheses\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"autoPairParentheses\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.autoPairBrackets(\"(\", \")\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(')', false, false, false, false, \"keypress\"), \"skipClosingParenthesis\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"skipClosingParenthesis\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.skipClosingBracket(\")\"); //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\t// Autocomplete braces {}\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"{\", false, false, false, false, \"keypress\"), \"autoPairBraces\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"autoPairBraces\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.autoPairBrackets(\"{\", \"}\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding('}', false, false, false, false, \"keypress\"), \"skipClosingBrace\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"skipClosingBrace\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.skipClosingBracket(\"}\"); //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\t// Autocomplete single quotations\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding(\"'\", false, false, false, false, \"keypress\"), \"autoPairSingleQuotation\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"autoPairSingleQuotation\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.autoPairQuotations(\"'\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\t// Autocomplete double quotations\n\t\t\ttextView.setKeyBinding(new mKeyBinding.KeyBinding('\"', false, false, false, false, \"keypress\"), \"autoPairDblQuotation\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\ttextView.setAction(\"autoPairDblQuotation\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.autoPairQuotations('\"'); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t}.bind(this));\n\n\t\t\ttextView.setAction(\"deletePrevious\", function() { //$NON-NLS-0$\n\t\t\t\treturn this.deletePrevious();\n\t\t\t}.bind(this));\n\t\t},\n\t\tautoIndent: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tif (textView.getOptions(\"singleMode\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tvar options = textView.getOptions(\"tabSize\", \"expandTab\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar tab = options.expandTab ? new Array(options.tabSize + 1).join(\" \") : \"\\t\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar lineDelimiter = model.getLineDelimiter();\n\t\t\tvar matchCommentStart = /^[\\s]*\\/\\*[\\*]*[\\s]*$/;\n\t\t\tvar matchCommentDelimiter = /^[\\s]*\\*/;\n\t\t\tvar matchCommentEnd = /\\*\\/[\\s]*$/;\n\t\t\tvar self = this;\n\t\t\tfunction indent(selection, setText) {\n\t\t\t\tif (selection.start === selection.end) {\n\t\t\t\t\tvar lineIndex = model.getLineAtOffset(selection.start);\n\t\t\t\t\tvar lineText = model.getLine(lineIndex, false);\n\t\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\t\tvar index = 0;\n\t\t\t\t\tvar lineOffset = selection.start - lineStart;\n\t\t\t\t\tvar c;\n\t\t\t\t\twhile (index < lineOffset && ((c = lineText.charCodeAt(index)) === 32 || c === 9)) { index++; }\n\t\t\t\t\tvar prefix = lineText.substring(0, index);\n\t\t\t\t\tvar lineTextBeforeCaret = lineText.substring(0, lineOffset);\n\t\t\t\t\tvar lineTextAfterCaret = lineText.substring(lineOffset);\n\t\t\t\t\tvar text;\n\t\t\t\t\t// If the character before the caret is an opening brace, smart indent the next line.\n\t\t\t\t\tvar prevCharIdx;\n\t\t\t\t\tif (self.smartIndentation && lineText.charCodeAt(prevCharIdx = lineTextBeforeCaret.trimRight().length - 1) === 123) {\n\t\t\t\t\t\t// Remove any extra whitespace\n\t\t\t\t\t\tvar whitespaceBeforeCaret = lineOffset - prevCharIdx - 1;\n\t\t\t\t\t\tvar whitespaceAfterCaret = lineTextAfterCaret.length - lineTextAfterCaret.trimLeft().length;\n\t\n\t\t\t\t\t\ttext = lineText.charCodeAt(lineOffset + whitespaceAfterCaret) === 125 ?\n\t\t\t\t\t\t\t   lineDelimiter + prefix + tab + lineDelimiter + prefix :\n\t\t\t\t\t\t\t   lineDelimiter + prefix + tab;\n\t\n\t\t\t\t\t\tsetText(text, selection.start - whitespaceBeforeCaret, selection.end + whitespaceAfterCaret);\n\t\t\t\t\t\tselection.start = selection.end = selection.start + lineDelimiter.length + prefix.length + tab.length - whitespaceBeforeCaret;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t// Proceed with autocompleting multi-line comment if the text before the caret matches\n\t\t\t\t\t// the start or comment delimiter (*) of a multi-line comment\n\t\t\t\t\t} else if (self.autoCompleteComments && !matchCommentEnd.test(lineTextBeforeCaret) &&\n\t\t\t\t\t\t\t\t(matchCommentStart.test(lineTextBeforeCaret) || matchCommentDelimiter.test(lineTextBeforeCaret))) {\n\t\t\t\t\t\tvar caretOffset;\n\t\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Matches the start of a multi-line comment. Autocomplete the multi-line block comment,\n\t\t\t\t\t\t * moving any text after the caret into the block comment and setting the caret to be\n\t\t\t\t\t\t * after the comment delimiter.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tvar match = matchCommentStart.exec(lineTextBeforeCaret);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\ttext = lineDelimiter + prefix + \" * \"; //$NON-NLS-0$\n\t\t\t\t\t\t\t// Text added into the comment block are trimmed of all preceding and trailing whitespaces.\n\t\t\t\t\t\t\t// If the text after the caret contains the ending of a block comment, exclude the ending.\n\t\t\t\t\t\t\tif (matchCommentEnd.test(lineTextAfterCaret)) {\n\t\t\t\t\t\t\t\ttext += lineTextAfterCaret.substring(0, lineTextAfterCaret.length - 2).trim();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttext += lineTextAfterCaret.trim();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Add the closing to the multi-line block comment if the next line is not a\n\t\t\t\t\t\t\t// comment delimiter.\n\t\t\t\t\t\t\tif ((model.getLineCount() === lineIndex + 1) ||\n\t\t\t\t\t\t\t\t!matchCommentDelimiter.test(model.getLine(lineIndex + 1))) {\n\t\t\t\t\t\t\t\ttext += lineDelimiter + prefix + \" */\"; //$NON-NLS-0$\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetText(text, selection.start, selection.end + lineTextAfterCaret.length);\n\t\t\t\t\t\t\tselection.start = selection.end = selection.start + lineDelimiter.length + prefix.length + 3;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Matches a comment delimiter (*) as the start of the line, and traverses up the lines to confirm if\n\t\t\t\t\t\t * it is a multi-line comment by matching the start of a block comment. If so, continue the\n\t\t\t\t\t\t * multi-line comment in the next line. Any text that follows after the caret is moved to the newly\n\t\t\t\t\t\t * added comment delimiter.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmatch = matchCommentDelimiter.exec(lineTextBeforeCaret);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tfor (var i = lineIndex - 1; i >= 0; i--) {\n\t\t\t\t\t\t\t\tvar prevLine = model.getLine(i, false);\n\t\t\t\t\t\t\t\tif (matchCommentStart.test(prevLine)) {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * If the text after the caret matches the end of a comment block or the character in front of the\n\t\t\t\t\t\t\t\t\t * caret is a forward slash, continue the block comment with the caret and text after the caret on\n\t\t\t\t\t\t\t\t\t * the next line directly in front of the star (*).\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (matchCommentEnd.test(lineTextAfterCaret) || lineText.charCodeAt(lineOffset) === 47) {\n\t\t\t\t\t\t\t\t\t\ttext = lineDelimiter + prefix + \"*\" + lineTextAfterCaret; //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\t\tcaretOffset = selection.start + lineDelimiter.length + prefix.length + 1;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttext = lineDelimiter + prefix + \"* \" + lineTextAfterCaret; //$NON-NLS-0$\n\t\t\t\t\t\t\t\t\t\tcaretOffset = selection.start + lineDelimiter.length + prefix.length + 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsetText(text, selection.start, selection.end + lineTextAfterCaret.length);\n\t\t\t\t\t\t\t\t\tselection.start = selection.end = caretOffset;\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t} else if (!matchCommentDelimiter.test(prevLine)) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (matchCommentEnd.test(lineTextBeforeCaret) && prefix.charCodeAt(prefix.length - 1) === 32) {\n\t\t\t\t\t\t// Matches the end of a block comment. Fix the indentation for the following line.\n\t\t\t\t\t\ttext = lineDelimiter + prefix.substring(0, prefix.length - 1);\n\t\t\t\t\t\tsetText(text, selection.start, selection.end);\n\t\t\t\t\t\tselection.start = selection.end = selection.start + text.length;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (index > 0) {\n\t\t\t\t\t\t//TODO still wrong when typing inside folding\n\t\t\t\t\t\tindex = lineOffset;\n\t\t\t\t\t\twhile (index < lineText.length && ((c = lineText.charCodeAt(index++)) === 32 || c === 9)) { selection.end++; }\n\t\t\t\t\t\ttext = model.getLineDelimiter() + prefix;\n\t\t\t\t\t\tsetText(text, selection.start, selection.end);\n\t\t\t\t\t\tselection.start = selection.end = selection.start + text.length;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tforEachSelection(this, true, function(selection, setText) {\n\t\t\t\tif (!indent(selection, setText)) {\n\t\t\t\t\tsetText(lineDelimiter, selection.start, selection.end);\n\t\t\t\t\tselection.start = selection.end = selection.start + lineDelimiter.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\taddBlockComment: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tvar open = \"/*\", close = \"*/\", commentTags = new RegExp(\"/\\\\*\" + \"|\" + \"\\\\*/\", \"g\"); //$NON-NLS-5$ //$NON-NLS-4$ //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar self = this;\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tvar result = self._findEnclosingComment(model, selection.start, selection.end);\n\t\t\t\tif (result.commentStart !== undefined && result.commentEnd !== undefined) {\n\t\t\t\t\treturn; // Already in a comment\n\t\t\t\t}\n\t\n\t\t\t\tvar text = model.getText(selection.start, selection.end);\n\t\t\t\tif (text.length === 0) { return; }\n\t\n\t\t\t\tvar oldLength = text.length;\n\t\t\t\ttext = text.replace(commentTags, \"\");\n\t\t\t\tvar newLength = text.length;\n\t\t\t\ttext = open + text + close;\n\t\n\t\t\t\tsetText(text, selection.start, selection.end);\n\t\t\t\tselection.start += open.length;\n\t\t\t\tselection.end +=  open.length + (newLength-oldLength);\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * Called on an opening bracket keypress.\n\t\t * Automatically inserts the specified opening and closing brackets around the caret or selected text.\n\t\t */\n\t\tautoPairBrackets: function(openBracket, closeBracket) {\n\t\t\tif (openBracket === \"[\" && !this.autoPairSquareBrackets) { //$NON-NLS-0$\n\t\t\t\treturn false;\n\t\t\t} else if (openBracket === \"{\" && !this.autoPairBraces) { //$NON-NLS-0$\n\t\t\t\treturn false;\n\t\t\t} else if (openBracket === \"(\" && !this.autoPairParentheses) { //$NON-NLS-0$\n\t\t\t\treturn false;\n\t\t\t} else if (openBracket === \"<\" && !this.autoPairAngleBrackets) { //$NON-NLS-0$\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar isClosingBracket = new RegExp(\"^$|[)}\\\\]>]\"); //$NON-NLS-0$ // matches any empty string and closing bracket\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tvar nextChar = (selection.start === model.getCharCount()) ? \"\" : model.getText(selection.start, selection.start + 1).trim(); //$NON-NLS-0$\n\t\t\t\tvar text;\n\t\t\t\tif (selection.start === selection.end && isClosingBracket.test(nextChar)) {\n\t\t\t\t\t// No selection and subsequent character is not a closing bracket - wrap the caret with the opening and closing brackets,\n\t\t\t\t\t// and maintain the caret position inbetween the brackets\n\t\t\t\t\ttext = openBracket + closeBracket;\n\t\t\t\t\tsetText(text, selection.start, selection.start);\n\t\t\t\t\tselection.start = selection.end = selection.start + 1;\n\t\t\t\t} else if (selection.start !== selection.end) {\n\t\t\t\t\t// Wrap the selected text with the specified opening and closing brackets and keep selection on text\n\t\t\t\t\ttext = openBracket + model.getText(selection.start, selection.end) + closeBracket;\n\t\t\t\t\tsetText(text, selection.start, selection.end);\n\t\t\t\t\tselection.start += 1;\n\t\t\t\t\tselection.end += 1;\n\t\t\t\t} else {\n\t\t\t\t\tsetText(openBracket, selection.start, selection.end);\n\t\t\t\t\tselection.start = selection.end = selection.start + openBracket.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * Called on a quotation mark keypress.\n\t\t * Automatically inserts a pair of the specified quotation around the caret the caret or selected text.\n\t\t */\n\t\tautoPairQuotations: function(quotation) {\n\t\t\tif (!this.autoPairQuotation) { return false; }\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar isQuotation = new RegExp(\"^\\\"$|^'$\"); //$NON-NLS-0$\n\t\t\tvar isAlpha = new RegExp(\"\\\\w\"); //$NON-NLS-0$\n\t\t\tvar isClosingBracket = new RegExp(\"^$|[)}\\\\]>]\"); //$NON-NLS-0$ // matches any empty string and closing bracket\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tvar prevChar = (selection.start === 0) ? \"\" : model.getText(selection.start - 1, selection.start).trim(); //$NON-NLS-0$\n\t\t\t\tvar nextChar = (selection.start === model.getCharCount()) ? \"\" : model.getText(selection.start, selection.start + 1).trim(); //$NON-NLS-0$\n\t\t\t\tfunction insertQuotation() {\n\t\t\t\t\tsetText(quotation, selection.start, selection.end);\n\t\t\t\t\tselection.start = selection.end = selection.start + quotation.length;\n\t\t\t\t}\n\t\t\t\t// Wrap the selected text with the specified opening and closing quotation marks and keep selection on text\n\t\t\t\tif (selection.start !== selection.end) {\n\t\t\t\t\tvar text = model.getText(selection.start, selection.end);\n\t\t\t\t\tif (isQuotation.test(text)) {\n\t\t\t\t\t\tinsertQuotation();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetText(quotation + text + quotation, selection.start, selection.end);\n\t\t\t\t\t\tselection.start += 1;\n\t\t\t\t\t\tselection.end += 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (nextChar === quotation) {\n\t\t\t\t\t// Skip over the next character if it matches the specified quotation mark\n\t\t\t\t\tselection.start = selection.end = selection.start + 1;\n\t\t\t\t} else if (prevChar === quotation || isQuotation.test(nextChar) || isAlpha.test(prevChar) || !isClosingBracket.test(nextChar)) {\n\t\t\t\t\tinsertQuotation();\n\t\t\t\t} else {\n\t\t\t\t\t// No selection - wrap the caret with the opening and closing quotation marks, and maintain the caret position inbetween the quotations\n\t\t\t\t\tsetText(quotation + quotation, selection.start, selection.end);\n\t\t\t\t\tselection.start = selection.end = selection.start + quotation.length;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * Called when a content assist proposal has been applied. Inserts the proposal into the\n\t\t * document. Activates Linked Mode if applicable for the selected proposal.\n\t\t * @param {orion.editor.ContentAssist#ProposalAppliedEvent} event\n\t\t */\n\t\tcontentAssistProposalApplied: function(event) {\n\t\t\t/*\n\t\t\t * The event.proposal is an object with this shape:\n\t\t\t * {   proposal: \"[proposal string]\", // Actual text of the proposal\n\t\t\t *     description: \"diplay string\", // Optional\n\t\t\t *     positions: [{\n\t\t\t *         offset: 10, // Offset of start position of parameter i\n\t\t\t *         length: 3  // Length of parameter string for parameter i\n\t\t\t *     }], // One object for each parameter; can be null\n\t\t\t *     escapePosition: 19, // Optional; offset that caret will be placed at after exiting Linked Mode.\n\t\t\t *     style: 'emphasis', // Optional: either emphasis, noemphasis, hr to provide custom styling for the proposal\n\t\t\t *     unselectable: false // Optional: if set to true, then this proposal cannnot be selected through the keyboard\n\t\t\t * }\n\t\t\t * Offsets are relative to the text buffer.\n\t\t\t */\n\t\t\tvar proposal = event.data.proposal;\n\n\t\t\t// If escapePosition is not provided, positioned the cursor at the end of the inserted text \n\t\t\tfunction escapePosition() {\n\t\t\t\tif (typeof proposal.escapePosition === \"number\") { //$NON-NLS-0$\n\t\t\t\t\treturn proposal.escapePosition;\n\t\t\t\t}\n\t\t\t\treturn event.data.start + proposal.proposal.length;\n\t\t\t}\n\n\t\t\t//if the proposal specifies linked positions, build the model and enter linked mode\n\t\t\tif (proposal.positions && proposal.positions.length > 0 && this.linkedMode) {\n\t\t\t\tvar positionGroups = [];\n\t\t\t\tfor (var i = 0; i < proposal.positions.length; ++i) {\n\t\t\t\t\tpositionGroups[i] = {\n\t\t\t\t\t\tpositions: [{\n\t\t\t\t\t\t\toffset: proposal.positions[i].offset,\n\t\t\t\t\t\t\tlength: proposal.positions[i].length\n\t\t\t\t\t\t}]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.linkedMode.enterLinkedMode({\n\t\t\t\t\tgroups: positionGroups,\n\t\t\t\t\tescapePosition: escapePosition()\n\t\t\t\t});\n\t\t\t} else if (proposal.groups && proposal.groups.length > 0 && this.linkedMode) {\n\t\t\t\tthis.linkedMode.enterLinkedMode({\n\t\t\t\t\tgroups: proposal.groups,\n\t\t\t\t\tescapePosition: escapePosition()\n\t\t\t\t});\n\t\t\t} else if (typeof proposal.escapePosition === \"number\") { //$NON-NLS-0$\n\t\t\t\t//we don't want linked mode, but there is an escape position, so just set cursor position\n\t\t\t\tvar textView = this.editor.getTextView();\n\t\t\t\ttextView.setCaretOffset(proposal.escapePosition);\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t// On backspace keypress, checks if there are a pair of brackets or quotation marks to be deleted\n\t\tdeletePrevious: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\t\t\t\tif (selection.start !== selection.end) { return; }\n\t\t\t\n\t\t\t\tvar prevChar = (selection.start === 0) ? \"\" : model.getText(selection.start - 1, selection.start); //$NON-NLS-0$\n\t\t\t\tvar nextChar = (selection.start === model.getCharCount()) ? \"\" : model.getText(selection.start, selection.start + 1); //$NON-NLS-0$\n\t\n\t\t\t\tif ((prevChar === \"(\" && nextChar === \")\") || //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t(prevChar === \"[\" && nextChar === \"]\") || //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t(prevChar === \"{\" && nextChar === \"}\") || //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t(prevChar === \"<\" && nextChar === \">\") || //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t(prevChar === '\"' && nextChar === '\"') || //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t(prevChar === \"'\" && nextChar === \"'\")) { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\tsetText(\"\", selection.start, selection.start + 1); //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}, true);\n\t\t\treturn false;\n\t\t},\n\t\t_findEnclosingComment: function(model, start, end) {\n\t\t\tvar open = \"/*\", close = \"*/\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar firstLine = model.getLineAtOffset(start);\n\t\t\tvar lastLine = model.getLineAtOffset(end);\n\t\t\tvar i, line, extent, openPos, closePos;\n\t\t\tvar commentStart, commentEnd;\n\t\t\tfor (i=firstLine; i >= 0; i--) {\n\t\t\t\tline = model.getLine(i);\n\t\t\t\textent = (i === firstLine) ? start - model.getLineStart(firstLine) : line.length;\n\t\t\t\topenPos = line.lastIndexOf(open, extent);\n\t\t\t\tclosePos = line.lastIndexOf(close, extent);\n\t\t\t\tif (closePos > openPos) {\n\t\t\t\t\tbreak; // not inside a comment\n\t\t\t\t} else if (openPos !== -1) {\n\t\t\t\t\tcommentStart = model.getLineStart(i) + openPos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i=lastLine; i < model.getLineCount(); i++) {\n\t\t\t\tline = model.getLine(i);\n\t\t\t\textent = (i === lastLine) ? end - model.getLineStart(lastLine) : 0;\n\t\t\t\topenPos = line.indexOf(open, extent);\n\t\t\t\tclosePos = line.indexOf(close, extent);\n\t\t\t\tif (openPos !== -1 && openPos < closePos) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (closePos !== -1) {\n\t\t\t\t\tcommentEnd = model.getLineStart(i) + closePos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {commentStart: commentStart, commentEnd: commentEnd};\n\t\t},\n\t\tlineStart: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar model = editor.getModel();\n\t\t\tforEachSelection(this, false, function(selection/*, setText*/) {\n\t\t\t\tvar caretOffset = selection.getCaret();\n\t\t\t\tvar lineIndex = model.getLineAtOffset(caretOffset);\n\t\t\t\tvar lineOffset = model.getLineStart(lineIndex);\n\t\t\t\tvar lineText = model.getLine(lineIndex);\n\t\t\t\tvar offset;\n\t\t\t\tfor (offset=0; offset<lineText.length; offset++) {\n\t\t\t\t\tvar c = lineText.charCodeAt(offset);\n\t\t\t\t\tif (!(c === 32 || c === 9)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toffset += lineOffset;\n\t\t\t\tif (caretOffset !== offset) {\n\t\t\t\t\tselection.setCaret(offset);\n\t\t\t\t} else {\n\t\t\t\t\tselection.setCaret(lineOffset);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\tremoveBlockComment: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tvar open = \"/*\", close = \"*/\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar self  = this;\n\t\t\tforEachSelection(this, false, function(selection, setText) {\n\n\t\t\t\t// Try to shrink selection to a comment block\n\t\t\t\tvar selectedText = model.getText(selection.start, selection.end);\n\t\t\t\tvar newStart, newEnd;\n\t\t\t\tvar i;\n\t\t\t\tfor(i=0; i < selectedText.length; i++) {\n\t\t\t\t\tif (selectedText.substring(i, i + open.length) === open) {\n\t\t\t\t\t\tnewStart = selection.start + i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (; i < selectedText.length; i++) {\n\t\t\t\t\tif (selectedText.substring(i, i + close.length) === close) {\n\t\t\t\t\t\tnewEnd = selection.start + i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar text;\n\t\t\t\tif (newStart !== undefined && newEnd !== undefined) {\n\t\t\t\t\ttext = model.getText(newStart + open.length, newEnd);\n\t\t\t\t\tsetText(text, newStart, newEnd + close.length);\n\t\t\t\t\tselection.start = newStart;\n\t\t\t\t\tselection.end = newEnd;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise find enclosing comment block\n\t\t\t\t\tvar result = self._findEnclosingComment(model, selection.start, selection.end);\n\t\t\t\t\tif (!(result.commentStart === undefined || result.commentEnd === undefined)) {\n\t\t\t\t\t\ttext = model.getText(result.commentStart + open.length, result.commentEnd);\n\t\t\t\t\t\tsetText(text, result.commentStart, result.commentEnd + close.length);\n\t\t\t\t\t\tselection.start = selection.start - open.length;\n\t\t\t\t\t\tselection.end = selection.end - close.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t},\n\t\ttoggleLineComment: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar comment = this.lineComment || \"//\"; //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\ttextView.setRedraw(false);\n\t\t\tforEachSelection(this, true, function(selection, setText) {\n\t\t\t\tvar firstLine = model.getLineAtOffset(selection.start);\n\t\t\t\tvar lastLine = model.getLineAtOffset(selection.end > selection.start ? selection.end - 1 : selection.end);\n\t\t\t\tvar uncomment = true, lineIndices = [], index;\n\t\t\t\tfor (var i = firstLine; i <= lastLine; i++) {\n\t\t\t\t\tvar lineText = model.getLine(i, true);\n\t\t\t\t\tindex = lineText.indexOf(comment);\n\t\t\t\t\tlineIndices.push(index);\n\t\t\t\t\tif (!uncomment || index === -1) {\n\t\t\t\t\t\tuncomment = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (index !== 0) {\n\t\t\t\t\t\t\tvar j;\n\t\t\t\t\t\t\tfor (j=0; j<index; j++) {\n\t\t\t\t\t\t\t\tvar c = lineText.charCodeAt(j);\n\t\t\t\t\t\t\t\tif (!(c === 32 || c === 9)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tuncomment = j === index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar selStart, selEnd, l = comment.length, k;\n\t\t\t\tvar lineStart = model.getLineStart(firstLine);\n\t\t\t\tif (uncomment) {\n\t\t\t\t\tfor (k = lineIndices.length - 1; k >= 0; k--) {\n\t\t\t\t\t\tindex = lineIndices[k] + model.getLineStart(firstLine + k);\n\t\t\t\t\t\tsetText(\"\", index, index + l);\n\t\t\t\t\t}\n\t\t\t\t\tvar lastLineStart = model.getLineStart(lastLine);\n\t\t\t\t\tselStart = lineStart === selection.start ? selection.start : selection.start - l;\n\t\t\t\t\tselEnd = selection.end - (l * (lastLine - firstLine + 1)) + (selection.end === lastLineStart+1 ? l : 0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (k = lineIndices.length - 1; k >= 0; k--) {\n\t\t\t\t\t\tindex = model.getLineStart(firstLine + k);\n\t\t\t\t\t\tsetText(comment, index, index);\n\t\t\t\t\t}\n\t\t\t\t\tselStart = lineStart === selection.start ? selection.start : selection.start + l;\n\t\t\t\t\tselEnd = selection.end + (l * (lastLine - firstLine + 1));\n\t\t\t\t}\n\t\t\t\tselection.start = selStart;\n\t\t\t\tselection.end = selEnd;\n\t\t\t});\n\t\t\ttextView.setRedraw(true);\n\t\t\treturn true;\n\t\t},\n\t\ttrimTrailingWhitespaces: function() {\n\t\t\tvar editor = this.editor;\n\t\t\tvar model = editor.getModel();\n\t\t\tvar selections = editor.getSelections();\n\t\t\teditor.getTextView().setRedraw(false);\n\t\t\tthis.startUndo();\n\t\t\tvar matchTrailingWhiteSpace = /(\\s+$)/;\n\t\t\tvar lineCount = model.getLineCount();\n\t\t\tfor (var i = 0; i < lineCount; i++) {\n\t\t\t\tvar lineText = model.getLine(i);\n\t\t\t\tvar match = matchTrailingWhiteSpace.exec(lineText);\n\t\t\t\tif (match) {\n\t\t\t\t\tvar lineStartOffset = model.getLineStart(i);\n\t\t\t\t\tvar matchLength = match[0].length;\n\t\t\t\t\tvar start = lineStartOffset + match.index;\n\t\t\t\t\tmodel.setText(\"\", start, start + matchLength);\n\t\t\t\t\t/**\n\t\t\t\t\t * Move the caret to its original position prior to the save. If the caret\n\t\t\t\t\t * was in the trailing whitespaces, move the caret to the end of the line.\n\t\t\t\t\t */\n\t\t\t\t\tselections.forEach(function(selection) {\n\t\t\t\t\t\tif (selection.start > start) {\n\t\t\t\t\t\t\tselection.start = Math.max(start, selection.start - matchLength);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (selection.start !== selection.end && selection.end > start) {\n\t\t\t\t\t\t\tselection.end = Math.max(start, selection.end - matchLength);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.endUndo();\n\t\t\teditor.setSelections(selections, false);\n\t\t\teditor.getTextView().setRedraw(true);\n\t\t},\n\t\tstartUndo: function() {\n\t\t\tif (this.undoStack) {\n\t\t\t\tthis.undoStack.startCompoundChange();\n\t\t\t}\n\t\t},\n\t\tskipClosingBracket: function(closingChar) {\n\t\t\tvar editor = this.editor;\n\t\t\tvar textView = editor.getTextView();\n\t\t\tif (textView.getOptions(\"readonly\")) { return false; } //$NON-NLS-0$\n\t\t\tvar model = editor.getModel();\n\t\t\tvar selections = editor.getSelections();\n\t\t\tif (selections.length === 1 && selections[0].start === selections[0].end) {\n\t\t\t\tvar nextChar = selections[0].start === model.getCharCount() ? \"\" : model.getText(selections[0].start, selections[0].start + 1); //$NON-NLS-0$\n\t\t\t\tif (nextChar === closingChar) {\n\t\t\t\t\tselections[0].start = selections[0].end = selections[0].start + 1;\n\t\t\t\t\teditor.setSelections(selections);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tendUndo: function() {\n\t\t\tif (this.undoStack) {\n\t\t\t\tthis.undoStack.endCompoundChange();\n\t\t\t}\n\t\t},\n\t\tsetAutoPairParentheses: function(enabled) {\n\t\t\tthis.autoPairParentheses = enabled;\n\t\t},\n\t\tsetAutoPairBraces: function(enabled) {\n\t\t\tthis.autoPairBraces = enabled;\n\t\t},\n\t\tsetAutoPairSquareBrackets: function(enabled) {\n\t\t\tthis.autoPairSquareBrackets = enabled;\n\t\t},\n\t\tsetAutoPairAngleBrackets: function(enabled) {\n\t\t\tthis.autoPairAngleBrackets = enabled;\n\t\t},\n\t\tsetAutoPairQuotations: function(enabled) {\n\t\t\tthis.autoPairQuotation = enabled;\n\t\t},\n\t\tsetAutoCompleteComments: function(enabled) {\n\t\t\tthis.autoCompleteComments = enabled;\n\t\t},\n\t\tsetLineComment: function(lineComment) {\n\t\t\tthis.lineComment = lineComment;\n\t\t},\n\t\tsetSmartIndentation: function(enabled) {\n\t\t\tthis.smartIndentation = enabled;\n\t\t}\n\t};\n\texports.SourceCodeActions = SourceCodeActions;\n\n\tif (!String.prototype.trimLeft) {\n\t\tString.prototype.trimLeft = function(){\n\t\t\treturn this.replace(/^\\s+/g, '');\n\t\t};\n\t}\n\tif (!String.prototype.trimRight) {\n\t\tString.prototype.trimRight = function(){\n\t\t\treturn this.replace(/\\s+$/g, '');\n\t\t};\n\t}\n\n\treturn exports;\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/undoStack\", [], function() { //$NON-NLS-0$\n\n\t/** \n\t * Constructs a new Change object.\n\t * \n\t * @class \n\t * @name orion.editor.Change\n\t * @private\n\t */\n\tfunction Change(model, offset, text, previousText, type) {\n\t\tthis.model = model;\n\t\tthis.offset = offset;\n\t\tthis.text = text;\n\t\tthis.previousText = previousText;\n\t\tthis.type = type;\n\t}\n\tChange.prototype = {\n\t\t/** @ignore */\n\t\tgetRedoChanges: function() {\n\t\t\treturn [{start: this.offset, end: this.offset + this.previousText.length, text: this.text}];\n\t\t},\n\t\t/** @ignore */\n\t\tgetUndoChanges: function() {\n\t\t\treturn [{start: this.offset, end: this.offset + this.text.length, text: this.previousText}];\n\t\t},\n\t\t/** @ignore */\n\t\tundo: function (view, select) {\n\t\t\tthis._doUndoRedo(this.offset, this.previousText, this.text, view, select);\n\t\t\treturn true;\n\t\t},\n\t\t/** @ignore */\n\t\tredo: function (view, select) {\n\t\t\tthis._doUndoRedo(this.offset, this.text, this.previousText, view, select);\n\t\t\treturn true;\n\t\t},\n\t\tmerge: function(start, text, previousText, type, end) {\n\t\t\tif (type === this.type) {\n\t\t\t\tif (type === 1 && start === this.offset + this.text.length) {\n\t\t\t\t\tthis.text += text;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (type === -1 && end === this.offset) {\n\t\t\t\t\tthis.offset = start;\n\t\t\t\t\tthis.previousText = previousText + this.previousText;\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (type === -1 && start === this.offset) {\n\t\t\t\t\tthis.previousText = this.previousText + previousText;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t_doUndoRedo: function(offset, text, previousText, view, select) {\n\t\t\tthis.model.setText(text, offset, offset + previousText.length);\n\t\t\tif (select && view) {\n\t\t\t\tvar model = view.getModel();\n\t\t\t\tif (model !== this.model) {\n\t\t\t\t\toffset = model.mapOffset(offset, true);\n\t\t\t\t}\n\t\t\t\tview.setSelection(offset, offset + text.length);\n\t\t\t}\n\t\t}\n\t};\n\n\t/** \n\t * Constructs a new CompoundChange object.\n\t * \n\t * @param owner the owner of the compound change\n\t *\n\t * @class \n\t * @name orion.editor.CompoundChange\n\t * @private\n\t */\n\tfunction CompoundChange (owner) {\n\t\tthis.owner = owner;\n\t\tthis.changes = [];\n\t}\n\tCompoundChange.prototype = {\n\t\t/** @ignore */\n\t\tgetRedoChanges: function() {\n\t\t\tvar changes = [];\n\t\t\tfor (var i=0; i<this.changes.length; i++) {\n\t\t\t\tchanges = changes.concat(this.changes[i].getRedoChanges());\n\t\t\t}\n\t\t\treturn changes;\n\t\t},\n\t\t/** @ignore */\n\t\tgetUndoChanges: function() {\n\t\t\tvar changes = [];\n\t\t\tfor (var i=this.changes.length - 1; i >= 0; i--) {\n\t\t\t\tchanges = changes.concat(this.changes[i].getUndoChanges());\n\t\t\t}\n\t\t\treturn changes;\n\t\t},\n\t\t/** @ignore */\n\t\tadd: function (change) {\n\t\t\tthis.changes.push(change);\n\t\t},\n\t\t/** @ignore */\n\t\tend: function (view) {\n\t\t\tif (view) {\n\t\t\t\tthis.endSelection = view.getSelections();\n\t\t\t}\n\t\t\tvar owner = this.owner;\n\t\t\tif (owner && owner.end) {\n\t\t\t\towner.end();\n\t\t\t}\n\t\t},\n\t\t/** @ignore */\n\t\tundo: function (view, select) {\n\t\t\tif (this.changes.length > 1 && view) {\n\t\t\t\tview.setRedraw(false);\n\t\t\t}\n\t\t\tfor (var i=this.changes.length - 1; i >= 0; i--) {\n\t\t\t\tthis.changes[i].undo(view, false);\n\t\t\t}\n\t\t\tif (select && view) {\n\t\t\t\tview.setSelections(this.startSelection);\n\t\t\t}\n\t\t\tif (this.changes.length > 1 && view) {\n\t\t\t\tview.setRedraw(true);\n\t\t\t}\n\t\t\tvar owner = this.owner;\n\t\t\tif (owner && owner.undo) {\n\t\t\t\towner.undo();\n\t\t\t}\n\t\t\treturn this.changes.length > 0;\n\t\t},\n\t\t/** @ignore */\n\t\tredo: function (view, select) {\n\t\t\tif (this.changes.length > 1 && view) {\n\t\t\t\tview.setRedraw(false);\n\t\t\t}\n\t\t\tfor (var i = 0; i < this.changes.length; i++) {\n\t\t\t\tthis.changes[i].redo(view, false);\n\t\t\t}\n\t\t\tif (select && view) {\n\t\t\t\tview.setSelections(this.endSelection);\n\t\t\t}\n\t\t\tif (this.changes.length > 1, view) {\n\t\t\t\tview.setRedraw(true);\n\t\t\t}\n\t\t\tvar owner = this.owner;\n\t\t\tif (owner && owner.redo) {\n\t\t\t\towner.redo();\n\t\t\t}\n\t\t\treturn this.changes.length > 0;\n\t\t},\n\t\tmerge: function(start, text, previousText, type, end, compoundChange) {\n\t\t\tvar length = this.changes.length;\n\t\t\tif (length > 0 && this === compoundChange) {\n\t\t\t\treturn this.changes[length - 1].merge(start, text, previousText, type, end);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t/** @ignore */\n\t\tstart: function (view) {\n\t\t\tif (view) {\n\t\t\t\tthis.startSelection = view.getSelections();\n\t\t\t}\n\t\t\tvar owner = this.owner;\n\t\t\tif (owner && owner.start) {\n\t\t\t\towner.start();\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Constructs a new UndoStack on a text view.\n\t *\n\t * @param {orion.editor.TextView} view the text view for the undo stack.\n\t * @param {Number} [size=100] the size for the undo stack.\n\t *\n\t * @name orion.editor.UndoStack\n\t * @class The UndoStack is used to record the history of a text model associated to an view. Every\n\t * change to the model is added to stack, allowing the application to undo and redo these changes.\n\t *\n\t * <p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.TextView}<br/>\n\t * </p>\n\t */\n\tfunction UndoStack (view, size) {\n\t\tthis.size = size !== undefined ? size : 100;\n\t\tthis.reset();\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonChanging: function(e) {\n\t\t\t\tself._onChanging(e);\n\t\t\t},\n\t\t\tonDestroy: function(e) {\n\t\t\t\tself._onDestroy(e);\n\t\t\t}\n\t\t};\n\t\tif (view.getModel) {\n\t\t\tvar model = view.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\tthis.model = model;\n\t\t\tthis.setView(view);\n\t\t} else {\n\t\t\tthis.shared = true;\n\t\t\tthis.model = view;\n\t\t}\n\t\tthis.model.addEventListener(\"Changing\", this._listener.onChanging); //$NON-NLS-0$\n\t}\n\tUndoStack.prototype = /** @lends orion.editor.UndoStack.prototype */ {\n\t\t/**\n\t\t * Destroy the undo stack.\n\t\t */\n\t\tdestroy: function() {\n\t\t\tthis._onDestroy();\n\t\t},\n\t\t/**\n\t\t * Adds a change to the stack.\n\t\t * \n\t\t * @param change the change to add.\n\t\t */\n\t\tadd: function (change) {\n\t\t\tif (this.compoundChange) {\n\t\t\t\tthis.compoundChange.add(change);\n\t\t\t} else {\n\t\t\t\tvar length = this.stack.length;\n\t\t\t\tthis.stack.splice(this.index, length-this.index, change);\n\t\t\t\tthis.index++;\n\t\t\t\tif (this.stack.length > this.size) {\n\t\t\t\t\tthis.stack.shift();\n\t\t\t\t\tthis.index--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/** \n\t\t * Marks the current state of the stack as clean.\n\t\t *\n\t\t * <p>\n\t\t * This function is typically called when the content of view associated with the stack is saved.\n\t\t * </p>\n\t\t *\n\t\t * @see orion.editor.UndoStack#isClean\n\t\t */\n\t\tmarkClean: function() {\n\t\t\tthis._commitUndo();\n\t\t\tthis.cleanChange = this.stack[this.index - 1];\n\t\t\tif (this.cleanChange) {\n\t\t\t\tthis.cleanChange.type = 2;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Returns true if current state of stack is the same\n\t\t * as the state when markClean() was called.\n\t\t *\n\t\t * <p>\n\t\t * For example, the application calls markClean(), then calls undo() four times and redo() four times.\n\t\t * At this point isClean() returns true.  \n\t\t * </p>\n\t\t * <p>\n\t\t * This function is typically called to determine if the content of the view associated with the stack\n\t\t * has changed since the last time it was saved.\n\t\t * </p>\n\t\t *\n\t\t * @return {Boolean} returns if the state is the same as the state when markClean() was called.\n\t\t *\n\t\t * @see orion.editor.UndoStack#markClean\n\t\t */\n\t\tisClean: function() {\n\t\t\treturn this.cleanChange === this.stack[this.index - 1];\n\t\t},\n\t\t/**\n\t\t * Returns true if there is at least one change to undo.\n\t\t *\n\t\t * @return {Boolean} returns true if there is at least one change to undo.\n\t\t *\n\t\t * @see orion.editor.UndoStack#canRedo\n\t\t * @see orion.editor.UndoStack#undo\n\t\t */\n\t\tcanUndo: function() {\n\t\t\treturn this.index > 0;\n\t\t},\n\t\t/**\n\t\t * Returns true if there is at least one change to redo.\n\t\t *\n\t\t * @return {Boolean} returns true if there is at least one change to redo.\n\t\t *\n\t\t * @see orion.editor.UndoStack#canUndo\n\t\t * @see orion.editor.UndoStack#redo\n\t\t */\n\t\tcanRedo: function() {\n\t\t\treturn (this.stack.length - this.index) > 0;\n\t\t},\n\t\t/**\n\t\t * Finishes a compound change.\n\t\t *\n\t\t * @see orion.editor.UndoStack#startCompoundChange\n\t\t */\n\t\tendCompoundChange: function() {\n\t\t\tif (this.compoundChange) {\n\t\t\t\tthis.compoundChange.end(this.view);\n\t\t\t}\n\t\t\tthis.compoundChange = undefined;\n\t\t},\n\t\t/**\n\t\t * Returns the sizes of the stack.\n\t\t *\n\t\t * @return {object} a object where object.undo is the number of changes that can be un-done, \n\t\t *  and object.redo is the number of changes that can be re-done.\n\t\t *\n\t\t * @see orion.editor.UndoStack#canUndo\n\t\t * @see orion.editor.UndoStack#canRedo\n\t\t */\n\t\tgetSize: function() {\n\t\t\treturn {\n\t\t\t\tundo: this.index,\n\t\t\t\tredo: this.stack.length - this.index\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * @class This object represents a text change.\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.UndoStack}<br/>\n\t\t * {@link orion.editor.UndoStack#getUndoChanges}<br/>\n\t\t * {@link orion.editor.UndoStack#getRedoChanges}<br/>\n\t\t * </p>\n\t\t * @name orion.editor.TextChange\n\t\t * \n\t\t * @property {Number} start The start offset in the model of the range to be replaced.\n\t\t * @property {Number} end The end offset in the model of the range to be replaced\n\t\t * @property {String} text the text to be inserted\n\t\t */\n\t\t/**\n\t\t * Returns the redo changes.\n\t\t *\n\t\t * @return {orion.editor.TextChange[]} an array of TextChanges that are returned in the order\n\t\t * that they occurred (most recent change last).\n\t\t *\n\t\t * @see orion.editor.UndoStack#getUndoChanges\n\t\t */\n\t\tgetRedoChanges: function() {\n\t\t\tthis._commitUndo();\n\t\t\tvar changes = [];\n\t\t\tfor (var i=this.index; i<this.stack.length; i++) {\n\t\t\t\tchanges = changes.concat(this.stack[i].getRedoChanges());\n\t\t\t}\n\t\t\treturn changes;\n\t\t},\n\t\t/**\n\t\t * Returns the undo changes.\n\t\t *\n\t\t * @return {orion.editor.TextChange[]} an array of TextChanges that are returned in the reverse order\n\t\t * that they occurred (most recent change first).\n\t\t *\n\t\t * @see orion.editor.UndoStack#getRedoChanges\n\t\t */\n\t\tgetUndoChanges: function() {\n\t\t\tthis._commitUndo();\n\t\t\tvar changes = [];\n\t\t\tfor (var i=this.index; i >= 0; i--) {\n\t\t\t\tchanges = changes.concat(this.stack[i].getUndoChanges());\n\t\t\t}\n\t\t\treturn changes;\n\t\t},\n\t\t/**\n\t\t * Undo the last change in the stack.\n\t\t *\n\t\t * @return {Boolean} returns true if a change was un-done.\n\t\t *\n\t\t * @see orion.editor.UndoStack#redo\n\t\t * @see orion.editor.UndoStack#canUndo\n\t\t */\n\t\tundo: function() {\n\t\t\tthis._commitUndo();\n\t\t\tvar change, result = false;\n\t\t\tthis._ignoreUndo = true;\n\t\t\tdo {\n\t\t\t\tif (this.index <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchange = this.stack[--this.index];\n\t\t\t} while (!(result = change.undo(this.view, true)));\n\t\t\tthis._ignoreUndo = false;\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * Redo the last change in the stack.\n\t\t *\n\t\t * @return {Boolean} returns true if a change was re-done.\n\t\t *\n\t\t * @see orion.editor.UndoStack#undo\n\t\t * @see orion.editor.UndoStack#canRedo\n\t\t */\n\t\tredo: function() {\n\t\t\tthis._commitUndo();\n\t\t\tvar change, result = false;\n\t\t\tthis._ignoreUndo = true;\n\t\t\tdo {\n\t\t\t\tif (this.index >= this.stack.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchange = this.stack[this.index++];\n\t\t\t} while (!(result = change.redo(this.view, true)));\n\t\t\tthis._ignoreUndo = false;\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * Reset the stack to its original state. All changes in the stack are thrown away.\n\t\t */\n\t\treset: function() {\n\t\t\tthis.index = 0;\n\t\t\tthis.cleanChange = undefined;\n\t\t\tthis.stack = [];\n\t\t\tthis._ignoreUndo = false;\n\t\t\tthis._compoundChange = undefined;\n\t\t},\n\t\tsetView: function(view) {\n\t\t\tif (this.view === view) { return; }\n\t\t\tif (this.view) {\n\t\t\t\tview.removeEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis.view = view;\n\t\t\tif (this.view) {\n\t\t\t\tview.addEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Starts a compound change. \n\t\t * <p>\n\t\t * All changes added to stack from the time startCompoundChange() is called\n\t\t * to the time that endCompoundChange() is called are compound on one change that can be un-done or re-done\n\t\t * with one single call to undo() or redo().\n\t\t * </p>\n\t\t *\n\t\t * @param owner the owner of the compound change which is called for start, end, undo and redo.\n\t\t *\t\t \n\t\t * @return the compound change\n\t\t *\n\t\t * @see orion.editor.UndoStack#endCompoundChange\n\t\t */\n\t\tstartCompoundChange: function(owner) {\n\t\t\tthis._commitUndo();\n\t\t\tvar change = new CompoundChange(owner);\n\t\t\tthis.add(change);\n\t\t\tthis.compoundChange = change;\n\t\t\tthis.compoundChange.start(this.view);\n\t\t\treturn this.compoundChange;\n\t\t},\n\t\t_commitUndo: function () {\n\t\t\tthis.endCompoundChange();\n\t\t},\n\t\t_onDestroy: function(evt) {\n\t\t\tif (!evt /* undo stack destroyed */ || !this.shared) {\n\t\t\t\tthis.model.removeEventListener(\"Changing\", this._listener.onChanging); //$NON-NLS-0$\n\t\t\t}\n\t\t\tif (this.view) {\n\t\t\t\tthis.view.removeEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\t\t\tthis.view = null;\n\t\t\t}\n\t\t},\n\t\t_trackUnsavedChanges: function(e) {\n\t\t\tif (!this._unsavedChanges) return;\n\t\t\tvar length = this._unsavedChanges.length;\n\t\t\tvar addedCharCount = e.addedCharCount;\n\t\t\tvar removedCharCount = e.removedCharCount;\n\t\t\tvar start = e.start;\n\t\t\tvar end = e.start + removedCharCount;\n\t\t\tvar type = 0;\n\t\t\tif (addedCharCount === 0) {\n\t\t\t\ttype = -1;\n\t\t\t} else if (removedCharCount === 0) {\n\t\t\t\ttype = 1;\n\t\t\t}\n\t\t\tif (length > 0) {\n\t\t\t\tif (type === this._previousChangeType) {\n\t\t\t\t\tvar previousChange = this._unsavedChanges[length-1];\n\t\t\t\t\tif (removedCharCount === 0 && start === previousChange.end + previousChange.text.length) {\n\t\t\t\t\t\tpreviousChange.text += e.text;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.addedCharCount === 0 && end === previousChange.start) {\n\t\t\t\t\t\tpreviousChange.start = start;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._previousChangeType = type;\n\t\t\tthis._unsavedChanges.push({start:start, end:end, text:e.text});\n\t\t},\n\t\t_onChanging: function(e) {\n\t\t\tthis._trackUnsavedChanges(e);\n\t\t\tif (this._ignoreUndo) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar text = e.text;\n\t\t\tvar start = e.start;\n\t\t\tvar addedCharCount = e.addedCharCount;\n\t\t\tvar removedCharCount = e.removedCharCount;\n\t\t\tvar end = start + removedCharCount;\n\t\t\tvar type = 0;\n\t\t\tif (addedCharCount === 0 && removedCharCount === 1) {\n\t\t\t\ttype = -1;\n\t\t\t} else if (addedCharCount === 1 && removedCharCount === 0) {\n\t\t\t\ttype = 1;\n\t\t\t}\n\t\t\tvar length = this.stack.length;\n\t\t\tvar previousText = this.model.getText(start, end);\n\t\t\tif (length > 0 && this.index === length) {\n\t\t\t\tvar change = this.stack[length - 1];\n\t\t\t\tif (change.merge(start, text, previousText, type, end, this.compoundChange)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.add(new Change(this.model, start, text, previousText, type));\n\t\t}\n\t};\n\t\n\treturn {\n\t\tUndoStack: UndoStack\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: IBM Corporation - initial API and implementation\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/rulers\", [\n\t'i18n!orion/editor/nls/messages',\n\t'orion/editor/textView',\n\t'orion/editor/annotations',\n\t'orion/editor/tooltip', \n\t'orion/objects',\n\t'orion/editor/util',\n\t'orion/util'\n], function(messages, mTextView, mAnnotations, mTooltip, objects, textUtil, util) {\n\n\tfunction BaseRuler (rulerLocation, rulerOverview, rulerStyle) {\n\t\tthis._location = rulerLocation || \"left\"; //$NON-NLS-0$\n\t\tthis._overview = rulerOverview || \"page\"; //$NON-NLS-0$\n\t\tthis._rulerStyle = rulerStyle;\n\t\tthis._view = null;\n\t}\n\tBaseRuler.prototype = /** @lends orion.editor.BaseRuler.prototype */ {\n\t\t/**\n\t\t * Returns the ruler location.\n\t\t *\n\t\t * @returns {String} the ruler location, which is either \"left\" or \"right\" or \"margin\".\n\t\t *\n\t\t * @see orion.editor.Ruler#getOverview\n\t\t */\n\t\tgetLocation: function() {\n\t\t\treturn this._location;\n\t\t},\n\t\t/**\n\t\t * Returns the ruler overview type.\n\t\t *\n\t\t * @returns {String} the overview type, which is either \"page\" or \"document\" or \"fixed\".\n\t\t *\n\t\t * @see orion.editor.Ruler#getLocation\n\t\t */\n\t\tgetOverview: function() {\n\t\t\treturn this._overview;\n\t\t},\n\t\t/**\n\t\t * Returns the style information for the ruler.\n\t\t *\n\t\t * @returns {orion.editor.Style} the style information.\n\t\t */\n\t\tgetRulerStyle: function() {\n\t\t\treturn this._rulerStyle;\n\t\t},\n\t\t/**\n\t\t * Returns the text view.\n\t\t *\n\t\t * @returns {orion.editor.TextView} the text view.\n\t\t *\n\t\t * @see orion.editor.Ruler#setView\n\t\t */\n\t\tgetView: function() {\n\t\t\treturn this._view;\n\t\t},\n\t\t/**\n\t\t * Sets the view for the ruler.\n\t\t * <p>\n\t\t * This method is called by the text view when the ruler\n\t\t * is added to the view.\n\t\t * </p>\n\t\t *\n\t\t * @param {orion.editor.TextView} view the text view.\n\t\t */\n\t\tsetView: function (view) {\n\t\t\tif (this._onTextModelChanged && this._view) {\n\t\t\t\tthis._view.removeEventListener(\"ModelChanged\", this._listener.onTextModelChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._view = view;\n\t\t\tif (this._onTextModelChanged && this._view) {\n\t\t\t\tthis._view.addEventListener(\"ModelChanged\", this._listener.onTextModelChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t};\n\n\t/**\n\t * Constructs a new ruler. \n\t * <p>\n\t * The default implementation does not implement all the methods in the interface\n\t * and is useful only for objects implementing rulers.\n\t * <p/>\n\t * \n\t * @param {orion.editor.AnnotationModel} annotationModel the annotation model for the ruler.\n\t * @param {String} [rulerLocation=\"left\"] the location for the ruler.\n\t * @param {String} [rulerOverview=\"page\"] the overview for the ruler.\n\t * @param {orion.editor.Style} [rulerStyle] the style for the ruler. \n\t * \n\t * @class This interface represents a ruler for the text view.\n\t * <p>\n\t * A Ruler is a graphical element that is placed either on the left or on the right side of \n\t * the view. It can be used to provide the view with per line decoration such as line numbering,\n\t * bookmarks, breakpoints, folding disclosures, etc. \n\t * </p><p>\n\t * There are two types of rulers: page and document. A page ruler only shows the content for the lines that are\n\t * visible, while a document ruler always shows the whole content.\n\t * </p>\n\t * <b>See:</b><br/>\n\t * {@link orion.editor.LineNumberRuler}<br/>\n\t * {@link orion.editor.AnnotationRuler}<br/>\n\t * {@link orion.editor.OverviewRuler}<br/> \n\t * {@link orion.editor.TextView}<br/>\n\t * {@link orion.editor.TextView#addRuler}\n\t * </p>\t\t \n\t * @name orion.editor.Ruler\n\t * @borrows orion.editor.AnnotationTypeList#addAnnotationType as #addAnnotationType\n\t * @borrows orion.editor.AnnotationTypeList#getAnnotationTypePriority as #getAnnotationTypePriority\n\t * @borrows orion.editor.AnnotationTypeList#getAnnotationsByType as #getAnnotationsByType\n\t * @borrows orion.editor.AnnotationTypeList#isAnnotationTypeVisible as #isAnnotationTypeVisible\n\t * @borrows orion.editor.AnnotationTypeList#removeAnnotationType as #removeAnnotationType\n\t */\n\tfunction Ruler (annotationModel, rulerLocation, rulerOverview, rulerStyle) {\n\t\tBaseRuler.call(this, rulerLocation, rulerOverview, rulerStyle);\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonTextModelChanged: function(e) {\n\t\t\t\tself._onTextModelChanged(e);\n\t\t\t},\n\t\t\tonAnnotationModelChanged: function(e) {\n\t\t\t\tself._onAnnotationModelChanged(e);\n\t\t\t}\n\t\t};\n\t\tthis.setAnnotationModel(annotationModel);\n\t}\n\tRuler.prototype = objects.mixin(new BaseRuler(), /** @lends orion.editor.Ruler.prototype */ {\n\t\t/**\n\t\t * Returns the annotations for a given line range merging multiple\n\t\t * annotations when necessary.\n\t\t * <p>\n\t\t * This method is called by the text view when the ruler is redrawn.\n\t\t * </p>\n\t\t *\n\t\t * @param {Number} startLine the start line index\n\t\t * @param {Number} endLine the end line index\n\t\t * @return {orion.editor.Annotation[]} the annotations for the line range. The array might be sparse.\n\t\t */\n\t\tgetAnnotations: function(startLine, endLine) {\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tif (!annotationModel) { return []; }\n\t\t\tvar model = this._view.getModel();\n\t\t\tvar start = model.getLineStart(startLine);\n\t\t\tvar end = model.getLineEnd(endLine - 1);\n\t\t\tvar baseModel = model;\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tbaseModel = model.getBaseModel();\n\t\t\t\tstart = model.mapOffset(start);\n\t\t\t\tend = model.mapOffset(end);\n\t\t\t}\n\t\t\tvar result = [];\n\t\t\tvar annotations = this.getAnnotationsByType(annotationModel, start, end);\n\t\t\tfor (var i = 0; i < annotations.length; i++) {\n\t\t\t\tvar annotation = annotations[i];\n\t\t\t\tvar annotationLineStart = baseModel.getLineAtOffset(annotation.start);\n\t\t\t\tvar annotationLineEnd = baseModel.getLineAtOffset(Math.max(annotation.start, annotation.end - 1));\n\t\t\t\tfor (var lineIndex = annotationLineStart; lineIndex<=annotationLineEnd; lineIndex++) {\n\t\t\t\t\tvar visualLineIndex = lineIndex;\n\t\t\t\t\tif (model !== baseModel) {\n\t\t\t\t\t\tvar ls = baseModel.getLineStart(lineIndex);\n\t\t\t\t\t\tls = model.mapOffset(ls, true);\n\t\t\t\t\t\tif (ls === -1) { continue; }\n\t\t\t\t\t\tvisualLineIndex = model.getLineAtOffset(ls);\n\t\t\t\t\t}\n\t\t\t\t\tif (!(startLine <= visualLineIndex && visualLineIndex < endLine)) { continue; }\n\t\t\t\t\tvar rulerAnnotation = this._mergeAnnotation(result[visualLineIndex], annotation, lineIndex - annotationLineStart, annotationLineEnd - annotationLineStart + 1);\n\t\t\t\t\tif (rulerAnnotation) {\n\t\t\t\t\t\tresult[visualLineIndex] = rulerAnnotation;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!this._multiAnnotation && this._multiAnnotationOverlay) {\n\t\t\t\tfor (var k in result) {\n\t\t\t\t\tif (result[k]._multiple) {\n\t\t\t\t\t\tresult[k].html = result[k].html + this._multiAnnotationOverlay.html;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * Returns the annotation model.\n\t\t *\n\t\t * @returns {orion.editor.AnnotationModel} the ruler annotation model.\n\t\t *\n\t\t * @see orion.editor.Ruler#setAnnotationModel\n\t\t */\n\t\tgetAnnotationModel: function() {\n\t\t\treturn this._annotationModel;\n\t\t},\n\t\t/**\n\t\t * Returns the widest annotation which determines the width of the ruler.\n\t\t * <p>\n\t\t * If the ruler does not have a fixed width it should provide the widest\n\t\t * annotation to avoid the ruler from changing size as the view scrolls.\n\t\t * </p>\n\t\t * <p>\n\t\t * This method is called by the text view when the ruler is redrawn.\n\t\t * </p>\n\t\t *\n\t\t * @returns {orion.editor.Annotation} the widest annotation.\n\t\t *\n\t\t * @see orion.editor.Ruler#getAnnotations\n\t\t */\n\t\tgetWidestAnnotation: function() {\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Sets the annotation model for the ruler.\n\t\t *\n\t\t * @param {orion.editor.AnnotationModel} annotationModel the annotation model.\n\t\t *\n\t\t * @see orion.editor.Ruler#getAnnotationModel\n\t\t */\n\t\tsetAnnotationModel: function (annotationModel) {\n\t\t\tif (this._annotationModel) {\n\t\t\t\tthis._annotationModel.removEventListener(\"Changed\", this._listener.onAnnotationModelChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t\tthis._annotationModel = annotationModel;\n\t\t\tif (this._annotationModel) {\n\t\t\t\tthis._annotationModel.addEventListener(\"Changed\", this._listener.onAnnotationModelChanged); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets the annotation that is displayed when a given line contains multiple\n\t\t * annotations.  This annotation is used when there are different types of\n\t\t * annotations in a given line.\n\t\t *\n\t\t * @param {orion.editor.Annotation} annotation the annotation for lines with multiple annotations.\n\t\t * \n\t\t * @see orion.editor.Ruler#setMultiAnnotationOverlay\n\t\t */\n\t\tsetMultiAnnotation: function(annotation) {\n\t\t\tthis._multiAnnotation = annotation;\n\t\t},\n\t\t/**\n\t\t * Sets the annotation that overlays a line with multiple annotations.  This annotation is displayed on\n\t\t * top of the computed annotation for a given line when there are multiple annotations of the same type\n\t\t * in the line. It is also used when the multiple annotation is not set.\n\t\t *\n\t\t * @param {orion.editor.Annotation} annotation the annotation overlay for lines with multiple annotations.\n\t\t * \n\t\t * @see orion.editor.Ruler#setMultiAnnotation\n\t\t */\n\t\tsetMultiAnnotationOverlay: function(annotation) {\n\t\t\tthis._multiAnnotationOverlay = annotation;\n\t\t},\n\t\t/**\n\t\t * This event is sent when the user clicks a line annotation. We select an annotation on the line using\n\t\t * the following logic:\n\t\t * 1) If no selection or selection is on another line, select the first annotation\n\t\t * 2) If an annotation is selected, select the next annotation in the model\n\t\t * 3) If there is a selection that does not match an annotation, select the first annotation after the selection start\n\t\t *\n\t\t * @event\n\t\t * @param {Number} lineIndex the line index of the annotation under the pointer.\n\t\t * @param {DOMEvent} e the click event.\n\t\t */\n\t\tonClick: function(lineIndex, e) {\n\t\t\tif (lineIndex === undefined) { return; }\n\t\t\tvar view = this._view;\n\t\t\t\n\t\t\tvar model = view.getModel();\n\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\tvar lineEnd = model.getLineEnd(lineIndex, true);\n\t\t\tvar selectionStart = view.getSelection().start;\n\t\t\tvar selectionEnd = view.getSelection().end;\n\t\t\t\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tvar annotation, start, end;\n\t\t\tif (annotationModel){\n\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tlineStart = model.mapOffset(lineStart);\n\t\t\t\t\tlineEnd = model.mapOffset(lineEnd);\n\t\t\t\t\tselectionStart = model.mapOffset(selectionStart);\n\t\t\t\t\tselectionEnd = model.mapOffset(selectionEnd);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar self = this;\n\t\t\t\tannotation = this._findNextAnnotation(annotationModel, lineStart, lineEnd, selectionStart, selectionEnd, \n\t\t\t\t\tfunction(annotationType){\n\t\t\t\t\t\treturn self.isAnnotationTypeVisible(annotationType);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t// Select the annotation or the start of the line\n\t\t\t\tstart = annotation ? annotation.start : lineStart;\n\t\t\t\tend = annotation ? annotation.end : lineStart;\n\t\t\t\t\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\t\tend = model.mapOffset(end, true);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// TODO What does this code do\n\t\t\t\tif (annotation && annotation.groupId !== undefined) {\n\t\t\t\t\tif (this._currentClickGroup === annotation.groupId) {\n\t\t\t\t\t\tthis._currentClickGroup = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._currentClickGroup = annotation.groupId;\n\t\t\t\t\t}\n\t\t\t\t\tthis._setCurrentGroup(lineIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Set the selection before opening the tooltip otherwise the tooltip will be closed immediately\n\t\t\tthis._view.setSelection(end, start, 1/3, function(){});\n\t\t\t\n\t\t\t// Open the tooltip for the selected annotation in the same location as the multi-annotation ruler tooltip.\n\t\t\tvar tooltip = mTooltip.Tooltip.getTooltip(this._view);\n\t\t\tif (tooltip) {\n\t\t\t\tif (annotation && this.getLocation() === \"left\"){ //$NON-NLS-0$\n\t\t\t\t\ttooltip.show({getTooltipInfo: function() {\n\t\t\t\t\t\t\treturn self._getTooltipInfo([annotation]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, false, false);\n\t\t\t\t} else {\n\t\t\t\t\ttooltip.hide();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * This event is sent when the user double clicks a line annotation.\n\t\t *\n\t\t * @event\n\t\t * @param {Number} lineIndex the line index of the annotation under the pointer.\n\t\t * @param {DOMEvent} e the double click event.\n\t\t * @callback\n\t\t */\n\t\tonDblClick: function(lineIndex, e) {\n\t\t},\n\t\t/**\n\t\t * This event is sent when the user moves the mouse over a line annotation.\n\t\t *\n\t\t * @event\n\t\t * @param {Number} lineIndex the line index of the annotation under the pointer.\n\t\t * @param {DOMEvent} e the mouse move event.\n\t\t */\n\t\tonMouseMove: function(lineIndex, e) {\n\t\t\tvar tooltip = mTooltip.Tooltip.getTooltip(this._view);\n\t\t\tif (!tooltip) { return; }\n\t\t\tif (tooltip.isVisible() && this._tooltipLineIndex === lineIndex) { return; }\n\t\t\tthis._tooltipLineIndex = lineIndex;\n\t\t\t\n\t\t\t// Prevent spurious mouse event (e.g. on a scroll)\t\t\t\t\t\n\t\t\tif (e.clientX === this._lastMouseX\n\t\t\t\t&& e.clientY === this._lastMouseY) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis._lastMouseX = e.clientX;\n\t\t\tthis._lastMouseY = e.clientY;\n\n\t\t\tif (this._hoverTimeout) {\n\t\t\t\twindow.clearTimeout(this._hoverTimeout);\n\t\t\t\tthis._hoverTimeout = null;\n\t\t\t}\n\t\t\t\n\t\t\tvar target = e.target ? e.target : e.srcElement;\n\t\t\tthis._curElementBounds = target.getBoundingClientRect();\n\t\t\t// If we have the entire ruler selected, just use a 1 pixel high area in the ruler (Bug 463486)\n\t\t\tif (target._ruler){\n\t\t\t\tthis._curElementBounds.top = e.clientY;\n\t\t\t\tthis._curElementBounds.height = 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar self = this;\n\t\t\tself._hoverTimeout = window.setTimeout(function() {\n\t\t\t\tself._hoverTimeout = null;\n\t\t\t\ttooltip.onHover({\n\t\t\t\t\tgetTooltipInfo: function() {\n\t\t\t\t\t\tvar annotations = self._getAnnotationsAtLineIndex(self._tooltipLineIndex);\n\t\t\t\t\t\tvar content = self._getTooltipContents(self._tooltipLineIndex, annotations);\n\t\t\t\t\t\treturn self._getTooltipInfo(content, e.clientY, {source: \"ruler\", rulerLocation: self.getLocation()}); //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t}, e.clientX, e.clientY);\n\t\t\t}, 175);\n\t\t},\n\t\t/**\n\t\t * This event is sent when the mouse pointer enters a line annotation.\n\t\t *\n\t\t * @event\n\t\t * @param {Number} lineIndex the line index of the annotation under the pointer.\n\t\t * @param {DOMEvent} e the mouse over event.\n\t\t */\n\t\tonMouseOver: function(lineIndex, e) {\n\t\t\tthis.onMouseMove(lineIndex, e);\n\t\t\tif (!this._currentClickGroup) {\n\t\t\t\tthis._setCurrentGroup(lineIndex);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * This event is sent when the mouse pointer exits a line annotation.\n\t\t *\n\t\t * @event\n\t\t * @param {Number} lineIndex the line index of the annotation under the pointer.\n\t\t * @param {DOMEvent} e the mouse out event.\n\t\t * @callback\n\t\t */\n\t\tonMouseOut: function(lineIndex, e) {\n\t\t\tif (!this._currentClickGroup) {\n\t\t\t\tthis._setCurrentGroup(-1);\n\t\t\t}\n\n\t\t\tif (this._hoverTimeout) {\n\t\t\t\twindow.clearTimeout(this._hoverTimeout);\n\t\t\t\tthis._hoverTimeout = null;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @name _findNextAnnotation\n\t\t * @description Looks at all annotations in the given range and attempt to find the next valid\n\t\t * \t\t\t\tannotation after the current selection.\n\t\t * @function\n\t\t * @private\n\t\t * @param annotationModel The annotation model to lookup annotations in\n\t\t * @param rangeStart The start range to search for annotations (required)\n\t\t * @param rangeEnd The end range to search for annotations (required)\n\t\t * @param selectionStart The start of the current selection (optional)\n\t\t * @param selectionEnd The end of the current selection (optional)\n\t\t * @param isAnnotationTypeVisible A function callback to check if a given annotation type is valid or visible (optional)\n\t\t * @returns The next annotation in the list or <code>null</code>\n\t\t */\n\t\t_findNextAnnotation: function(annotationModel, rangeStart, rangeEnd, selectionStart, selectionEnd, isAnnotationTypeVisible){\n\t\t\tvar annotation = null;\n\t\t\tvar selectedAnnotation;\n\t\t\tvar searchStart = rangeStart;\n\t\t\t\n\t\t\tif (selectionStart >= 0 && selectionEnd >= 0){\n\t\t\t\tif (selectionStart >= rangeStart && selectionStart < rangeEnd){\n\t\t\t\t\tsearchStart = selectionStart;\n\t\t\t\t\tvar selectedAnnotations = annotationModel.getAnnotations(selectionStart, selectionEnd);\n\t\t\t\t\twhile (!selectedAnnotation && selectedAnnotations.hasNext()){\n\t\t\t\t\t\tvar current = selectedAnnotations.next();\n\t\t\t\t\t\tif (isAnnotationTypeVisible && !isAnnotationTypeVisible(current.type)) { continue; }\n\t\t\t\t\t\tif (current.start === selectionStart && current.end === selectionEnd){\n\t\t\t\t\t\t\tselectedAnnotation = current;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar iter = annotationModel.getAnnotations(searchStart, rangeEnd);\n\t\t\tvar useNextValid;\n\t\t\twhile (iter.hasNext()){\n\t\t\t\tcurrent = iter.next();\n\t\t\t\tif (isAnnotationTypeVisible && !isAnnotationTypeVisible(current.type)) { continue; }\n\t\t\t\t// Default to first visible annotation\n\t\t\t\tif (!annotation){\n\t\t\t\t\tannotation = current;\n\t\t\t\t}\n\t\t\t\t// If no selected annotation, use the first in the list\n\t\t\t\tif (!selectedAnnotation){\n\t\t\t\t\tannotation = current;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// If the selected annotation was found, use the next annotation\n\t\t\t\t// NOTE: If two annotations have the same range, we skip to the next annotation so don't flip between them\n\t\t\t\tif (useNextValid && (selectedAnnotation.start !== current.start || selectedAnnotation.end !== current.end)){\n\t\t\t\t\tuseNextValid = false;\n\t\t\t\t\tannotation = current;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Found the selected annotation, use the next in the list\n\t\t\t\tif (selectedAnnotation && selectedAnnotation === current){\n\t\t\t\t\tuseNextValid = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useNextValid){\n\t\t\t\tannotation = null; // Last annotation on the line was selected, go to line start\n\t\t\t}\n\t\t\t\n\t\t\treturn annotation;\n\t\t},\n\t\t\n\t\t_getAnnotationsAtLineIndex: function _getAnnotationsAtLineIndex(lineIndex){\n\t\t\tif (lineIndex === undefined) { return; }\n\t\t\tvar view = this._view;\n\t\t\tvar model = view.getModel();\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tvar annotations = [];\n\t\t\tif (annotationModel) {\n\t\t\t\tvar start = model.getLineStart(lineIndex);\n\t\t\t\tvar end = model.getLineEnd(lineIndex);\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tstart = model.mapOffset(start);\n\t\t\t\t\tend = model.mapOffset(end);\n\t\t\t\t}\n\t\t\t\tannotations = this.getAnnotationsByType(annotationModel, start, end);\n\t\t\t}\n\t\t\treturn annotations;\n\t\t},\n\t\t/** @ignore */\n\t\t_getTooltipInfo: function(contents, y, context) {\n\t\t\tif (!contents) { return null; } // TODO: shouldn't this check the length, it'll never be null\n\t\t\n\t\t\tvar hoverArea = Object.create(null);\n\t\t\thoverArea.top = this._curElementBounds.top;\n\t\t\thoverArea.left = this._curElementBounds.left;\n\t\t\thoverArea.height = this._curElementBounds.height;\n\t\t\thoverArea.width = this._curElementBounds.width;\n\t\t\tif (typeof contents === 'string' && y) { //$NON-NLS-0$\n\t\t\t\t// Hack for line numbers\n\t\t\t\thoverArea.top = y;\n\t\t\t\thoverArea.height = 1;\n\t\t\t}\n\t\t\t\n\t\t\tvar rulerLocation = this.getLocation();\n\t\t\tvar rulerStyle = this.getRulerStyle();\n\t\t\t// The tooltip is positioned opposite to where the ruler is\n\t\t\tvar position = rulerLocation === \"left\" ? \"right\" : \"left\"; //$NON-NLS-0$ //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\n\t\t\t\n\t\t\tvar viewRect = this._view._clientDiv.getBoundingClientRect();\n\t\t\tvar offsetX = 0;\n\t\t\tvar offsetY = 0;\n\t\t\toffsetX = viewRect.left - (hoverArea.left + hoverArea.width);\n\t\t\toffsetY = hoverArea.height;\n\t\t\tif (position === \"left\") { //$NON-NLS-0$\n\t\t\t\toffsetX = -25;\n\t\t\t\t// Hack for when the hoverArea is a sliver of the ruler, ruler is 2px wider than annotations\n\t\t\t\tif (hoverArea.height === 1){\n\t\t\t\t\toffsetX += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Adjust the tooltip for folding comments to exactly cover the unfolded text location\n\t\t\tif (rulerStyle.styleClass.indexOf(\"folding\") >= 0){ //$NON-NLS-0$\n\t\t\t\toffsetY -= 14;\n\t\t\t}\n\t\t\t\n\t\t\tvar info = {\n\t\t\t\tcontents: contents,\n\t\t\t\tposition: position,\n\t\t\t\ttooltipOffsetX: offsetX,\n\t\t\t\ttooltipOffsetY: offsetY,\n\t\t\t\tanchorArea: hoverArea,\n\t\t\t\tcontext: context\n\t\t\t};\n\t\t\treturn info;\n\t\t},\n\t\t/**\n\t\t * @name _getTooltipContents\n\t\t * @description Overridden by different rulers to provide customer tooltip content\n\t\t * @function\n\t\t * @private\n\t\t * @param lineIndex\n\t\t * @param annotations\n\t\t * @returns returns\n\t\t * @callback\n\t\t */\n\t\t_getTooltipContents: function _getTooltipContents(lineIndex, annotations){\n\t\t\treturn annotations;\n\t\t},\n\t\t\n\t\t_getOnClickTooltipInfo: function(annotation) {\n\t\t\tvar view = this._view;\n\t\t\tvar hoverArea = Object.create(null);\n\t\t\thoverArea.top = this._curElementBounds.top;\n\t\t\thoverArea.left = this._curElementBounds.left;\n\t\t\thoverArea.height = this._curElementBounds.height;\n\t\t\thoverArea.width = this._curElementBounds.width;\n\t\t\tvar rulerLocation = this.getLocation();\n\t\t\tvar position = rulerLocation === \"left\" ? \"right\" : \"left\"; //$NON-NLS-0$ //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tvar info = {\n\t\t\t\tcontents: [annotation],\n\t\t\t\tposition: position,\n\t\t\t\tanchorArea: hoverArea\n\t\t\t};\n\t\t\t\n\t\t\tvar viewRect = view._clientDiv.getBoundingClientRect();\n\n\t\t\tinfo.offsetX = viewRect.left - (hoverArea.left + hoverArea.width);\n\t\t\tinfo.offsetY = hoverArea.height;\n\t\t\tif (info.position === \"left\") { //$NON-NLS-0$\n\t\t\t\tinfo.offsetX = 20;\n\t\t\t}\n\t\t\treturn info;\n\t\t},\n\t\t/** @ignore */\n\t\t_onAnnotationModelChanged: function(e) {\n\t\t\tvar view = this._view;\n\t\t\tif (!view) { return; }\n\t\t\tvar model = view.getModel(), self = this;\n\t\t\tvar lineCount = model.getLineCount();\n\t\t\tif (e.textModelChangedEvent) {\n\t\t\t\tvar start = e.textModelChangedEvent.start;\n\t\t\t\tif (model.getBaseModel) { start = model.mapOffset(start, true); }\n\t\t\t\tvar startLine = model.getLineAtOffset(start);\n\t\t\t\tview.redrawLines(startLine, lineCount, self);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfunction redraw(changes) {\n\t\t\t\tfor (var i = 0; i < changes.length; i++) {\n\t\t\t\t\tif (!self.isAnnotationTypeVisible(changes[i].type)) { continue; }\n\t\t\t\t\tstart = changes[i].start;\n\t\t\t\t\tvar end = changes[i].end;\n\t\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\t\t\tend = model.mapOffset(end, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (start !== -1 && end !== -1) {\n\t\t\t\t\t\tview.redrawLines(model.getLineAtOffset(start), model.getLineAtOffset(Math.max(start, end - 1)) + 1, self);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tredraw(e.added);\n\t\t\tredraw(e.removed);\n\t\t\tredraw(e.changed);\n\t\t},\n\t\t/** @ignore */\n\t\t_mergeAnnotation: function(result, annotation, annotationLineIndex, annotationLineCount) {\n\t\t\tif (!result) { result = {}; }\n\t\t\tif (annotationLineIndex === 0) {\n\t\t\t\tif (result.html && annotation.html) {\n\t\t\t\t\tif (annotation.html !== result.html) {\n\t\t\t\t\t\tif (!result._multiple && this._multiAnnotation) {\n\t\t\t\t\t\t\tresult.html = this._multiAnnotation.html;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\tresult._multiple = true;\n\t\t\t\t} else {\n\t\t\t\t\tresult.html = annotation.html;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.style = this._mergeStyle(result.style, annotation.style);\n\t\t\treturn result;\n\t\t},\n\t\t/** @ignore */\n\t\t_mergeStyle: function(result, style) {\n\t\t\tif (style) {\n\t\t\t\tif (!result) { result = {}; }\n\t\t\t\tif (result.styleClass && style.styleClass && result.styleClass !== style.styleClass) {\n\t\t\t\t\tresult.styleClass += \" \" + style.styleClass; //$NON-NLS-0$\n\t\t\t\t} else {\n\t\t\t\t\tresult.styleClass = style.styleClass;\n\t\t\t\t}\n\t\t\t\tvar prop;\n\t\t\t\tif (style.style) {\n\t\t\t\t\tif (!result.style) { result.style  = {}; }\n\t\t\t\t\tfor (prop in style.style) {\n\t\t\t\t\t\tif (result.style[prop] === undefined) {\n\t\t\t\t\t\t\tresult.style[prop] = style.style[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (style.attributes) {\n\t\t\t\t\tif (!result.attributes) { result.attributes  = {}; }\n\t\t\t\t\tfor (prop in style.attributes) {\n\t\t\t\t\t\tif (result.attributes[prop] === undefined) {\n\t\t\t\t\t\t\tresult.attributes[prop] = style.attributes[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t_setCurrentGroup: function(lineIndex) {\n\t\t\tvar annotationModel = this._annotationModel;\n\t\t\tvar groupAnnotation = null;\n\t\t\tvar model = annotationModel.getTextModel();\n\t\t\tvar annotation;\n\t\t\tvar annotations;\n\t\t\tvar currentGroupAnnotation = this._currentGroupAnnotation;\n\t\t\tif (lineIndex !== -1) {\n\t\t\t\tvar start = model.getLineStart(lineIndex);\n\t\t\t\tvar end = model.getLineEnd(lineIndex);\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tstart = model.mapOffset(start);\n\t\t\t\t\tend = model.mapOffset(end);\n\t\t\t\t}\n\t\t\t\tannotations = annotationModel.getAnnotations(start, end);\n\t\t\t\twhile(annotations.hasNext()){\n\t\t\t\t\tannotation = annotations.next();\n\t\t\t\t\tif (!this.isAnnotationTypeVisible(annotation.type)) { continue; }\n\t\t\t\t\tif (annotation.start <= start && annotation.end >= end){\n\t\t\t\t\t\tif (annotation.groupId !== undefined) {\n\t\t\t\t\t\t\tgroupAnnotation = annotation;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentGroupAnnotation && groupAnnotation) {\n\t\t\t\t\tif (currentGroupAnnotation.groupId === groupAnnotation.groupId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._currentGroupAnnotation = null;\n\t\t\tif (currentGroupAnnotation) {\n\t\t\t\tannotationModel.removeAnnotations(currentGroupAnnotation.groupType);\n\t\t\t}\n\t\t\tif (!groupAnnotation) { return; }\n\t\t\t\n\t\t\tif (lineIndex === -1) { return; }\n\t\t\tthis._currentGroupAnnotation = groupAnnotation;\n\t\t\tannotations = annotationModel.getAnnotations();\n\t\t\tvar add = [];\n\t\t\twhile (annotations.hasNext()) {\n\t\t\t\tannotation = annotations.next();\n\t\t\t\tdelete annotation.groupAnnotation;\n\t\t\t\tif (annotation.groupId === groupAnnotation.groupId) {\n\t\t\t\t\tannotation = annotation.createGroupAnnotation();\n\t\t\t\t\tadd.push(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotationModel.replaceAnnotations(null, add);\n\t\t}\n\t});\n\tmAnnotations.AnnotationTypeList.addMixin(Ruler.prototype);\n\n\t/**\n\t * Constructs a new line numbering ruler. \n\t *\n\t * @param {orion.editor.AnnotationModel} annotationModel the annotation model for the ruler.\n\t * @param {String} [rulerLocation=\"left\"] the location for the ruler.\n\t * @param {orion.editor.Style} [rulerStyle=undefined] the style for the ruler.\n\t * @param {orion.editor.Style} [oddStyle={style: {backgroundColor: \"white\"}] the style for lines with odd line index.\n\t * @param {orion.editor.Style} [evenStyle={backgroundColor: \"white\"}] the style for lines with even line index.\n\t *\n\t * @augments orion.editor.Ruler\n\t * @class This objects implements a line numbering ruler.\n\t *\n\t * <p><b>See:</b><br/>\n\t * {@link orion.editor.Ruler}\n\t * </p>\n\t * @name orion.editor.LineNumberRuler\n\t */\n\tfunction LineNumberRuler (annotationModel, rulerLocation, rulerStyle, oddStyle, evenStyle) {\n\t\tRuler.call(this, annotationModel, rulerLocation, \"page\", rulerStyle); //$NON-NLS-0$\n\t\tthis._oddStyle = oddStyle || {style: {backgroundColor: \"white\"}}; //$NON-NLS-0$\n\t\tthis._evenStyle = evenStyle || {style: {backgroundColor: \"white\"}}; //$NON-NLS-0$\n\t\tthis._numOfDigits = 0;\n\t\tthis._firstLine = 1;\n\t}\n\tLineNumberRuler.prototype = new Ruler(); \n\t/** @ignore */\n\tLineNumberRuler.prototype.getAnnotations = function(startLine, endLine) {\n\t\tvar result = Ruler.prototype.getAnnotations.call(this, startLine, endLine);\n\t\tvar model = this._view.getModel();\n\t\tfor (var lineIndex = startLine; lineIndex < endLine; lineIndex++) {\n\t\t\tvar style = (lineIndex - this._firstLine) & 1 ? this._oddStyle : this._evenStyle;\n\t\t\tvar mapLine = lineIndex;\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tvar lineStart = model.getLineStart(mapLine);\n\t\t\t\tmapLine = model.getBaseModel().getLineAtOffset(model.mapOffset(lineStart));\n\t\t\t}\n\t\t\tif (!result[lineIndex]) { result[lineIndex] = {}; }\n\t\t\tresult[lineIndex].html = (this._firstLine + mapLine) + \"\";\n\t\t\tif (!result[lineIndex].style) { result[lineIndex].style = style; }\n\t\t}\n\t\treturn result;\n\t};\n\t/** @ignore */\n\tLineNumberRuler.prototype.getWidestAnnotation = function() {\n\t\tvar lineCount = this._view.getModel().getLineCount();\n\t\treturn this.getAnnotations(lineCount - 1, lineCount)[lineCount - 1];\n\t};\n\t/**\n\t * Sets the line index displayed for the first line. The default value is\n\t * <code>1</code>.\n\t *\n\t * @param {Number} [lineIndex=1] the first line index displayed\n\t */\n\tLineNumberRuler.prototype.setFirstLine = function(lineIndex) {\n\t\tthis._firstLine = lineIndex !== undefined ? lineIndex : 1;\n\t};\n\t/** @ignore */\n\tLineNumberRuler.prototype._onTextModelChanged = function(e) {\n\t\tvar start = e.start;\n\t\tvar model = this._view.getModel();\n\t\tvar lineCount = model.getBaseModel ? model.getBaseModel().getLineCount() : model.getLineCount();\n\t\tvar numOfDigits = ((this._firstLine + lineCount - 1)+\"\").length;\n\t\tif (this._numOfDigits !== numOfDigits) {\n\t\t\tthis._numOfDigits = numOfDigits;\n\t\t\tvar startLine = model.getLineAtOffset(start);\n\t\t\tthis._view.redrawLines(startLine,  model.getLineCount(), this);\n\t\t}\n\t};\n\t\n\t/** \n\t * @class This is class represents an annotation for the AnnotationRuler. \n\t * <p> \n\t * <b>See:</b><br/> \n\t * {@link orion.editor.AnnotationRuler}\n\t * </p> \n\t * \n\t * @name orion.editor.Annotation \n\t * \n\t * @property {String} [html=\"\"] The html content for the annotation, typically contains an image.\n\t * @property {orion.editor.Style} [style] the style for the annotation.\n\t * @property {orion.editor.Style} [overviewStyle] the style for the annotation in the overview ruler.\n\t */ \n\t/**\n\t * Constructs a new annotation ruler. \n\t *\n\t * @param {orion.editor.AnnotationModel} annotationModel the annotation model for the ruler.\n\t * @param {String} [rulerLocation=\"left\"] the location for the ruler.\n\t * @param {orion.editor.Style} [rulerStyle=undefined] the style for the ruler.\n\t * @param {orion.editor.Annotation} [defaultAnnotation] the default annotation.\n\t *\n\t * @augments orion.editor.Ruler\n\t * @class This objects implements an annotation ruler.\n\t *\n\t * <p><b>See:</b><br/>\n\t * {@link orion.editor.Ruler}<br/>\n\t * {@link orion.editor.Annotation}\n\t * </p>\n\t * @name orion.editor.AnnotationRuler\n\t */\n\tfunction AnnotationRuler (annotationModel, rulerLocation, rulerStyle) {\n\t\tRuler.call(this, annotationModel, rulerLocation, \"page\", rulerStyle); //$NON-NLS-0$\n\t}\n\tAnnotationRuler.prototype = new Ruler();\n\t\n\t/**\n\t * Constructs a new overview ruler. \n\t * <p>\n\t * The overview ruler is used in conjunction with a AnnotationRuler, for each annotation in the \n\t * AnnotationRuler this ruler displays a mark in the overview. Clicking on the mark causes the \n\t * view to scroll to the annotated line.\n\t * </p>\n\t *\n\t * @param {orion.editor.AnnotationModel} annotationModel the annotation model for the ruler.\n\t * @param {String} [rulerLocation=\"left\"] the location for the ruler.\n\t * @param {orion.editor.Style} [rulerStyle=undefined] the style for the ruler.\n\t *\n\t * @augments orion.editor.Ruler\n\t * @class This objects implements an overview ruler.\n\t *\n\t * <p><b>See:</b><br/>\n\t * {@link orion.editor.AnnotationRuler} <br/>\n\t * {@link orion.editor.Ruler} \n\t * </p>\n\t * @name orion.editor.OverviewRuler\n\t */\n\tfunction OverviewRuler (annotationModel, rulerLocation, rulerStyle) {\n\t\tRuler.call(this, annotationModel, rulerLocation, \"document\", rulerStyle); //$NON-NLS-0$\n\t}\n\tOverviewRuler.prototype = new Ruler();\n\t\n\t/** @ignore */\n\tOverviewRuler.prototype.getRulerStyle = function() {\n\t\tvar result = {style: {lineHeight: \"1px\", fontSize: \"1px\"}}; //$NON-NLS-1$ //$NON-NLS-0$\n\t\tresult = this._mergeStyle(result, this._rulerStyle);\n\t\treturn result;\n\t};\n\t/** @ignore */\n\tOverviewRuler.prototype._getTooltipContents = function(lineIndex, annotations) {\n\t\tif (annotations && annotations.length === 0) {\n\t\t\tvar model = this._view.getModel();\n\t\t\tvar mapLine = lineIndex;\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tvar lineStart = model.getLineStart(mapLine);\n\t\t\t\tmapLine = model.getBaseModel().getLineAtOffset(model.mapOffset(lineStart));\n\t\t\t}\n\t\t\treturn util.formatMessage(messages.line, mapLine + 1);\n\t\t}\n\t\treturn Ruler.prototype._getTooltipContents.call(this, lineIndex, annotations);\n\t};\n\t/** @ignore */\n\tOverviewRuler.prototype._mergeAnnotation = function(previousAnnotation, annotation, annotationLineIndex, annotationLineCount) {\n\t\tif (annotationLineIndex !== 0) { return undefined; }\n\t\tvar result = previousAnnotation;\n\t\tif (!result) {\n\t\t\t//TODO annotationLineCount does not work when there are folded lines\n\t\t\tvar height = 3 * annotationLineCount;\n\t\t\tresult = {html: \"&nbsp;\", style: { style: {height: height + \"px\"}}}; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tresult.style = this._mergeStyle(result.style, annotation.overviewStyle);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Constructs a new folding ruler. \n\t *\n\t * @param {orion.editor.AnnotationModel} annotationModel the annotation model for the ruler.\n\t * @param {String} [rulerLocation=\"left\"] the location for the ruler.\n\t * @param {orion.editor.Style} [rulerStyle=undefined] the style for the ruler.\n\t *\n\t * @augments orion.editor.Ruler\n\t * @class This objects implements an overview ruler.\n\t *\n\t * <p><b>See:</b><br/>\n\t * {@link orion.editor.AnnotationRuler} <br/>\n\t * {@link orion.editor.Ruler} \n\t * </p>\n\t * @name orion.editor.OverviewRuler\n\t */\n\tfunction FoldingRuler (annotationModel, rulerLocation, rulerStyle) {\n\t\tAnnotationRuler.call(this, annotationModel, rulerLocation, rulerStyle);\n\t}\n\tFoldingRuler.prototype = new AnnotationRuler();\n\t\n\t/** @ignore */\n\tFoldingRuler.prototype.onClick =  /* @callback */ function(lineIndex, e) {\n\t\tif (lineIndex === undefined) { return; }\n\t\tvar annotationModel = this._annotationModel;\n\t\tif (!annotationModel) { return; }\n\t\tvar view = this._view;\n\t\tvar model = view.getModel();\n\t\tvar start = model.getLineStart(lineIndex);\n\t\tvar end = model.getLineEnd(lineIndex, true);\n\t\tif (model.getBaseModel) {\n\t\t\tstart = model.mapOffset(start);\n\t\t\tend = model.mapOffset(end);\n\t\t\tmodel = model.getBaseModel();\n\t\t}\n\t\tvar annotation, iter = annotationModel.getAnnotations(start, end);\n\t\twhile (!annotation && iter.hasNext()) {\n\t\t\tvar a = iter.next();\n\t\t\tif (!this.isAnnotationTypeVisible(a.type)) { continue; }\n\t\t\tif (model.getLineAtOffset(a.start) !== model.getLineAtOffset(start)) { continue; }\n\t\t\tannotation = a;\n\t\t}\n\t\tif (annotation) {\n\t\t\tvar tooltip = mTooltip.Tooltip.getTooltip(this._view);\n\t\t\tif (tooltip) {\n\t\t\t\ttooltip.hide();\n\t\t\t}\n\t\t\tif (annotation.expanded) {\n\t\t\t\tannotation.collapse();\n\t\t\t} else {\n\t\t\t\tannotation.expand();\n\t\t\t}\n\t\t}\n\t};\n\t/** @ignore */\n\tFoldingRuler.prototype._getTooltipContents = function(lineIndex, annotations) {\n\t\tif (annotations && annotations.length > 0) {\n\t\t\tvar view = this._view;\n\t\t\tvar model = view.getModel();\n\t\t\tvar start = model.getLineStart(lineIndex);\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tstart = model.mapOffset(start);\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\tvar mapLineIndex = model.getLineAtOffset(start);\n\t\t\tfor (var i = 0; i < annotations.length; i++) {\n\t\t\t\tvar a = annotations[i];\n\t\t\t\tif (!this.isAnnotationTypeVisible(a.type)) { continue; }\n\t\t\t\tif (model.getLineAtOffset(a.start) !== mapLineIndex) { continue; }\n\t\t\t\tif (annotations[i].expanded) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn AnnotationRuler.prototype._getTooltipContents.call(this, lineIndex, [a]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\t/** @ignore */\n\tFoldingRuler.prototype._onAnnotationModelChanged = function(e) {\n\t\tif (e.textModelChangedEvent) {\n\t\t\tAnnotationRuler.prototype._onAnnotationModelChanged.call(this, e);\n\t\t\treturn;\n\t\t}\n\t\tvar view = this._view;\n\t\tif (!view) { return; }\n\t\tvar model = view.getModel(), self = this, i;\n\t\tvar lineCount = model.getLineCount(), lineIndex = lineCount;\n\t\tfunction redraw(changes) {\n\t\t\tfor (i = 0; i < changes.length; i++) {\n\t\t\t\tif (!self.isAnnotationTypeVisible(changes[i].type)) { continue; }\n\t\t\t\tvar start = changes[i].start;\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tstart = model.mapOffset(start, true);\n\t\t\t\t}\n\t\t\t\tif (start !== -1) {\n\t\t\t\t\tlineIndex = Math.min(lineIndex, model.getLineAtOffset(start));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tredraw(e.added);\n\t\tredraw(e.removed);\n\t\tredraw(e.changed);\n\t\tvar rulers = view.getRulers();\n\t\tfor (i = 0; i < rulers.length; i++) {\n\t\t\tview.redrawLines(lineIndex, lineCount, rulers[i]);\n\t\t}\n\t};\n\t\n\n\t/**\n\t * Constructs a new zoom ruler. \n\t *\n\t * @param {String} [rulerLocation=\"left\"] the location for the ruler.\n\t * @param {orion.editor.Style} [rulerStyle=undefined] the style for the ruler.\n\t *\n\t * @augments orion.editor.Ruler\n\t * @class This objects implements an overview ruler.\n\t *\n\t * <p><b>See:</b><br/>\n\t * {@link orion.editor.AnnotationRuler} <br/>\n\t * {@link orion.editor.Ruler} \n\t * </p>\n\t * @name orion.editor.OverviewRuler\n\t */\n\tvar ZoomRuler = function(rulerLocation, rulerStyle) {\n\t\tBaseRuler.call(this, rulerLocation, \"fixed\", rulerStyle); //$NON-NLS-0$\n\t};\n\t\n\tZoomRuler.prototype = objects.mixin(new BaseRuler(), {\n\t\tsetView: function (view) {\n\t\t\tthis._destroy();\n\t\t\tBaseRuler.prototype.setView.call(this, view);\n\t\t\tthis._create();\n\t\t},\n\t\t_create: function() {\n\t\t\tvar textView = this.getView();\n\t\t\tif (!textView) return;\n\t\t\tfunction getOptions(options) {\n\t\t\t\tvar rulerTheme = \"textviewZoom\"; //$NON-NLS-0$\n\t\t\t\tvar theme = options.themeClass;\n\t\t\t\tif (theme) {\n\t\t\t\t\ttheme = theme.replace(rulerTheme, \"\");\n\t\t\t\t\tif (theme) { theme = \" \" + theme; } //$NON-NLS-0$\n\t\t\t\t\ttheme = rulerTheme + theme;\n\t\t\t\t} else {\n\t\t\t\t\ttheme = rulerTheme;\n\t\t\t\t}\n\t\t\t\toptions.themeClass = theme;\n\t\t\t\toptions.noScroll = true;\n\t\t\t\toptions.readonly = true;\n\t\t\t\treturn options;\n\t\t\t}\n\t\t\tvar options = getOptions(textView.getOptions());\n\t\t\toptions.parent = this.node;\n\t\t\tvar zoomView = this._zoomView = new mTextView.TextView(options);\n\t\t\tzoomView._clientDiv.contentEditable = false;\n\t\t\tzoomView.setModel(textView.getModel());\n\t\t\tvar document = textView.getOptions(\"parent\").ownerDocument; //$NON-NLS-0$\n\t\t\tvar windowDiv = this._windowDiv = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\twindowDiv.className =\"rulerZoomWindow\"; //$NON-NLS-0$\n\t\t\tthis.node.appendChild(windowDiv);\n\t\t\tvar border = parseInt(textUtil.getNodeStyle(windowDiv, \"border-top-width\", 0)) + //$NON-NLS-0$\n\t\t\t\t\tparseInt(textUtil.getNodeStyle(windowDiv, \"border-bottom-width\", 0)); //$NON-NLS-0$\n\t\t\tvar that = this;\n\t\t\tfunction updateWindow(scroll, p) {\n\t\t\t\tvar top = scroll.y * p.zoomFactor;\n\t\t\t\tvar height = p.clientHeight * p.zoomFactor;\n\t\t\t\tthat.top = top;\n\t\t\t\tthat.bottom = top + height;\n\t\t\t\ttop = zoomView.convert({y: top}, \"document\", \"page\").y; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\ttop = top - that.node.getBoundingClientRect().top;\n\t\t\t\twindowDiv.style.top = top + \"px\"; //$NON-NLS-0$\n\t\t\t\twindowDiv.style.height = (height - border) + \"px\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\tfunction getProps() {\n\t\t\t\tvar padding = textView._metrics.viewPadding;\n\t\t\t\tvar zoomPadding = textView._metrics.viewPadding;\n\t\t\t\tvar lineHeight = textView.getLineHeight();\n\t\t\t\tvar zoomLineHeight = zoomView.getLineHeight();\n\t\t\t\tvar lineCount = textView.getModel().getLineCount();\n\t\t\t\tvar documentHeight = textView._lineHeight ? textView._scrollHeight : lineCount * lineHeight;\n\t\t\t\tvar zoomDocumentHeight = zoomView._lineHeight ? zoomView._scrollHeight : lineCount * zoomLineHeight;\n\t\t\t\tvar zoomFactor = zoomDocumentHeight / documentHeight;\n\t\t\t\tvar clientHeight = textView.getClientArea().height + padding.top + padding.bottom;\n\t\t\t\tvar zoomClientHeight = zoomView.getClientArea().height + zoomPadding.top + zoomPadding.bottom;\n\t\t\t\tvar windowHeight = clientHeight * zoomFactor;\n\t\t\t\tvar scrollWidth = textView._metrics.scrollWidth;\n\t\t\t\treturn {\n\t\t\t\t\tzoomFactor: zoomFactor,\n\t\t\t\t\tdocumentHeight: documentHeight,\n\t\t\t\t\tzoomDocumentHeight: zoomDocumentHeight,\n\t\t\t\t\tclientHeight: clientHeight,\n\t\t\t\t\tzoomClientHeight: zoomClientHeight,\n\t\t\t\t\tscrollWidth: scrollWidth,\n\t\t\t\t\twindowHeight: windowHeight,\n\t\t\t\t\tpadding: padding\n\t\t\t\t};\n\t\t\t}\n\t\t\tfunction toZoom(scroll, p) {\n\t\t\t\treturn scroll.y * (p.zoomFactor + (p.windowHeight - p.clientHeight - p.scrollWidth) / p.documentHeight);\n\t\t\t}\n\t\t\tfunction updateScroll(scroll) {\n\t\t\t\tscroll = scroll || {y: textView.getTopPixel()};\n\t\t\t\tvar p = getProps();\n\t\t\t\tvar y = toZoom(scroll, p);\n\t\t\t\tzoomView.setTopPixel(y);\n\t\t\t\tupdateWindow(scroll, p);\n\t\t\t}\n\t\t\tfunction updateWidth(options) {\n\t\t\t\tvar width;\n\t\t\t\tif (options.wrapMode && !options.wrapOffset && textView._metrics.charWidth) {\n\t\t\t\t\tvar div1 = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\t\t\tdiv1.style.position = \"fixed\"; //$NON-NLS-0$\n\t\t\t\t\tdiv1.style.left = \"-1000px\"; //$NON-NLS-0$\n\t\t\t\t\tzoomView._clientDiv.appendChild(div1);\n\t\t\t\t\tdiv1.innerHTML = new Array(Math.ceil(textView.getClientArea().width / textView._metrics.charWidth) + 1).join(\"a\"); //$NON-NLS-0$\n\t\t\t\t\tvar rect1 = div1.getBoundingClientRect();\n\t\t\t\t\twidth = Math.min(150, Math.ceil(rect1.right - rect1.left)) + \"px\"; //$NON-NLS-0$\n\t\t\t\t} else {\n\t\t\t\t\twidth = \"\";\n\t\t\t\t}\n\t\t\t\tvar oldWidth = that.node.style.width;\n\t\t\t\tthat.node.style.width = width;\n\t\t\t\treturn oldWidth !== width;\n\t\t\t}\n\t\t\ttextView.addEventListener(\"Scroll\", this._scrollListener = function(event) { //$NON-NLS-0$\n\t\t\t\tupdateScroll(event.newValue);\n\t\t\t});\n\t\t\ttextView.addEventListener(\"Resize\", this._resizeListener = function() { //$NON-NLS-0$\n\t\t\t\tupdateWidth(zoomView.getOptions());\n\t\t\t\tupdateScroll();\n\t\t\t});\n\t\t\ttextView.addEventListener(\"Redraw\", this._redrawListener = function(event) { //$NON-NLS-0$\n\t\t\t\tif (!event.ruler) {\n\t\t\t\t\tzoomView.redrawLines(event.startLine, event.endLine);\n\t\t\t\t}\n\t\t\t});\n\t\t\ttextView.addEventListener(\"Options\", this._optionsListener = function(event) { //$NON-NLS-0$\n\t\t\t\tvar options = getOptions(event.options);\n\t\t\t\tzoomView.setOptions(options);\n\t\t\t\tupdateWidth(zoomView.getOptions());\n\t\t\t});\n\t\t\tzoomView.addEventListener(\"LineStyle\", this._lineListener = function(e) { //$NON-NLS-0$\n\t\t\t\ttextView.onLineStyle(e);\n\t\t\t});\n\t\t\tfunction down(event, clientY, touch) {\n\t\t\t\tif (touch || (that.top <= event.y && event.y <= that.bottom)) {\n\t\t\t\t\tthat.mouseDown = true;\n\t\t\t\t\tthat.delta = clientY - windowDiv.getBoundingClientRect().top + that.node.getBoundingClientRect().top;\n\t\t\t\t} else {\n\t\t\t\t\tvar offset = zoomView.getOffsetAtLocation(event.x, event.y);\n\t\t\t\t\ttextView.setSelection(offset, offset, 0.5, function() {});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction up() {\n\t\t\t\tthat.mouseDown = false;\n\t\t\t}\n\t\t\tfunction move(clientY) {\n\t\t\t\tif (that.mouseDown) {\n\t\t\t\t\tvar p = getProps();\n\t\t\t\t\tvar thumbPos = Math.min(p.zoomClientHeight - p.windowHeight, Math.max(0, clientY - that.delta));\n\t\t\t\t\ttextView.setTopPixel(thumbPos * (p.documentHeight - p.clientHeight) / Math.min(p.zoomDocumentHeight, p.zoomClientHeight - p.windowHeight));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction stop(event) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t\tif (util.isIOS || util.isAndroid) {\n\t\t\t\twindowDiv.addEventListener(\"touchstart\", function(event) { //$NON-NLS-0$\n\t\t\t\t\tvar touches = event.touches;\n\t\t\t\t\tif (touches.length === 1) {\n\t\t\t\t\t\tdown(event, event.touches[0].clientY, true);\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\twindowDiv.addEventListener(\"touchend\", function(event) { //$NON-NLS-0$\n\t\t\t\t\tvar touches = event.touches;\n\t\t\t\t\tif (touches.length === 0) {\n\t\t\t\t\t\tup(event);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\twindowDiv.addEventListener(\"touchmove\", function(event) { //$NON-NLS-0$\n\t\t\t\t\tvar touches = event.touches;\n\t\t\t\t\tif (touches.length === 1) {\n\t\t\t\t\t\tmove(event.touches[0].clientY);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tzoomView.addEventListener(\"TouchStart\", function(event) { //$NON-NLS-0$\n\t\t\t\t\tif (event.touchCount === 1) {\n\t\t\t\t\t\tdown(event, event.event.touches[0].clientY);\n\t\t\t\t\t\tstop(event);\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\twindowDiv.style.pointerEvents = \"none\"; //$NON-NLS-0$\n//\t\t\t\tzoomView.addEventListener(\"TouchEnd\", function(event) { //$NON-NLS-0$\n//\t\t\t\t\tif (event.touchCount === 0) {\n//\t\t\t\t\t\tup(event);\n//\t\t\t\t\t}\n//\t\t\t\t});\n//\t\t\t\tzoomView.addEventListener(\"TouchMove\", function(event) { //$NON-NLS-0$\n//\t\t\t\t\tif (event.touchCount === 1) {\n//\t\t\t\t\t\tmove(event.event.touches[0].clientY);\n//\t\t\t\t\t}\n//\t\t\t\t});\n\t\t\t} else {\n\t\t\t\twindowDiv.style.pointerEvents = \"none\"; //$NON-NLS-0$\n\t\t\t\tzoomView.addEventListener(\"MouseDown\", function(event) { //$NON-NLS-0$\n\t\t\t\t\tvar e = event.event;\n\t\t\t\t\tif (e.which ? e.button === 0 : e.button === 1) {\n\t\t\t\t\t\tdown(event, e.clientY);\n\t\t\t\t\t}\n\t\t\t\t\tstop(event);\n\t\t\t\t});\n\t\t\t\tzoomView.addEventListener(\"MouseUp\", function(event) { //$NON-NLS-0$\n\t\t\t\t\tup(event);\n\t\t\t\t\tstop(event);\n\t\t\t\t});\n\t\t\t\tzoomView.addEventListener(\"MouseMove\", function(event) { //$NON-NLS-0$\n\t\t\t\t\tmove(event.event.clientY);\n\t\t\t\t\tstop(event);\n\t\t\t\t});\n\t\t\t}\n\t\t\t(document.defaultView || document.parentWindow).setTimeout(function() {\n\t\t\t\tupdateScroll();\n\t\t\t}, 0);\n\t\t},\n\t\t_destroy: function() {\n\t\t\tvar textView = this.getView();\n\t\t\tif (textView) {\n\t\t\t\ttextView.removeEventListener(\"Scroll\", this._scrollListener); //$NON-NLS-0$\n\t\t\t\tthis._scrollListener = null;\n\t\t\t\ttextView.removeEventListener(\"Resize\", this._resizeListener); //$NON-NLS-0$\n\t\t\t\tthis._resizeListener = null;\n\t\t\t\ttextView.removeEventListener(\"Redraw\", this._redrawListener); //$NON-NLS-0$\n\t\t\t\tthis._redrawListener = null;\n\t\t\t\ttextView.removeEventListener(\"Options\", this._optionsListener); //$NON-NLS-0$\n\t\t\t\tthis._optionsListener = null;\n\t\t\t}\n\t\t\tvar zoomView = this._zoomView;\n\t\t\tif (zoomView) {\n\t\t\t\tzoomView.removeEventListener(\"LineStyle\", this._lineListener); //$NON-NLS-0$\n\t\t\t\tzoomView.setModel(null);\n\t\t\t\tzoomView.destroy();\n\t\t\t\tthis._zoomView = null;\n\t\t\t}\n\t\t}\n\t});\n\t\n\treturn {\n\t\tBaseRuler: BaseRuler,\n\t\tRuler: Ruler,\n\t\tAnnotationRuler: AnnotationRuler,\n\t\tLineNumberRuler: LineNumberRuler,\n\t\tOverviewRuler: OverviewRuler,\n\t\tFoldingRuler: FoldingRuler,\n\t\tZoomRuler: ZoomRuler,\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n * \n * Contributors: \n *\t\tFelipe Heidrich (IBM Corporation) - initial API and implementation\n *\t\tSilenio Quarti (IBM Corporation) - initial API and implementation\n ******************************************************************************/\n \n/*eslint-env browser, amd*/\ndefine(\"orion/editor/textDND\", ['orion/util'], function(util) { //$NON-NLS-1$ //$NON-NLS-0$\n\n\tfunction TextDND(view, undoStack) {\n\t\tthis._view = view;\n\t\tthis._undoStack = undoStack;\n\t\tthis._dragSelection = null;\n\t\tthis._dropOffset = -1;\n\t\tthis._dropText = null;\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonDragStart: function (evt) {\n\t\t\t\tself._onDragStart(evt);\n\t\t\t},\n\t\t\tonDragEnd: function (evt) {\n\t\t\t\tself._onDragEnd(evt);\n\t\t\t},\n\t\t\tonDragEnter: function (evt) {\n\t\t\t\tself._onDragEnter(evt);\n\t\t\t},\n\t\t\tonDragOver: function (evt) {\n\t\t\t\tself._onDragOver(evt);\n\t\t\t},\n\t\t\tonDrop: function (evt) {\n\t\t\t\tself._onDrop(evt);\n\t\t\t},\n\t\t\tonDestroy: function (evt) {\n\t\t\t\tself._onDestroy(evt);\n\t\t\t}\n\t\t};\n\t\tview.addEventListener(\"DragStart\", this._listener.onDragStart); //$NON-NLS-0$\n\t\tview.addEventListener(\"DragEnd\", this._listener.onDragEnd); //$NON-NLS-0$\n\t\tview.addEventListener(\"DragEnter\", this._listener.onDragEnter); //$NON-NLS-0$\n\t\tview.addEventListener(\"DragOver\", this._listener.onDragOver); //$NON-NLS-0$\n\t\tview.addEventListener(\"Drop\", this._listener.onDrop); //$NON-NLS-0$\n\t\tview.addEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t}\n\tTextDND.prototype = {\n\t\tdestroy: function() {\n\t\t\tvar view = this._view;\n\t\t\tif (!view) { return; }\n\t\t\tview.removeEventListener(\"DragStart\", this._listener.onDragStart); //$NON-NLS-0$\n\t\t\tview.removeEventListener(\"DragEnd\", this._listener.onDragEnd); //$NON-NLS-0$\n\t\t\tview.removeEventListener(\"DragEnter\", this._listener.onDragEnter); //$NON-NLS-0$\n\t\t\tview.removeEventListener(\"DragOver\", this._listener.onDragOver); //$NON-NLS-0$\n\t\t\tview.removeEventListener(\"Drop\", this._listener.onDrop); //$NON-NLS-0$\n\t\t\tview.removeEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\t\tthis._view = null;\n\t\t},\n\t\t_onDestroy: function(e) {\n\t\t\tthis.destroy();\n\t\t},\n\t\t_onDragStart: function(e) {\n\t\t\tvar view = this._view;\n\t\t\tvar text = view.getSelectionText();\n\t\t\tif (text) {\n\t\t\t\tthis._dragSelection = view.getSelections();\n\t\t\t\te.event.dataTransfer.effectAllowed = \"copyMove\"; //$NON-NLS-0$\n\t\t\t\te.event.dataTransfer.setData(\"Text\", text); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_onDragEnd: function(e) {\n\t\t\tif (this._dragSelection) {\n\t\t\t\tvar view = this._view;\n\t\t\t\tvar dropEffect = e.event.dataTransfer.dropEffect;\n\t\t\t\tif (!util.isFirefox) {\n\t\t\t\t\tif (dropEffect !== \"none\" || this._dropText) { //$NON-NLS-0$\n\t\t\t\t\t\tdropEffect = e.event.dataTransfer.dropEffect = this._dropEffect;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this._undoStack) { this._undoStack.startCompoundChange(); }\n\t\t\t\tvar move = dropEffect === \"move\"; //$NON-NLS-0$\n\t\t\t\tif (move) {\n\t\t\t\t\tview.setText({text: \"\", selection: this._dragSelection});\n\t\t\t\t}\n\t\t\t\tif (this._dropText) {\n\t\t\t\t\tvar text = this._dropText;\n\t\t\t\t\tvar offset = this._dropOffset;\n\t\t\t\t\tif (move) {\n\t\t\t\t\t\tthis._dragSelection.forEach(function(selection) {\n\t\t\t\t\t\t\tif (offset >= selection.end) {\n\t\t\t\t\t\t\t\toffset -= selection.end - selection.start;\n\t\t\t\t\t\t\t} else if (offset >= selection.start) {\n\t\t\t\t\t\t\t\toffset = selection.start;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tview.setText(text, offset, offset);\n\t\t\t\t\tview.setSelection(offset, offset + text.length);\n\t\t\t\t\tthis._dropText = null;\n\t\t\t\t\tthis._dropOffset = -1;\n\t\t\t\t}\n\t\t\t\tif (this._undoStack) { this._undoStack.endCompoundChange(); }\n\t\t\t\tthis._dragSelection = null;\n\t\t\t}\n\t\t},\n\t\t_onDragEnter: function(e) {\n\t\t\tthis._onDragOver(e);\n\t\t},\n\t\t_onDragOver: function(e) {\n\t\t\tvar types = e.event.dataTransfer.types;\n\t\t\tvar allowed = !this._view.getOptions(\"readonly\"); //$NON-NLS-0$\n\t\t\tif (allowed) {\n\t\t\t\tif (types) {\n\t\t\t\t\tallowed = types.contains ? \n\t\t\t\t\t\ttypes.contains(\"text/plain\") || types.contains(\"Text\") : //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\ttypes.indexOf(\"text/plain\") !== -1 || types.indexOf(\"Text\") !== -1; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!allowed) {\n\t\t\t\te.event.dataTransfer.dropEffect = \"none\"; //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tif (!util.isFirefox) {\n\t\t\t\t\tvar copy = util.isMac ? e.event.altKey : e.event.ctrlKey;\n\t\t\t\t\tthis._dropEffect = e.event.dataTransfer.dropEffect = copy ? \"copy\" : \"move\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_onDrop: function(e) {\n\t\t\tvar view = this._view;\n\t\t\tvar text = e.event.dataTransfer.getData(\"Text\"); //$NON-NLS-0$\n\t\t\tif (text) {\n\t\t\t\tif (!util.isFirefox) {\n\t\t\t\t\te.event.dataTransfer.dropEffect = this._dropEffect; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\tvar offset = view.getOffsetAtLocation(e.x, e.y);\n\t\t\t\tif (this._dragSelection) {\n\t\t\t\t\tthis._dropOffset = offset;\n\t\t\t\t\tthis._dropText = text;\n\t\t\t\t} else {\n\t\t\t\t\tview.setText(text, offset, offset);\n\t\t\t\t\tview.setSelection(offset, offset + text.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\treturn {TextDND: TextDND};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/linkedMode\", [ //$NON-NLS-0$\n\t'i18n!orion/editor/nls/messages', //$NON-NLS-0$\n\t'orion/keyBinding', //$NON-NLS-0$\n\t'orion/editor/keyModes', //$NON-NLS-0$\n\t'orion/editor/annotations', //$NON-NLS-0$\n\t'orion/objects', //$NON-NLS-0$\n\t'orion/util' //$NON-NLS-0$\n], function(messages, mKeyBinding, mKeyModes, mAnnotations, objects) {\n\n\tvar exports = {};\n\n\t/**\n\t * @name LinkedContentAssist\n\t * @description Creates a new LinkedContentAssist object which is used for linked data in templates\n\t * @constructor \n\t * @param {Object} linkedData The linked data\n\t * @returns A new LinkedContentAssist object\n\t * @since 9.0\n\t */\n\tfunction LinkedContentAssist(linkedData) {\n\t\tthis._data = linkedData;\n\t}\n\t\n\tLinkedContentAssist.prototype = {\n\t\tchop: function(prefix, string) {\n\t\t\treturn string.substring(prefix.length);\n\t\t},\n\t\t\n\t\t/**\n\t\t * @callback\n\t\t */\n\t\tcomputeProposals: function(buffer, offset, context) {\n\t\t\tvar prefix = context.prefix;\n\t\t\tvar proposals = [];\n\t\t\tvar linkedstyle = this._data.style ? this._data.style : null;\n\t\t\tlinkedstyle = linkedstyle ? linkedstyle : 'emphasis';\n\t\t\tvar values = this._data.values;\n\t\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\t\tvar val = values[i];\n\t\t\t\tif(typeof(val) === 'string' && val.indexOf(prefix) === 0) {\n\t\t\t\t\tproposals.push({proposal: this.chop(prefix, val), \n\t\t\t\t\t\tdescription: val,\n\t\t\t\t\t\thover: val,\n\t\t\t\t\t\tstyle: linkedstyle\n\t\t\t\t\t});\n\t\t\t\t} else if(typeof(val) === 'object' && val.proposal) {\n\t\t\t\t\tproposals.push({proposal: this.chop(prefix, val.proposal), \n\t\t\t\t\t\tdescription: val.description ? val.description : val.proposal,\n\t\t\t\t\t\thover: val.hover ? val.hover : val.proposal,\n\t\t\t\t\t\tstyle: linkedstyle\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar linkedtitle = this._data.title ? this._data.title : null;\n\t\t\tif (0 < proposals.length) {\n\t\t\t\tproposals.splice(0, 0,{\n\t\t\t\t\tproposal: '',\n\t\t\t\t\tdescription: linkedtitle ? linkedtitle : 'Options', //$NON-NLS-0$\n\t\t\t\t\tstyle: 'noemphasis_title', //$NON-NLS-0$\n\t\t\t\t\tunselectable: true\n\t\t\t\t});\t\n\t\t\t}\n\t\t\treturn proposals;\n\t\t}\n\t};\n\n\tfunction LinkedMode(editor, undoStack, contentAssist) {\n\t\tvar textView = editor.getTextView();\n\t\tmKeyModes.KeyMode.call(this, textView);\n\t\tthis.editor = editor;\n\t\tthis.undoStack = undoStack;\n\t\tthis.contentAssist = contentAssist;\n\t\t\n\t\tthis.linkedModeModel = null;\n\t\t\n\t\ttextView.setAction(\"linkedModeEnter\", function() { //$NON-NLS-0$\n\t\t\tthis.exitLinkedMode(true);\n\t\t\treturn true;\n\t\t}.bind(this));\n\t\ttextView.setAction(\"linkedModeCancel\", function() { //$NON-NLS-0$\n\t\t\tthis.exitLinkedMode(false);\n\t\t\treturn true;\n\t\t}.bind(this));\n\t\ttextView.setAction(\"linkedModeNextGroup\", function() { //$NON-NLS-0$\n\t\t\tvar model = this.linkedModeModel;\n\t\t\tthis.selectLinkedGroup((model.selectedGroupIndex + 1) % model.groups.length);\n\t\t\treturn true;\n\t\t}.bind(this));\n\t\ttextView.setAction(\"linkedModePreviousGroup\", function() { //$NON-NLS-0$\n\t\t\tvar model = this.linkedModeModel;\n\t\t\tthis.selectLinkedGroup(model.selectedGroupIndex > 0 ? model.selectedGroupIndex-1 : model.groups.length-1);\n\t\t\treturn true;\n\t\t}.bind(this));\n\t\t\n\t\t/**\n\t\t * Listener called when Linked Mode is active. Updates position's offsets and length\n\t\t * on user change. Also escapes the Linked Mode if the text buffer was modified outside of the Linked Mode positions.\n\t\t */\n\t\tthis.linkedModeListener = {\n\t\t\n\t\t\tonActivating: function(event) {\n\t\t\t\tif (this._groupContentAssistProvider) {\n\t\t\t\t\tthis.contentAssist.setProviders([this._groupContentAssistProvider]);\n\t\t\t\t\tthis.contentAssist.setProgress(null);\n\t\t\t\t}\n\t\t\t}.bind(this),\n\t\t\t\n\t\t\tonModelChanged: function(event) {\n\t\t\t\tif (this.ignoreVerify) { return; }\n\n\t\t\t\t// Get the position being modified\n\t\t\t\tvar start = this.editor.mapOffset(event.start);\n\t\t\t\tvar model = this.linkedModeModel, positionChanged, changed;\n\t\t\t\twhile (model) {\n\t\t\t\t\tpositionChanged = this._getPositionChanged(model, start, start + event.removedCharCount);\n\t\t\t\t\tchanged = positionChanged.position;\n\t\t\t\t\tif (changed === undefined || changed.model !== model) {\n\t\t\t\t\t\t// The change has been done outside of the positions, exit the Linked Mode\n\t\t\t\t\t\tthis.exitLinkedMode(false);\n\t\t\t\t\t\tmodel = this.linkedModeModel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!model) { return; }\n\n\t\t\t\t// Update position offsets for this change. Group changes are done in #onVerify\n\t\t\t\tvar deltaCount = 0;\n\t\t\t\tvar changeCount = event.addedCharCount - event.removedCharCount;\n\t\t\t\tvar sortedPositions = positionChanged.positions, position, pos;\n\t\t\t\tfor (var i = 0; i < sortedPositions.length; ++i) {\n\t\t\t\t\tpos = sortedPositions[i];\n\t\t\t\t\tposition = pos.position;\n\t\t\t\t\tvar inside = position.offset <= start && start <= position.offset + position.length;\n\t\t\t\t\tif (inside && !pos.ansestor) {\n\t\t\t\t\t\tposition.offset += deltaCount;\n\t\t\t\t\t\tposition.length += changeCount;\n\t\t\t\t\t\tdeltaCount += changeCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.offset += deltaCount;\n\t\t\t\t\t\tif (pos.ansestor && inside) {\n\t\t\t\t\t\t\tposition.length += changeCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pos.escape) {\n\t\t\t\t\t\tpos.model.escapePosition = position.offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._updateAnnotations(sortedPositions);\n\t\t\t}.bind(this),\n\n\t\t\tonVerify: function(event) {\n\t\t\t\tif (this.ignoreVerify) { return; }\n\n\t\t\t\t// Get the position being modified\n\t\t\t\tvar editor = this.editor;\n\t\t\t\tvar start = editor.mapOffset(event.start);\n\t\t\t\tvar end = this.editor.mapOffset(event.end);\n\t\t\t\tvar model = this.linkedModeModel, positionChanged, changed;\n\t\t\t\twhile (model) {\n\t\t\t\t\tpositionChanged = this._getPositionChanged(model, start, end);\n\t\t\t\t\tchanged = positionChanged.position;\n\t\t\t\t\tif (changed === undefined || changed.model !== model) {\n\t\t\t\t\t\t// The change has been done outside of the positions, exit the Linked Mode\n\t\t\t\t\t\tthis.exitLinkedMode(false);\n\t\t\t\t\t\tmodel = this.linkedModeModel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!model) { return; }\n\t\t\t\t\n\t\t\t\t// Make sure changes in a same group are compound\n\t\t\t\tvar undo = this._compoundChange;\n\t\t\t\tif (undo) {\n\t\t\t\t\tif (!(undo.owner.model === model && undo.owner.group === changed.group)) {\n\t\t\t\t\t\tthis.endUndo();\n\t\t\t\t\t\tthis.startUndo();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.startUndo();\n\t\t\t\t}\n\n\t\t\t\tmodel.selectedGroupIndex = changed.group;\n\t\t\t\t\n\t\t\t\t// Update position offsets taking into account all positions in the same changing group\n\t\t\t\tvar deltaCount = 0;\n\t\t\t\tvar changeCount = event.text.length - (end - start);\n\t\t\t\tvar sortedPositions = positionChanged.positions, position, pos;\n\t\t\t\tvar deltaStart = start - changed.position.offset, deltaEnd = end - changed.position.offset;\n\t\t\t\tfor (var i = 0; i < sortedPositions.length; ++i) {\n\t\t\t\t\tpos = sortedPositions[i];\n\t\t\t\t\tposition = pos.position;\n\t\t\t\t\tpos.oldOffset = position.offset;\n\t\t\t\t\tif (pos.model === model && pos.group === changed.group) {\n\t\t\t\t\t\tposition.offset += deltaCount;\n\t\t\t\t\t\tposition.length += changeCount;\n\t\t\t\t\t\tdeltaCount += changeCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.offset += deltaCount;\n\t\t\t\t\t\tif (pos.ansestor) {\n\t\t\t\t\t\t\tposition.length += changed.count * changeCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pos.escape) {\n\t\t\t\t\t\tpos.model.escapePosition = position.offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Cancel this modification and apply same modification to all positions in changing group\n\t\t\t\tthis.ignoreVerify = true;\n\t\t\t\tfor (i = sortedPositions.length - 1; i >= 0; i--) {\n\t\t\t\t\tpos = sortedPositions[i];\n\t\t\t\t\tif (pos.model === model && pos.group === changed.group) {\n\t\t\t\t\t\teditor.setText(event.text, pos.oldOffset + deltaStart , pos.oldOffset + deltaEnd, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.ignoreVerify = false;\n\t\t\t\tevent.text = null;\n\t\t\t\tthis._updateAnnotations(sortedPositions);\n\t\t\t}.bind(this)\n\t\t};\n\t}\n\tLinkedMode.prototype = new mKeyModes.KeyMode();\n\tobjects.mixin(LinkedMode.prototype, {\n\t\tcreateKeyBindings: function() {\n\t\t\tvar KeyBinding = mKeyBinding.KeyBinding;\n\t\t\tvar bindings = [];\n\t\t\tbindings.push({actionID: \"linkedModeEnter\", keyBinding: new KeyBinding(13)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"linkedModeCancel\", keyBinding: new KeyBinding(27)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"linkedModeNextGroup\", keyBinding: new KeyBinding(9)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"linkedModePreviousGroup\", keyBinding: new KeyBinding(9, false, true)}); //$NON-NLS-0$\n\t\t\treturn bindings;\n\t\t},\n\t\t/**\n\t\t * Starts Linked Mode, selects the first position and registers the listeners.\n\t\t * @param {Object} linkedModeModel An object describing the model to be used by linked mode.\n\t\t * Contains one or more position groups. If a position in a group is edited, the other positions in\n\t\t * the same group are edited the same way. The model structure is as follows:\n\t\t * <pre>{\n\t\t *\t\tgroups: [{\n\t\t *\t\t\tdata: {},\n\t\t *\t\t\tpositions: [{\n\t\t *\t\t\t\toffset: 10, // Relative to the text buffer\n\t\t *\t\t\t\tlength: 3\n\t\t *\t\t\t}]\n\t\t *\t\t}],\n\t\t *\t\tescapePosition: 19, // Relative to the text buffer\n\t\t * }</pre>\n\t\t *\n\t\t * Each group in the model has an optional <code>data</code> property which can be\n\t\t * used to provide additional content assist for the group.  The <code>type</code> in\n\t\t * data determines what kind of content assist is provided. These are the support\n\t\t * structures for the <code>data</code> property.\n\t\t * <pre>{\n\t\t *\t\ttype: \"link\"\n\t\t *\t\tvalues: [\"proposal0\", \"proposal1\", ...]\n\t\t * }</pre>\n\t\t *\n\t\t * The \"link\" data struture provides static content assist proposals stored in the\n\t\t * <code>values</code> property.\n\t\t *\n\t\t * <p>\n\t\t * <b>See:</b><br/>\n\t\t * {@link orion.editor.Template}<br/>\n\t\t * {@link orion.editor.TemplateContentAssist}<br/>\n\t\t * </p>\n\t\t */\n\t\tenterLinkedMode: function(linkedModeModel) {\n\t\t\tif (!this.linkedModeModel) {\n\t\t\t\tvar textView = this.editor.getTextView();\n\t\t\t\ttextView.addKeyMode(this);\n\t\t\t\ttextView.addEventListener(\"Verify\", this.linkedModeListener.onVerify); //$NON-NLS-0$\n\t\t\t\ttextView.addEventListener(\"ModelChanged\", this.linkedModeListener.onModelChanged); //$NON-NLS-0$\n\t\t\t\tvar contentAssist = this.contentAssist;\n\t\t\t\tcontentAssist.addEventListener(\"Activating\", this.linkedModeListener.onActivating); //$NON-NLS-0$\n\t\t\t\tthis.editor.reportStatus(messages.linkedModeEntered, null, true);\n\t\t\t}\n\t\t\tthis._sortedPositions = null;\n\t\t\tif (this.linkedModeModel) {\n\t\t\t\tlinkedModeModel.previousModel = this.linkedModeModel;\n\t\t\t\tlinkedModeModel.parentGroup = this.linkedModeModel.selectedGroupIndex;\n\t\t\t\tthis.linkedModeModel.nextModel = linkedModeModel;\n\t\t\t}\n\t\t\tthis.linkedModeModel = linkedModeModel;\n\t\t\tthis.selectLinkedGroup(0);\n\t\t},\n\t\t/** \n\t\t * Exits Linked Mode. Optionally places the caret at linkedMode escapePosition. \n\t\t * @param {Boolean} [escapePosition=false] if true, place the caret at the  escape position.\n\t\t */\n\t\texitLinkedMode: function(escapePosition) {\n\t\t\tif (!this.isActive()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._compoundChange) {\n\t\t\t\tthis.endUndo();\n\t\t\t\tthis._compoundChange = null;\n\t\t\t}\n\t\t\tthis._sortedPositions = null;\n\t\t\tvar model = this.linkedModeModel;\n\t\t\tthis.linkedModeModel = model.previousModel;\n\t\t\tmodel.parentGroup = model.previousModel = undefined;\n\t\t\tif (this.linkedModeModel) {\n\t\t\t\tthis.linkedModeModel.nextModel = undefined;\n\t\t\t}\n\t\t\tif (!this.linkedModeModel) {\n\t\t\t\tvar editor = this.editor;\n\t\t\t\tvar textView = editor.getTextView();\n\t\t\t\ttextView.removeKeyMode(this);\n\t\t\t\ttextView.removeEventListener(\"Verify\", this.linkedModeListener.onVerify); //$NON-NLS-0$\n\t\t\t\ttextView.removeEventListener(\"ModelChanged\", this.linkedModeListener.onModelChanged); //$NON-NLS-0$\n\t\t\t\tvar contentAssist = this.contentAssist;\n\t\t\t\tcontentAssist.removeEventListener(\"Activating\", this.linkedModeListener.onActivating); //$NON-NLS-0$\n\t\t\t\tcontentAssist.offset = undefined;\n\t\t\t\tthis.editor.reportStatus(messages.linkedModeExited, null, true);\n\t\t\t\tif (escapePosition && typeof model.escapePosition === \"number\") { //$NON-NLS-0$\n\t\t\t\t\teditor.setCaretOffset(model.escapePosition, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.selectLinkedGroup(0);\n\t\t},\n\t\tstartUndo: function() {\n\t\t\tif (this.undoStack) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar model = this.linkedModeModel;\n\t\t\t\tthis._compoundChange = this.undoStack.startCompoundChange({\n\t\t\t\t\tmodel: model,\n\t\t\t\t\tgroup: model.selectedGroupIndex,\n\t\t\t\t\tend: function() {\n\t\t\t\t\t\tself._compoundChange = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, \n\t\tendUndo: function() {\n\t\t\tif (this.undoStack) {\n\t\t\t\tthis.undoStack.endCompoundChange();\n\t\t\t}\n\t\t},\n\t\tisActive: function() {\n\t\t\treturn !!this.linkedModeModel;\n\t\t},\n\t\tisStatusActive: function() {\n\t\t\treturn !!this.linkedModeModel;\n\t\t},\n\t\tselectLinkedGroup: function(index) {\n\t\t\tvar model = this.linkedModeModel;\n\t\t\tif (model) {\n\t\t\t\tmodel.selectedGroupIndex = index;\n\t\t\t\tvar group = model.groups[index];\n\t\t\t\tvar position = group.positions[0];\n\t\t\t\tvar editor = this.editor;\n\t\t\t\teditor.setSelection(position.offset, position.offset + position.length);\n\t\t\t\tvar contentAssist = this.contentAssist;\n\t\t\t\tif (contentAssist) {\n\t\t\t\t\tcontentAssist.offset = undefined;\n\t\t\t\t\tif (group.data && group.data.type === \"link\" && group.data.values) { //$NON-NLS-0$\n\t\t\t\t\t\tvar provider = this._groupContentAssistProvider = new LinkedContentAssist(group.data);\n\t\t\t\t\t\tprovider.getPrefix = function() {\n\t\t\t\t\t\t\tvar selection = editor.getSelection();\n\t\t\t\t\t\t\tif (selection.start === selection.end) {\n\t\t\t\t\t\t\t\tvar caretOffset = editor.getCaretOffset();\n\t\t\t\t\t\t\t\tif (position.offset <= caretOffset && caretOffset <= position.offset + position.length) {\n\t\t\t\t\t\t\t\t\treturn editor.getText(position.offset, caretOffset);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t};\n\t\t\t\t\t\tcontentAssist.offset = position.offset;\n\t\t\t\t\t\tcontentAssist.deactivate();\n\t\t\t\t\t\tcontentAssist.activate();\n\t\t\t\t\t} else if (this._groupContentAssistProvider) {\n\t\t\t\t\t\tthis._groupContentAssistProvider = null;\n\t\t\t\t\t\tcontentAssist.deactivate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._updateAnnotations();\n\t\t},\n\t\t_getModelPositions: function(all, model, delta) {\n\t\t\tvar groups = model.groups;\n\t\t\tfor (var i = 0; i < groups.length; i++) {\n\t\t\t\tvar positions = groups[i].positions;\n\t\t\t\tfor (var j = 0; j < positions.length; j++) {\n\t\t\t\t\tvar position = positions[j];\n\t\t\t\t\tif (delta) {\n\t\t\t\t\t\tposition = {offset: position.offset + delta, length: position.length};\n\t\t\t\t\t}\n\t\t\t\t\tvar pos = {\n\t\t\t\t\t\tindex: j,\n\t\t\t\t\t\tgroup: i,\n\t\t\t\t\t\tcount: positions.length,\n\t\t\t\t\t\tmodel: model,\n\t\t\t\t\t\tposition: position\n\t\t\t\t\t};\n\t\t\t\t\tall.push(pos);\n\t\t\t\t\tif (model.nextModel && model.nextModel.parentGroup === i) {\n\t\t\t\t\t\tpos.ansestor = true;\n\t\t\t\t\t\tthis._getModelPositions(all, model.nextModel, (delta || 0) + positions[j].offset - positions[0].offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_getSortedPositions: function(model) {\n\t\t\tvar all = this._sortedPositions;\n\t\t\tif (!all) {\n\t\t\t\tall = [];\n\t\t\t\t// Get the root linked model\n\t\t\t\twhile (model.previousModel) {\n\t\t\t\t\tmodel = model.previousModel;\n\t\t\t\t}\n\t\t\t\t// Get all positions under model expanding group positions of stacked linked modes\n\t\t\t\tthis._getModelPositions(all, model);\n\t\t\t\t// Add escape position for all models\n\t\t\t\twhile (model) {\n\t\t\t\t\tif (typeof model.escapePosition === \"number\") { //$NON-NLS-0$\n\t\t\t\t\t\tall.push({\n\t\t\t\t\t\t\tescape: true,\n\t\t\t\t\t\t\tmodel: model,\n\t\t\t\t\t\t\tposition: {offset: model.escapePosition, length: 0}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tmodel = model.nextModel;\n\t\t\t\t}\n\t\t\t\tall.sort(function(a, b) {\n\t\t\t\t\treturn a.position.offset - b.position.offset;\n\t\t\t\t});\n\t\t\t\tthis._sortedPositions = all;\n\t\t\t}\n\t\t\treturn all;\n\t\t},\n\t\t_getPositionChanged: function(model, start, end) {\n\t\t\tvar changed;\n\t\t\tvar sortedPositions = this._getSortedPositions(model);\n\t\t\tfor (var i = sortedPositions.length - 1; i >= 0; i--) {\n\t\t\t\tif (sortedPositions[i].escape)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar position = sortedPositions[i].position;\n\t\t\t\tif (position.offset <= start && end <= position.offset + position.length) {\n\t\t\t\t\tchanged = sortedPositions[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {position: changed, positions: sortedPositions};\n\t\t},\n\t\t_updateAnnotations: function(positions) {\n\t\t\tvar annotationModel = this.editor.getAnnotationModel();\n\t\t\tif (!annotationModel) { return; }\n\t\t\tvar remove = [], add = [];\n\t\t\tvar annotations = annotationModel.getAnnotations(), annotation;\n\t\t\twhile (annotations.hasNext()) {\n\t\t\t\tannotation = annotations.next();\n\t\t\t\tswitch (annotation.type) {\n\t\t\t\t\tcase mAnnotations.AnnotationType.ANNOTATION_LINKED_GROUP:\n\t\t\t\t\tcase mAnnotations.AnnotationType.ANNOTATION_CURRENT_LINKED_GROUP:\n\t\t\t\t\tcase mAnnotations.AnnotationType.ANNOTATION_SELECTED_LINKED_GROUP:\n\t\t\t\t\t\tremove.push(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar model = this.linkedModeModel;\n\t\t\tif (model) {\n\t\t\t\tpositions = positions || this._getSortedPositions(model);\n\t\t\t\tfor (var i = 0; i < positions.length; i++) {\n\t\t\t\t\tvar position = positions[i];\n\t\t\t\t\tif (position.model !== model) { continue; }\n\t\t\t\t\tif (position.escape) { continue; }\n\t\t\t\t\tvar type = mAnnotations.AnnotationType.ANNOTATION_LINKED_GROUP;\n\t\t\t\t\tif (position.group === model.selectedGroupIndex) {\n\t\t\t\t\t\tif (position.index === 0) {\n\t\t\t\t\t\t\ttype = mAnnotations.AnnotationType.ANNOTATION_SELECTED_LINKED_GROUP;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = mAnnotations.AnnotationType.ANNOTATION_CURRENT_LINKED_GROUP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tposition = position.position;\n\t\t\t\t\tannotation = mAnnotations.AnnotationType.createAnnotation(type, position.offset, position.offset + position.length, \"\");\n\t\t\t\t\tadd.push(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotationModel.replaceAnnotations(remove, add);\n\t\t}\n\t});\n\texports.LinkedMode = LinkedMode;\n\n\treturn exports;\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/factories\", [ //$NON-NLS-0$\n\t'orion/editor/actions', //$NON-NLS-0$\n\t'orion/editor/undoStack', //$NON-NLS-0$\n\t'orion/editor/rulers', //$NON-NLS-0$\n\t'orion/editor/annotations', //$NON-NLS-0$\n\t'orion/editor/textDND', //$NON-NLS-0$\n\t'orion/editor/linkedMode', //$NON-NLS-0$\n\t'orion/util' //$NON-NLS-0$\n], function(mActions, mUndoStack, mRulers, mAnnotations, mTextDND, mLinkedMode, util) {\n\n\tvar exports = {};\n\t\n\tfunction KeyBindingsFactory() {\n\t}\n\tKeyBindingsFactory.prototype = {\n\t\tcreateKeyBindings: function(editor, undoStack, contentAssist, searcher) {\n\t\t\t// Create keybindings for generic editing, no dependency on the service model\n\t\t\tvar textActions = new mActions.TextActions(editor, undoStack , searcher);\n\t\t\t// Linked Mode\n\t\t\tvar linkedMode = new mLinkedMode.LinkedMode(editor, undoStack, contentAssist);\n\t\t\t// create keybindings for source editing\n\t\t\t// TODO this should probably be something that happens more dynamically, when the editor changes input\n\t\t\tvar sourceCodeActions = new mActions.SourceCodeActions(editor, undoStack, contentAssist, linkedMode);\n\t\t\treturn {\n\t\t\t\ttextActions: textActions,\n\t\t\t\tlinkedMode: linkedMode,\n\t\t\t\tsourceCodeActions: sourceCodeActions\n\t\t\t};\n\t\t}\n\t};\n\texports.KeyBindingsFactory = KeyBindingsFactory;\n\t\n\tfunction UndoFactory() {\n\t}\n\tUndoFactory.prototype = {\n\t\tcreateUndoStack: function(editor) {\n\t\t\tvar textView = editor.getTextView();\n\t\t\treturn new mUndoStack.UndoStack(textView, 200);\n\t\t}\n\t};\n\texports.UndoFactory = UndoFactory;\n\n\tfunction LineNumberRulerFactory() {\n\t}\n\tLineNumberRulerFactory.prototype = {\n\t\tcreateLineNumberRuler: function(annotationModel) {\n\t\t\treturn new mRulers.LineNumberRuler(annotationModel, \"left\", {styleClass: \"ruler lines\"}, {styleClass: \"rulerLines odd\"}, {styleClass: \"rulerLines even\"}); //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t}\n\t};\n\texports.LineNumberRulerFactory = LineNumberRulerFactory;\n\t\n\tfunction FoldingRulerFactory() {\n\t}\n\tFoldingRulerFactory.prototype = {\n\t\tcreateFoldingRuler: function(annotationModel) {\n\t\t\treturn new mRulers.FoldingRuler(annotationModel, \"left\", {styleClass: \"ruler folding\"}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t}\n\t};\n\texports.FoldingRulerFactory = FoldingRulerFactory;\n\t\n\tfunction ZoomRulerFactory() {\n\t}\n\tZoomRulerFactory.prototype = {\n\t\tcreateZoomRuler: function(annotationModel) {\n\t\t\treturn new mRulers.ZoomRuler(util.isIOS || util.isAndroid ? \"right\" : \"innerRight\", {styleClass: \"ruler zoom\"}); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\t}\n\t};\n\texports.ZoomRulerFactory = ZoomRulerFactory;\n\t\n\tfunction AnnotationFactory() {\n\t}\n\tAnnotationFactory.prototype = {\n\t\tcreateAnnotationModel: function(model) {\n\t\t\treturn new mAnnotations.AnnotationModel(model);\n\t\t},\n\t\tcreateAnnotationStyler: function(annotationModel, view) {\n\t\t\treturn new mAnnotations.AnnotationStyler(annotationModel, view);\n\t\t},\n\t\tcreateAnnotationRulers: function(annotationModel) {\n\t\t\tvar annotationRuler = new mRulers.AnnotationRuler(annotationModel, \"left\", {styleClass: \"ruler annotations\"}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar overviewRuler = new mRulers.OverviewRuler(annotationModel, \"right\", {styleClass: \"ruler overview\"}); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\treturn {annotationRuler: annotationRuler, overviewRuler: overviewRuler};\n\t\t}\n\t};\n\texports.AnnotationFactory = AnnotationFactory;\n\t\n\tfunction TextDNDFactory() {\n\t}\n\tTextDNDFactory.prototype = {\n\t\tcreateTextDND: function(editor, undoStack) {\n\t\t\treturn new mTextDND.TextDND(editor.getTextView(), undoStack);\n\t\t}\n\t};\n\texports.TextDNDFactory = TextDNDFactory;\n\t\n\treturn exports;\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2011, 2013 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n ******************************************************************************/\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/editorFeatures\", [ //$NON-NLS-0$\n\t'orion/editor/factories', //$NON-NLS-0$\n\t'orion/editor/actions', //$NON-NLS-0$\n\t'orion/editor/linkedMode', //$NON-NLS-0$\n\t'orion/objects' //$NON-NLS-0$\n], function(mFactories, mActions, mLinkedMode, objects) {\n\treturn objects.mixin({}, mFactories, mActions, mLinkedMode);\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2011, 2014 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/contentAssist\", [ //$NON-NLS-0$\n\t'i18n!orion/editor/nls/messages', //$NON-NLS-0$\n\t'orion/keyBinding', //$NON-NLS-0$\n\t'orion/editor/keyModes', //$NON-NLS-0$\n\t'orion/editor/eventTarget', //$NON-NLS-0$\n\t'orion/Deferred', //$NON-NLS-0$\n\t'orion/objects', //$NON-NLS-0$\n\t'orion/editor/tooltip', //$NON-NLS-0$\n\t'orion/editor/util', //$NON-NLS-0$\n\t'orion/util', //$NON-NLS-0$\n\t'orion/webui/littlelib', //$NON-NLS-0$\n\t'orion/metrics' //$NON-NLS-0$\n], function(messages, mKeyBinding, mKeyModes, mEventTarget, Deferred, objects, mTooltip, textUtil, util, lib, mMetrics) {\n\t/**\n\t * @name orion.editor.ContentAssistProvider\n\t * @class Interface defining a provider of content assist proposals.\n\t */\n\t/**\n\t * @memberOf orion.editor.ContentAssistProvider.prototype\n\t * @function\n\t * @name computeProposals\n\t * @param {String} buffer The buffer being edited.\n\t * @param {Number} offset The position in the buffer at which content assist is being requested.\n\t * @param {orion.editor.ContentAssistProvider.Context} context\n\t * @returns {Object[]} This provider's proposals for the given buffer and offset.\n\t */\n\t/**\n\t * @name orion.editor.ContentAssistProvider.Context\n\t * @class\n\t * @property {String} line The text of the line on which content assist is being requested.\n\t * @property {String} prefix Any non-whitespace, non-symbol characters preceding the offset.\n\t * @property {orion.editor.Selection} selection The current selection.\n\t */\n\n\t/**\n\t * @name orion.editor.ContentAssist\n\t * @class Provides content assist for a TextView.\n\t * @description Creates a <code>ContentAssist</code> for a TextView. A ContentAssist consults a set of \n\t * {@link orion.editor.ContentAssistProvider}s to obtain proposals for text that may be inserted into a\n\t * TextView at a given offset.<p>\n\t * A ContentAssist is generally activated by its TextView action, at which point it computes the set of \n\t * proposals available. It will re-compute the proposals in response to subsequent changes on the TextView \n\t * (for example, user typing) for as long as the ContentAssist is active. A proposal may be applied by calling \n\t * {@link #apply}, after which the ContentAssist becomes deactivated. An active ContentAssist may be deactivated\n\t * by calling {@link #deactivate}.<p>\n\t * A ContentAssist dispatches events when it becomes activated or deactivated, and when proposals have been computed.\n\t * @param {orion.editor.TextView} textView The TextView to provide content assist for.\n\t * @borrows orion.editor.EventTarget#addEventListener as #addEventListener\n\t * @borrows orion.editor.EventTarget#removeEventListener as #removeEventListener\n\t * @borrows orion.editor.EventTarget#dispatchEvent as #dispatchEvent\n\t */\n\t/**\n\t * Dispatched when a ContentAssist is about to be activated.\n\t * @name orion.editor.ContentAssist#ActivatingEvent\n\t * @event\n\t */\n\t/**\n\t * Dispatched when a ContentAssist is about to be deactivated.\n\t * @name orion.editor.ContentAssist#DeactivatingEvent\n\t * @event\n\t */\n\t/**\n\t * Dispatched when a ContentAssist has applied a proposal. <p>This event's <code>data</code> field gives information\n\t * about the proposal that was applied.\n\t * @name orion.editor.ContentAssist#ProposalAppliedEvent\n\t * @event\n\t */\n\t/**\n\t * Dispatched whenever a ContentAssist has obtained proposals from its providers. <p>This event's\n\t * <code>data</code> field gives information about the proposals.\n\t * @name orion.editor.ContentAssist#ProposalsComputedEvent\n\t * @event\n\t */\n\t\t\n\t// INACTIVE --Ctrl+Space--> ACTIVE --ModelChanging--> FILTERING\n\tvar State = {\n\t\tINACTIVE: 1,\n\t\tACTIVE: 2,\n\t\tFILTERING: 3\n\t};\n\t\n\tvar STYLES = {\n\t\tselected : \"selected\", //$NON-NLS-0$\n\t\thr : \"proposal-hr\", //$NON-NLS-0$\n\t\temphasis : \"proposal-emphasis\", //$NON-NLS-0$\n\t\tnoemphasis : \"proposal-noemphasis\", //$NON-NLS-0$\n\t\tnoemphasis_keyword : \"proposal-noemphasis-keyword\", //$NON-NLS-0$\n\t\tnoemphasis_title : \"proposal-noemphasis-title\", //$NON-NLS-0$\n\t\tnoemphasis_title_keywords : \"proposal-noemphasis-title-keywords\", //$NON-NLS-0$\n\t\tdfault : \"proposal-default\" //$NON-NLS-0$\n\t};\n\t\n\tfunction ContentAssist(textView) {\n\t\tthis.textView = textView;\n\t\tthis.state = State.INACTIVE;\n\t\tthis.clearProviders();\n\t\tvar self = this;\n\t\tthis._textViewListeners = {\n\t\t\tonModelChanging: (function(event) {\n\t\t\t\tthis._latestModelChangingEvent = event;\n\t\t\t\tif (event) {\n\t\t\t\t\tthis._updateFilterText(event);\t\n\t\t\t\t}\n\t\t\t}).bind(this),\n\t\t\tonSelection: (function(event) {\n\t\t\t\tif (this.isDeactivatingChange(this._latestModelChangingEvent, event)) {\n\t\t\t\t\tthis.setState(State.INACTIVE);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.isActive()) {\n\t\t\t\t\t\tif (this.state === State.ACTIVE) {\n\t\t\t\t\t\t\tthis.setState(State.FILTERING);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.filterProposals();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._latestModelChangingEvent = null;\n\t\t\t}).bind(this),\n\t\t\tonScroll: (function(event) {\n\t\t\t\tthis.setState(State.INACTIVE);\n\t\t\t}).bind(this)\n\t\t};\n\t\t\n\t\ttextView.setKeyBinding(util.isMac ? new mKeyBinding.KeyBinding(' ', false, false, false, true) : new mKeyBinding.KeyBinding(' ', true), \"contentAssist\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\ttextView.setKeyBinding(util.isMac ? new mKeyBinding.KeyBinding(' ', false, false, true, true) : new mKeyBinding.KeyBinding(' ', true, false, true), \"contentAssist\"); //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\t\ttextView.setAction(\"contentAssist\", function() { //$NON-NLS-0$\n\t\t\tif (!textView.getOptions(\"readonly\")) { //$NON-NLS-0$\n\t\t\t\tself.activate();\n\t\t\t}\n\t\t\treturn true;\n\t\t}, {name: messages.contentAssist});\n\t}\n\tContentAssist.prototype = /** @lends orion.editor.ContentAssist.prototype */ {\n\t\t/**\n\t\t * Applies the given proposal to the TextView.\n\t\t * @param {Object} [proposal]\n\t\t * @returns {Boolean} <code>true</code> if the proposal was applied; <code>false</code> if no proposal was provided.\n\t\t */\n\t\tapply: function(proposal) {\n\t\t\tif (!proposal) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\t// now handle prefixes\n\t\t\t// if there is a non-empty selection, then replace it,\n\t\t\t// if overwrite is truthy, then also replace the prefix\n\t\t\tvar view = this.textView;\n\t\t\tvar sel = view.getSelection();\n\t\t\tvar start = this._initialCaretOffset;\n\t\t\tvar mapStart = start;\n\t\t\tvar end = Math.max(sel.start, sel.end), mapEnd = end;\n\t\t\tvar model = view.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tmapStart = model.mapOffset(mapStart);\n\t\t\t\tmapEnd = model.mapOffset(mapEnd);\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\t\n\t\t\tif (proposal.overwrite) {\n\t\t\t    if(typeof proposal.prefix === 'string') {\n\t\t\t        start = mapStart-proposal.prefix.length;\n\t\t\t    } else {\n\t\t\t\t    start = this.getPrefixStart(model, mapStart);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar data = {\n\t\t\t\tproposal: proposal,\n\t\t\t\tstart: mapStart,\n\t\t\t\tend: mapEnd\n\t\t\t};\n\t\t\tthis.setState(State.INACTIVE);\n\t\t\tvar proposalText = typeof proposal === \"string\" ? proposal : proposal.proposal; //$NON-NLS-0$\n\t\t\tview.setText(proposalText, start, end);\n\t\t\tif (proposal.additionalEdits) {\n\t\t\t\tvar edit;\n\t\t\t\tfor (var i = 0; i < proposal.additionalEdits.length; i++) {\n\t\t\t\t\tedit = proposal.additionalEdits[i];\n\t\t\t\t\tview.setText(edit.text, edit.offset, edit.offset + edit.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.dispatchEvent({type: \"ProposalApplied\", data: data}); //$NON-NLS-0$\n\t\t\tmMetrics.logEvent(\"contentAssist\", \"apply\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\treturn true;\n\t\t},\n\t\tactivate: function(providers, autoTriggered) {\n\t\t\tif (this.state === State.INACTIVE) {\n\t\t\t\tmMetrics.logEvent(\"contentAssist\", \"activate\", undefined, autoTriggered ? 0 : 1); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\tthis._autoTriggered = autoTriggered ? true : false;\n\t\t\t\tthis.setState(State.ACTIVE, providers);\n\t\t\t}\n\t\t},\n\t\tdeactivate: function() {\n\t\t\tthis.setState(State.INACTIVE);\n\t\t},\n\t\t/** @returns {orion.editor.TextView} */\n\t\tgetTextView: function() {\n\t\t\treturn this.textView;\n\t\t},\n\t\t/** @returns {Boolean} */\n\t\tisActive: function() {\n\t\t\treturn this.state === State.ACTIVE || this.state === State.FILTERING;\n\t\t},\n\t\t/** @returns {Boolean} <code>true</code> if the event describes a change that should deactivate content assist. */\n\t\tisDeactivatingChange: function(/**orion.editor.ModelChangingEvent*/ event, selectionEvent) {\n\t\t\tvar isDeactivating = false;\n\t\t\t\n\t\t\tvar selections = Array.isArray(selectionEvent.newValue) ? selectionEvent.newValue : [selectionEvent.newValue];\n\t\t\tvar isPriorToInitialCaretOffset = selections[0].start < this._initialCaretOffset;\n\t\t\t\n\t\t\tif (isPriorToInitialCaretOffset || !event) {\n\t\t\t\tisDeactivating = true;\n\t\t\t} else if (event) {\n\t\t\t\tisDeactivating = (event.removedLineCount > 0) || (event.addedLineCount > 0);\n\t\t\t}\n\t\t\t\n\t\t\treturn isDeactivating;\n\t\t},\n\t\t/** @private */\n\t\tsetState: function(state, /* Optional. Array of providers to pass to dispatched event.*/ providers) {\n\t\t\tvar eventType;\n\t\t\tif (state === State.ACTIVE) {\n\t\t\t\teventType = \"Activating\"; //$NON-NLS-0$\n\t\t\t\tif (this._mode) { this._mode.setActive(true); }\n\t\t\t} else if (state === State.INACTIVE) {\n\t\t\t\teventType = \"Deactivating\"; //$NON-NLS-0$\n\t\t\t\tif (this._mode) { this._mode.setActive(false); }\n\t\t\t}\n\t\t\tif (eventType) {\n\t\t\t\tthis.dispatchEvent({type: eventType, providers: providers});\n\t\t\t}\n\t\t\tthis.state = state;\n\t\t\tthis.onStateChange(state);\n\t\t},\n\t\tsetMode: function(mode) {\n\t\t\tthis._mode = mode;\n\t\t},\n\t\t/** @private */\n\t\tonStateChange: function(state) {\n\t\t\tif (state === State.INACTIVE) {\n\t\t\t\tthis._removeTextViewListeners();\n\t\t\t\tthis._filterText = \"\";\n\t\t\t\tthis._initialCaretOffset = -1;\n\t\t\t\tthis._computedProposals = null;\n\t\t\t} else if (state === State.ACTIVE) {\n\t\t\t\tthis._filterText = \"\";\n\t\t\t\tthis._addTextViewListeners();\n\t\t\t\tthis.computeProposals();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Computes the proposals at the TextView's current caret offset.\n\t\t */\n\t\tcomputeProposals: function() {\n\t\t\t// figure out initial offset, it should be the minimum between \n\t\t\t// the beginning of the selection and the current caret offset\n\t\t\tvar offset = this.textView.getCaretOffset();\n\t\t\tvar sel = this.textView.getSelection();\n\t\t\tvar selectionStart = Math.min(sel.start, sel.end);\t\t\t\n\t\t\tthis._initialCaretOffset = Math.min(offset, selectionStart);\n\t\t\tthis._computedProposals = null;\n\t\t\t\n\t\t\tthis._computeProposals(this._initialCaretOffset).then(function(proposals) {\n\t\t\t\tif (this.isActive()) {\n\t\t\t\t\tvar flatProposalArray = this._flatten(proposals);\n\t\t\t\t\t//check if flattened proposals form a valid array with at least one entry\n\t\t\t\t\tif (flatProposalArray && Array.isArray(flatProposalArray) && (0 < flatProposalArray.length)) {\n\t\t\t\t\t\tthis._computedProposals = proposals;\n\t\t\t\t\t}\n\t\t\t\t\tthis.dispatchEvent({type: \"ProposalsComputed\", data: {proposals: flatProposalArray}, autoApply: !this._autoTriggered}); //$NON-NLS-0$\n\t\t\t\t\tif (this._computedProposals && this._filterText) {\n\t\t\t\t\t\t// force filtering here because user entered text after\n\t\t\t\t\t\t// computeProposals() was called but before the plugins\n\t\t\t\t\t\t// returned the computed proposals\n\t\t\t\t\t\tthis.filterProposals(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t},\n\t\t/** @private */\n\t\tgetPrefixStart: function(model, end) {\n\t\t\tvar index = end;\n\t\t\twhile (index > 0 && /[A-Za-z0-9_]/.test(model.getText(index - 1, index))) {\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\treturn index;\n\t\t},\n\t\thandleError: function(error) {\n\t\t\tif (typeof console !== \"undefined\") { //$NON-NLS-0$\n\t\t\t\tconsole.log(\"Error retrieving content assist proposals\"); //$NON-NLS-0$\n\t\t\t\tconsole.log(error && error.stack);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Initializes the providers. A provider must define an <tt>initialize()</tt> method to be initialized.\n\t\t * @since 6.0\n\t\t */\n\t\tinitialize: function() {\n\t\t\tthis._providers.forEach(function(info) {\n\t\t\t\tvar provider = info.provider;\n\t\t\t\tif (typeof provider.initialize === \"function\") {//$NON-NLS-0$\n\t\t\t\t\tprovider.initialize();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Retrieves the proposals at the given offset.\n\t\t * @private\n\t\t * @param {Number} offset The caret offset.\n\t\t * @returns {Deferred} A promise that will provide the proposals.\n\t\t */\n\t\t_computeProposals: function(offset) {\n\t\t\tvar providerInfoArray = this._providers;\n\t\t\tvar textView = this.textView;\n\t\t\tvar sel = textView.getSelection();\n\t\t\tvar model = textView.getModel(), mapOffset = offset;\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tmapOffset = model.mapOffset(mapOffset);\n\t\t\t\tsel.start = model.mapOffset(sel.start);\n\t\t\t\tsel.end = model.mapOffset(sel.end);\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\tvar line = model.getLine(model.getLineAtOffset(mapOffset));\n\t\t\tvar index = 0;\n\t\t\twhile (index < line.length && /\\s/.test(line.charAt(index))) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tvar indentation = line.substring(0, index);\n\t\t\tvar options = textView.getOptions(\"tabSize\", \"expandTab\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar tab = options.expandTab ? new Array(options.tabSize + 1).join(\" \") : \"\\t\"; //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tvar params = {\n\t\t\t\tline: line,\n\t\t\t\toffset: mapOffset,\n\t\t\t\tprefix: model.getText(this.getPrefixStart(model, mapOffset), mapOffset),\n\t\t\t\tselection: sel,\n\t\t\t\tdelimiter: model.getLineDelimiter(),\n\t\t\t\ttab: tab,\n\t\t\t\tindentation: indentation\n\t\t\t};\n\t\t\tvar self = this;\n\t\t\tvar promises = providerInfoArray.map(function(providerInfo) {\n\t\t\t\tvar provider = providerInfo.provider;\n\t\t\t\tvar proposals;\n\t\t\t\ttry {\n\t\t\t\t\tvar func, promise;\n\t\t\t\t\tif ((func = provider.computeContentAssist)) {\n\t\t\t\t\t\tvar ecProvider = self.editorContextProvider, editorContext = ecProvider.getEditorContext();\n\t\t\t\t\t\tparams = objects.mixin(params, ecProvider.getOptions());\n\t\t\t\t\t\tpromise = func.apply(provider, [editorContext, params]);\n\t\t\t\t\t} else if ((func = provider.getProposals || provider.computeProposals)) {\n\t\t\t\t\t\t// old API\n\t\t\t\t\t\tpromise = func.apply(provider, [model.getText(), mapOffset, params]);\n\t\t\t\t\t}\n\t\t\t\t\tproposals = self.progress ? self.progress.progress(promise, \"Generating content assist proposal\") : promise; //$NON-NLS-0$\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn new Deferred().reject(e);\n\t\t\t\t}\n\t\t\t\treturn Deferred.when(proposals);\n\t\t\t});\n\t\t\t// TODO should we allow error to propagate instead of handling here?\n\t\t\treturn Deferred.all(promises, this.handleError);\n\t\t},\n\n\t\tfilterProposals: function(force) {\n\t\t\tif (this._computedProposals && (this._latestModelChangingEvent || force)) {\n\t\t\t\tvar model = this.textView.getModel();\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tmodel = model.getBaseModel();\n\t\t\t\t}\n\t\t\t\tvar prefixStart = this.getPrefixStart(model, this._initialCaretOffset);\n\t\t\t\tvar defaultPrefix = this.textView.getText(prefixStart, this._initialCaretOffset);\n\t\t\t\tvar prefixText = defaultPrefix;\n\t\t\t\t// filter proposals based on prefixes and _filterText\n\t\t\t\tvar proposals = []; //array of arrays of proposals\n\t\t\t\tthis._computedProposals.forEach(function(proposalArray) {\n\t\t\t\t\tif (proposalArray && Array.isArray(proposalArray)) {\n\t\t\t\t\t\tvar includedProposals = proposalArray.filter(function(proposal) {\n\t\t\t\t\t\t\tif (!proposal) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(typeof proposal.prefix === 'string') {\n\t\t\t\t\t\t\t    prefixText = proposal.prefix;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t    prefixText = defaultPrefix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((STYLES[proposal.style] === STYLES.hr)\n\t\t\t\t\t\t\t\t|| (STYLES[proposal.style] === STYLES.noemphasis_title)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar proposalString = \"\";\n\t\t\t\t\t\t\tif (proposal.overwrite) {\n\t\t\t\t\t\t\t\tif (proposal.name) {\n\t\t\t\t\t\t\t\t\tproposalString = proposal.name;\n\t\t\t\t\t\t\t\t} else if (proposal.proposal) {\n\t\t\t\t\t\t\t\t\tproposalString = proposal.proposal;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn false; // unknown format\n\t\t\t\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t\t\t\treturn (0 === proposalString.indexOf(prefixText + this._filterText));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else if (proposal.name || proposal.proposal) {\n\t\t\t\t\t\t\t\tvar activated = false;\n\t\t\t\t\t\t\t\t// try matching name\n\t\t\t\t\t\t\t\tif (proposal.name) {\n\t\t\t\t\t\t\t\t\tactivated = (0 === proposal.name.indexOf(prefixText + this._filterText));\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// try matching proposal text\n\t\t\t\t\t\t\t\tif (!activated && proposal.proposal) {\n\t\t\t\t\t\t\t\t\tactivated = (0 === proposal.proposal.indexOf(this._filterText));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn activated;\n\t\t\t\t\t\t\t} else if (typeof proposal === \"string\") { //$NON-NLS-0$\n\t\t\t\t\t\t\t\treturn 0 === proposal.indexOf(this._filterText);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (includedProposals.length > 0) {\n\t\t\t\t\t\t\tproposals.push(includedProposals);\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\t\t\t\t\n\t\t\t\tvar flatProposalArray = [];\n\t\t\t\tif (proposals) {\n\t\t\t\t\t// filter out extra separators and titles\n\t\t\t\t\tproposals = this._removeExtraUnselectableElements(proposals);\n\t\t\t\t\tflatProposalArray = this._flatten(proposals);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.dispatchEvent({type: \"ProposalsComputed\", data: {proposals: flatProposalArray}, autoApply: false}); //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper method which removes extra separators and titles from\n\t\t * an array containing arrays of proposals from the various providers.\n\t\t * @param{Array[]} proposals An array with each element containing an array of proposals\n\t\t * @returns {Array} An array without the extra unselectable elements\n\t\t */\n\t\t_removeExtraUnselectableElements: function(proposals) {\n\t\t\t// get rid of extra separators and titles\n\t\t\tvar mappedProposals = proposals.map(function(proposalArray) {\n\t\t\t\tvar element = proposalArray.filter(function(proposal, index) {\n\t\t\t\t\tvar keepElement = true;\n\t\t\t\t\tif (STYLES[proposal.style] === STYLES.hr) {\n\t\t\t\t\t\tif ((0 === index) || ((proposalArray.length - 1) === index)) {\n\t\t\t\t\t\t\tkeepElement = false; // remove separators at first or last element\n\t\t\t\t\t\t} else if (STYLES.hr === STYLES[proposalArray[index - 1].style]) {\n\t\t\t\t\t\t\tkeepElement = false; // remove separator preceeded by another separator\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (STYLES[proposal.style] === STYLES.noemphasis_title) {\n\t\t\t\t\t\tvar nextProposal = proposalArray[index + 1];\n\t\t\t\t\t\tif (nextProposal) {\n\t\t\t\t\t\t\t// remove titles that preceed other titles, all of their subelements have already been filtered out\n\t\t\t\t\t\t\tif (STYLES[nextProposal.style] === STYLES.noemphasis_title) {\n\t\t\t\t\t\t\t\tkeepElement = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tkeepElement = false; //remove titles that are at the end of the array\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn keepElement;\n\t\t\t\t});\n\t\t\t\treturn element;\n\t\t\t});\n\t\t\t\n\t\t\treturn mappedProposals;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets the provider that will be invoked to generate the Editor Context service and options to any\n\t\t * content assist providers that implement the v4.0 content assist API.\n\t\t * @param {Object} editorContextProvider\n\t\t */\n\t\tsetEditorContextProvider: function(editorContextProvider) {\n\t\t\tthis.editorContextProvider = editorContextProvider;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper method used to generate a unique ID for a provider.\n\t\t * Note that the uniqueness of the ID is only guaranteed for the life of this\n\t\t * object and if all of the other IDs are also generated using this method.\n\t\t */\n\t\t_generateProviderId: function() {\n\t\t\tif (this._idcount) {\n\t\t\t\tthis._idcount++;\n\t\t\t} else {\n\t\t\t\tthis._idcount = 0;\n\t\t\t}\n\t\t\treturn \"ContentAssistGeneratedID_\" +  this._idcount; //$NON-NLS-0$\n\t\t},\n\n\t\t/**\n\t\t * Sets whether or not automatic content assist triggering is enabled.\n\t\t * @param {Boolean} enableAutoTrigger\n\t\t */\n\t\tsetAutoTriggerEnabled: function(enableAutoTrigger) {\n\t\t\tthis._autoTriggerEnabled = enableAutoTrigger;\n\t\t\tthis._updateAutoTriggerListenerState();\n\t\t},\n\n\t\t/**\n\t\t * @name orion.editor.ContentAssistProviderInfo\n\t\t * @class Encapsulates a content assist provider and its automatic triggers.\n\t\t *\n\t\t * @property {String} id Unique ID of this provider.\n\t\t * @property {RegExp} charTriggers A regular expression matching the characters that, when typed,\n\t\t * will cause this provider to be activated automatically by the content assist engine.\n\t\t * @property {RegExp} excludedStyles A regular expression matching the style names that are\n\t\t * exclusions to this provider's <tt>charTriggers</tt> matching.\n\t\t * @property {orion.editor.ContentAssistProvider} provider The actual content assist provider.\n\t\t */\n\n\t\t/**\n\t\t * Sets the content assist providers that this ContentAssist will consult to obtain proposals.\n\t\t *\n\t\t * @param {orion.editor.ContentAssistProvider[]|orion.edit.ContentAssistProviderInfo[]} providers The\n\t\t * providers. Each element may be either a plain {@link orion.editor.ContentAssistProvider}, or a\n\t\t * {@link orion.edit.ContentAssistProviderInfo}.\n\t\t */\n\t\tsetProviders: function(providers) {\n\t\t\tvar _self = this;\n\t\t\tthis.setProviderInfoArray(providers.map(function(p) {\n\t\t\t\t// Wrap any plain Provider into a ProviderInfo\n\t\t\t\treturn p.id ? p : {\n\t\t\t\t\tprovider: p,\n\t\t\t\t\tid: _self._generateProviderId()\n\t\t\t\t};\n\t\t\t}));\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tsetProviderInfoArray: function(providerInfoArray) {\n\t\t\tthis.clearProviders();\n\t\t\t\n\t\t\tthis._providers = providerInfoArray;\n\t\t\tthis._charTriggersInstalled = providerInfoArray.some(function(info){\n\t\t\t\treturn info.charTriggers;\n\t\t\t});\n\t\t\tthis._updateAutoTriggerListenerState();\n\t\t},\n\n\t\t/**\n\t\t * @returns orion.edit.ContentAssistProviderInfo[]\n\t\t */\n\t\tgetProviders: function() {\n\t\t\treturn this._providers.slice();\n\t\t},\n\n\t\tclearProviders: function() {\n\t\t\tthis._providers = [];\n\t\t\tthis._charTriggersInstalled = false;\n\t\t\tthis._updateAutoTriggerListenerState();\n\t\t},\n\n\t\t/**\n\t\t * Sets the progress handler that will display progress information, if any are generated by content assist providers.\n\t\t */\n\t\tsetProgress: function(progress){\n\t\t\tthis.progress = progress;\n\t\t},\n\t\t\n\t\tsetStyleAccessor: function(styleAccessor) {\n\t\t\tthis._styleAccessor = styleAccessor;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Flattens an array of arrays into a one-dimensional array.\n\t\t * @param {Array[]} array\n\t\t * @returns {Array}\n\t\t */\n\t\t_flatten: function(arrayOrObjectArray) {\n\t\t\t\n\t\t\treturn arrayOrObjectArray.reduce(function(prev, curr) {\n\t\t\t\tvar returnValue = prev;\n\t\t\t\tvar filteredArray = null;\n\t\t\t\t\n\t\t\t\tif (curr && Array.isArray(curr)) {\n\t\t\t\t\tfilteredArray = curr.filter(function(element){\n\t\t\t\t\t\treturn element; //filter out falsy elements\n\t\t\t\t\t});\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// add current proposal array to flattened array\n\t\t\t\t// skip current elements that are not arrays\n\t\t\t\tif (filteredArray && Array.isArray(filteredArray) && (filteredArray.length > 0)) {\n\t\t\t\t\tvar first = filteredArray;\n\t\t\t\t\tvar last = prev;\n\t\t\t\t\tvar filteredArrayStyle = filteredArray[0].style;\n\t\t\t\t\t\n\t\t\t\t\tif (filteredArrayStyle && STYLES[filteredArrayStyle] && (0 === STYLES[filteredArrayStyle].indexOf(STYLES.noemphasis))) {\n\t\t\t\t\t\t// the style of the first element starts with noemphasis\n\t\t\t\t\t\t// add these proposals to the end of the array\n\t\t\t\t\t\tfirst = prev;\n\t\t\t\t\t\tlast = filteredArray;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (first.length > 0) {\n\t\t\t\t\t\tvar firstArrayStyle = first[first.length - 1].style;\n\t\t\t\t\t\tif (firstArrayStyle && (STYLES.hr !== STYLES[firstArrayStyle])) {\n\t\t\t\t\t\t\t// add separator between proposals from different providers \n\t\t\t\t\t\t\t// if the previous array didn't already end with a separator\n\t\t\t\t\t\t\tfirst = first.concat({\n\t\t\t\t\t\t\t\tproposal: '',\n\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\tdescription: '---------------------------------', //$NON-NLS-0$\n\t\t\t\t\t\t\t\tstyle: 'hr', //$NON-NLS-0$\n\t\t\t\t\t\t\t\tunselectable: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturnValue = first.concat(last);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn returnValue;\n\t\t\t}, []);\n\t\t},\n\t\t\n\t\t_triggerListener: function(/*event*/) {\n\t\t\tvar caretOffset = this.textView.getCaretOffset();\n\t\t\tvar stylesAtOffset = null;\n\t\t\tvar providerInfosToActivate = [];\n\n\t\t\tif (this._charTriggersInstalled) {\n\t\t\t\tvar currentChar = this.textView.getText(caretOffset - 1, caretOffset);\n\n\t\t\t\tthis._providers.forEach(function(info) {\n\t\t\t\t\t// check if the charTriggers RegExp matches the currentChar\n\t\t\t\t\t// we're assuming that this will fail much more often than\n\t\t\t\t\t// the excludedStyles test so do this first for better performance\n\t\t\t\t\tvar charTriggers = info.charTriggers;\n\t\t\t\t\tif (charTriggers && charTriggers.test(currentChar)) {\n\t\t\t\t\t\tvar isExcluded = false;\n\t\t\t\t\t\tvar excludedStyles = info.excludedStyles;\n\t\t\t\t\t\tif (this._styleAccessor && excludedStyles) {\n\t\t\t\t\t\t\tif (!stylesAtOffset) {\n\t\t\t\t\t\t\t\t// lazily initialize this variable to avoid getting the styles\n\t\t\t\t\t\t\t\t// for every model modification, only ones that may trigger\n\t\t\t\t\t\t\t\tstylesAtOffset = this._styleAccessor.getStyles(caretOffset - 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// check if any of the styles match the excludedStyles RegExp\n\t\t\t\t\t\t\tisExcluded = stylesAtOffset.some(function (element) {\n\t\t\t\t\t\t\t\treturn excludedStyles.test(element.style);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isExcluded) {\n\t\t\t\t\t\t\tproviderInfosToActivate.push(info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\n\t\t\t\tif (providerInfosToActivate.length > 0) {\n\t\t\t\t\tthis.activate(providerInfosToActivate, true);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Private helper to install/uninstall the automatic trigger\n\t\t * listener based on the state of the relevant booleans\n\t\t */\n\t\t_updateAutoTriggerListenerState: function() {\n\t\t\tif (!this._boundTriggerListener) {\n\t\t\t\tthis._boundTriggerListener = this._triggerListener.bind(this);\n\t\t\t}\n\t\t\t\n\t\t\tif (this._triggerListenerInstalled) {\n\t\t\t\t// uninstall the listener if necessary\n\t\t\t\tif (!this._autoTriggerEnabled || !this._charTriggersInstalled) {\n\t\t\t\t\tthis.textView.removeEventListener(\"Modify\", this._boundTriggerListener); //$NON-NLS-0$\n\t\t\t\t\tthis._triggerListenerInstalled = false;\n\t\t\t\t}\n\t\t\t} else if (this._autoTriggerEnabled && this._charTriggersInstalled){\n\t\t\t\t// install the listener if necessary\n\t\t\t\tthis.textView.addEventListener(\"Modify\", this._boundTriggerListener); //$NON-NLS-0$\n\t\t\t\tthis._triggerListenerInstalled = true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t_addTextViewListeners: function() {\n\t\t\tif (!this._textViewListenersAdded) {\n\t\t\t\tthis.textView.addEventListener(\"ModelChanging\", this._textViewListeners.onModelChanging); //$NON-NLS-0$\n\t\t\t\tthis.textView.addEventListener(\"Scroll\", this._textViewListeners.onScroll); //$NON-NLS-0$\n\t\t\t\tthis.textView.addEventListener(\"Selection\", this._textViewListeners.onSelection); //$NON-NLS-0$\n\t\t\t\tthis._textViewListenersAdded = true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t_removeTextViewListeners: function() {\n\t\t\tif (this._textViewListenersAdded) {\n\t\t\t\tthis._latestModelChangingEvent = null;\n\t\t\t\tthis.textView.removeEventListener(\"ModelChanging\", this._textViewListeners.onModelChanging); //$NON-NLS-0$\n\t\t\t\tthis.textView.removeEventListener(\"Scroll\", this._textViewListeners.onScroll); //$NON-NLS-0$\n\t\t\t\tthis.textView.removeEventListener(\"Selection\", this._textViewListeners.onSelection); //$NON-NLS-0$\n\t\t\t\tthis._textViewListenersAdded = false;\n\t\t\t}\n\t\t},\n\t\t\n\t\t_updateFilterText: function(modelChangingEvent) {\n\t\t\t// update this._filterText based on the modification info\n\t\t\t// contained in the event\n\t\t\tvar removedCharCount = modelChangingEvent.removedCharCount;\n\t\t\tif (removedCharCount) {\n\t\t\t\tvar lastIndex = this._filterText.length - removedCharCount;\n\t\t\t\tthis._filterText = this._filterText.substring(0, lastIndex);\n\t\t\t}\n\t\t\tvar text = modelChangingEvent.text;\n\t\t\tif (text) {\n\t\t\t\tthis._filterText = this._filterText.concat(text);\n\t\t\t}\n\t\t}\n\t};\n\tmEventTarget.EventTarget.addMixin(ContentAssist.prototype);\n\n\t/**\n\t * @name orion.editor.ContentAssistMode\n\t * @class Editor mode for interacting with content assist proposals.\n\t * @description Creates a ContentAssistMode. A ContentAssistMode is a key mode for {@link orion.editor.Editor}\n\t * that provides interaction with content assist proposals retrieved from an {@link orion.editor.ContentAssist}. \n\t * Interaction is performed via the {@link #lineUp}, {@link #lineDown}, and {@link #enter} actions. An \n\t * {@link orion.editor.ContentAssistWidget} may optionally be provided to display which proposal is currently selected.\n\t * @param {orion.editor.ContentAssist} contentAssist\n\t * @param {orion.editor.ContentAssistWidget} [ContentAssistWidget]\n\t */\n\tfunction ContentAssistMode(contentAssist, ContentAssistWidget) {\n\t\tvar textView = contentAssist.textView;\n\t\tmKeyModes.KeyMode.call(this, textView);\n\t\tthis.contentAssist = contentAssist;\n\t\tthis.widget = ContentAssistWidget;\n\t\tthis.proposals = [];\n\t\tvar self = this;\n\t\tthis.contentAssist.addEventListener(\"ProposalsComputed\", function(event) { //$NON-NLS-0$\n\t\t\tself.proposals = event.data.proposals;\n\t\t\tif (self.proposals.length === 0) {\n\t\t\t\tself.selectedIndex = -1;\n\t\t\t\tself.cancel();\n\t\t\t} else {\n\t\t\t\tself.selectedIndex = 0;\n\t\t\t\twhile(self.proposals[self.selectedIndex] && self.proposals[self.selectedIndex].unselectable) {\n\t\t\t\t\tself.selectedIndex++;\n\t\t\t\t}\n\t\t\t\tif (self.proposals[self.selectedIndex]) {\n\t\t\t\t\tif (self.widget) {\n\t\t\t\t\t\tvar showWidget = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (event.autoApply) {\n\t\t\t\t\t\t\tvar nextIndex = self.selectedIndex + 1;\n\t\t\t\t\t\t\twhile (self.proposals[nextIndex] && self.proposals[nextIndex].unselectable) {\n\t\t\t\t\t\t\t\tnextIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!self.proposals[nextIndex]) {\n\t\t\t\t\t\t\t\t// if there is only one selectable proposal apply it automatically\n\t\t\t\t\t\t\t\tshowWidget = false;\n\t\t\t\t\t\t\t\tself.contentAssist.apply(self.proposals[self.selectedIndex]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (showWidget) {\n\t\t\t\t\t\t\tself.widget.show();\n\t\t\t\t\t\t\tself.widget.selectNode(self.selectedIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tself.selectedIndex = -1; // didn't find any selectable items\n\t\t\t\t\tself.cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttextView.setAction(\"contentAssistApply\", function() { //$NON-NLS-0$\n\t\t\treturn this.enter();\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistCancel\", function() { //$NON-NLS-0$\n\t\t\treturn this.cancel();\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistNextProposal\", function() { //$NON-NLS-0$\n\t\t\treturn this.lineDown();\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistPreviousProposal\", function() { //$NON-NLS-0$\n\t\t\treturn this.lineUp();\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistNextPage\", function() { //$NON-NLS-0$\n\t\t\treturn this.pageDown();\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistPreviousPage\", function() { //$NON-NLS-0$\n\t\t\treturn this.pageUp();\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistHome\", function() { //$NON-NLS-0$\n\t\t\tif (this.widget) {\n\t\t\t\tthis.widget.scrollIndex(0, true);\n\t\t\t}\n\t\t\treturn this.lineDown(0); // select first selectable element starting at the top and moving downwards\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistEnd\", function() { //$NON-NLS-0$\n\t\t\treturn this.lineUp(this.proposals.length - 1); // select first selectable element starting at the bottom and moving up\n\t\t}.bind(this));\n\t\ttextView.setAction(\"contentAssistTab\", function() { //$NON-NLS-0$\n\t\t\treturn this.tab();\n\t\t}.bind(this));\n\t\t\n\t\tif (this.widget) {\n\t\t\tthis.widget.setContentAssistMode(this);\n\t\t\tthis.widget.createAccessible();\n\t\t}\n\t}\n\tContentAssistMode.prototype = new mKeyModes.KeyMode();\n\tobjects.mixin(ContentAssistMode.prototype, {\n\t\tcreateKeyBindings: function() {\n\t\t\tvar KeyBinding = mKeyBinding.KeyBinding;\n\t\t\tvar bindings = [];\n\t\t\tbindings.push({actionID: \"contentAssistApply\", keyBinding: new KeyBinding(13)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistCancel\", keyBinding: new KeyBinding(27)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistNextProposal\", keyBinding: new KeyBinding(40)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistPreviousProposal\", keyBinding: new KeyBinding(38)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistNextPage\", keyBinding: new KeyBinding(34)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistPreviousPage\", keyBinding: new KeyBinding(33)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistHome\", keyBinding: new KeyBinding(lib.KEY.HOME)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistEnd\", keyBinding: new KeyBinding(lib.KEY.END)}); //$NON-NLS-0$\n\t\t\tbindings.push({actionID: \"contentAssistTab\", keyBinding: new KeyBinding(9)}); //$NON-NLS-0$\n\t\t\treturn bindings;\n\t\t},\n\t\tcancel: function() {\n\t\t\tthis.getContentAssist().deactivate();\n\t\t},\n\t\t/** @private */\n\t\tgetContentAssist: function() {\n\t\t\treturn this.contentAssist;\n\t\t},\n\t\tgetProposals: function() {\n\t\t\treturn this.proposals;\t\n\t\t},\n\t\tisActive: function() {\n\t\t\treturn this.getContentAssist().isActive();\n\t\t},\n\t\tsetActive: function(active) {\n\t\t\tif (active) {\n\t\t\t\tthis.contentAssist.textView.addKeyMode(this);\n\t\t\t} else {\n\t\t\t\tthis.contentAssist.textView.removeKeyMode(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Selects a selectable item in the content assist widget\n\t\t * iterating backwards for .\n\t\t * \n\t\t * @param index {number} Optional. The index of the item to try and select. \n\t\t */\n\t\tlineUp: function(index, noWrap) {\n\t\t\treturn this.selectNew(index, noWrap, false);\n\t\t},\n\t\t/**\n\t\t * Selects the item at the specified index or the next\n\t\t * selectable item\n\t\t */\n\t\tlineDown: function(index, noWrap) {\n\t\t\treturn this.selectNew(index, noWrap, true);\n\t\t},\n\t\tselectNew: function(index, noWrap, forward) {\n\t\t\tvar newIndex = index;\n\t\t\t\n\t\t\tif (forward) {\n\t\t\t\tif (undefined === newIndex) {\n\t\t\t\t\tnewIndex = this.selectedIndex + 1;\n\t\t\t\t}\n\t\t\t\t// handle wrap around\n\t\t\t\tif (newIndex >= this.proposals.length) {\n\t\t\t\t\tif (noWrap) {\n\t\t\t\t\t\treturn true; // do nothing\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewIndex = 0;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (undefined === newIndex) {\n\t\t\t\t\tnewIndex = this.selectedIndex - 1;\n\t\t\t\t}\n\t\t\t\t// handle wrap around\n\t\t\t\tif (0 > newIndex) {\n\t\t\t\t\tif (noWrap) {\n\t\t\t\t\t\treturn true; // do nothing\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewIndex = this.proposals.length - 1;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar startIndex = newIndex;\n\t\t\twhile (this.proposals[newIndex] && this.proposals[newIndex].unselectable) {\n\t\t\t\tif (forward) {\n\t\t\t\t\tnewIndex++;\n\t\t\t\t\t// handle wrap around\n\t\t\t\t\tif (newIndex >= this.proposals.length) {\n\t\t\t\t\t\tif (noWrap) {\n\t\t\t\t\t\t\treturn true; // do nothing\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewIndex = 0;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewIndex--;\n\t\t\t\t\t// handle wrap around\n\t\t\t\t\tif (0 > newIndex) {\n\t\t\t\t\t\tif (noWrap) {\n\t\t\t\t\t\t\treturn true; // do nothing\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewIndex = this.proposals.length - 1;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (newIndex === startIndex) {\n\t\t\t\t\t// looped through all nodes and didn't find any that were selectable\n\t\t\t\t\tnewIndex = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.selectedIndex = newIndex;\n\t\t\t\n\t\t\tif (this.widget) {\n\t\t\t\tthis.widget.selectNode(newIndex);\n\t\t\t}\n\t\t\t\n\t\t\tthis._showTooltip(true);\n\t\t\t\n\t\t\treturn true;\n\t\t},\n\t\t\n\t\t_showTooltip: function(update) {\n\t\t\tvar tooltip = mTooltip.Tooltip.getTooltip(this.contentAssist.textView);\n\t\t\tvar self = this;\n\t\t\tvar target = {\n\t\t\t\tgetTooltipInfo: function() {\n\t\t\t\t\tvar bounds = self.widget.parentNode.getBoundingClientRect();\n\t\t\t\t\tvar tipArea = {width: 350, height: bounds.height, top: bounds.top};\n\t\t\t\t\tif ((bounds.left + bounds.width) >= document.documentElement.clientWidth){\n\t\t\t\t\t\ttipArea.left = bounds.left - tipArea.width;\n\t\t\t\t\t\ttipArea.left -= 10;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttipArea.left = bounds.left + bounds.width;\n\t\t\t\t\t\ttipArea.left += 10;\n\t\t\t\t\t}\n\t\t\t\t\tvar info = {\n\t\t\t\t\t\tcontext: {proposal: self.proposals[self.selectedIndex]},\n\t\t\t\t\t\tanchorArea: bounds,\n\t\t\t\t\t\ttooltipArea: tipArea\n\t\t\t\t\t};\n\t\t\t\t\treturn info;\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tif (update) {\n\t\t\t\ttooltip.update(target);\n\t\t\t} else {\n\t\t\t\ttooltip.show(target, true, false);\n\t\t\t}\n\t\t},\n\t\t\n\t\t_hideTooltip: function() {\n\t\t\tvar tooltip = mTooltip.Tooltip.getTooltip(this.contentAssist.textView);\n\t\t\ttooltip.hide();\n\t\t},\n\n\t\tpageUp: function() {\n\t\t\t//TODO find out why this doesn't always go to the very top\n\t\t\tif (this.widget) {\n\t\t\t\tvar newSelected = this.widget.getTopIndex();\n\t\t\t\tif (newSelected === this.selectedIndex) {\n\t\t\t\t\tthis.widget.scrollIndex(newSelected, false);\n\t\t\t\t\tnewSelected = this.widget.getTopIndex();\n\t\t\t\t}\n\t\t\t\tif (0 === newSelected) {\n\t\t\t\t\t// if we're attempting to select the first item in the list\n\t\t\t\t\t// move down to the next one if it is not selectable\n\t\t\t\t\treturn this.lineDown(newSelected, true);\t\n\t\t\t\t}\n\t\t\t\treturn this.lineUp(newSelected, true);\n\t\t\t} else {\n\t\t\t\treturn this.lineUp();\n\t\t\t}\n\t\t},\n\t\tpageDown: function() {\n\t\t\tif (this.widget) {\n\t\t\t\tvar newSelected = this.widget.getBottomIndex();\n\t\t\t\tif (newSelected === this.selectedIndex) {\n\t\t\t\t\tthis.widget.scrollIndex(newSelected, true);\n\t\t\t\t\tnewSelected = this.widget.getBottomIndex();\n\t\t\t\t}\n\t\t\t\treturn this.lineDown(newSelected, true);\n\t\t\t} else {\n\t\t\t\treturn this.lineDown();\n\t\t\t}\n\t\t},\n\t\tenter: function() {\n\t\t\tvar proposal = this.proposals[this.selectedIndex] || null;\n\t\t\treturn this.contentAssist.apply(proposal);\n\t\t},\n\t\ttab: function() {\n\t\t\tif (this.widget) {\n\t\t\t\tthis.widget.parentNode.focus();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t * @name orion.editor.ContentAssistWidget\n\t * @class Displays proposals from a {@link orion.editor.ContentAssist}.\n\t * @description Creates a ContentAssistWidget that will display proposals from the given {@link orion.editor.ContentAssist}\n\t * in the given <code>parentNode</code>. Clicking a proposal will cause the ContentAssist to apply that proposal.\n\t * @param {orion.editor.ContentAssist} contentAssist\n\t * @param {String|DomNode} [parentNode] The ID or DOM node to use as the parent for displaying proposals. If not provided,\n\t * a new DIV will be created inside &lt;body&gt; and assigned the CSS class <code>contentassist</code>.\n\t */\n\tfunction ContentAssistWidget(contentAssist, parentNode) {\n\t\tthis.contentAssist = contentAssist;\n\t\tthis.textView = this.contentAssist.getTextView();\n\t\tthis.textViewListenerAdded = false;\n\t\tthis.isShowing = false;\n\t\tvar document = this.textView.getOptions(\"parent\").ownerDocument; //$NON-NLS-0$\n\t\tthis.parentNode = typeof parentNode === \"string\" ? document.getElementById(parentNode) : parentNode; //$NON-NLS-0$\n\t\tif (!this.parentNode) {\n\t\t\tthis.parentNode = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tthis.parentNode.className = \"contentassist\"; //$NON-NLS-0$\n\t\t\tvar body = document.getElementsByTagName(\"body\")[0]; //$NON-NLS-0$\n\t\t\tif (body) {\n\t\t\t\tbody.appendChild(this.parentNode);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"parentNode is required\"); //$NON-NLS-0$\n\t\t\t}\n\t\t}\n\t\t\n\t\ttextUtil.addEventListener(this.parentNode, \"scroll\", this.onScroll.bind(this)); //$NON-NLS-0$\n\t\t\n\t\tvar self = this;\n\t\tthis.textViewListener = {\n\t\t\tonMouseDown: function(event) {\n\t\t\t\tvar target = event.event.target || event.event.srcElement;\n\t\t\t\tif (target.parentElement !== self.parentNode) {\n\t\t\t\t\tself.contentAssist.deactivate();\n\t\t\t\t}\n\t\t\t\t// ignore the event if this is a click inside of the parentNode\n\t\t\t\t// the click is handled by the onClick() function\n\t\t\t}\n\t\t};\n\t\tthis.contentAssist.addEventListener(\"Deactivating\", function(event) { //$NON-NLS-0$\n\t\t\tself.hide();\n\t\t});\n\t\tthis.scrollListener = function(e) {\n\t\t\tif (self.isShowing) {\n\t\t\t\tself.position();\n\t\t\t}\n\t\t};\n\t\ttextUtil.addEventListener(document, \"scroll\", this.scrollListener); //$NON-NLS-0$\n\t}\n\tContentAssistWidget.prototype = /** @lends orion.editor.ContentAssistWidget.prototype */ {\n\t\t/** @private */\n\t\tonClick: function(e) {\n\t\t\tif (!e) { e = window.event; }\n\t\t\tthis.contentAssist.apply(this.getProposal(e.target || e.srcElement));\n\t\t\tthis.textView.focus();\n\t\t},\n\t\t/** @private */\n\t\tonScroll: function(e) {\n\t\t\tif (this.previousCloneNode && !this.preserveCloneThroughScroll) {\n\t\t\t\tthis._removeCloneNode();\n\t\t\t\tthis.previousSelectedNode.classList.add(STYLES.selected);\n\t\t\t}\n\t\t\tthis.preserveCloneThroughScroll = false;\n\t\t},\n\t\t/** @private */\n\t\tcreateDiv: function(proposal, parent, itemIndex) {\n\t\t\tvar document = parent.ownerDocument;\n\t\t\tvar div = util.createElement(document, \"div\"); //$NON-NLS-0$\n\t\t\tdiv.id = \"contentoption\" + itemIndex; //$NON-NLS-0$\n\t\t\tdiv.setAttribute(\"role\", \"option\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tdiv.className = STYLES[proposal.style] ? STYLES[proposal.style] : STYLES.dfault;\n\t\t\tvar node;\n\t\t\tif (proposal.style === \"hr\") { //$NON-NLS-0$\n\t\t\t\tnode = util.createElement(document, \"hr\"); //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tnode = this._createDisplayNode(div, proposal, itemIndex);\n\t\t\t\tdiv.contentAssistProposalIndex = itemIndex; // make div clickable\n\t\t\t}\n\t\t\tdiv.appendChild(node);\n\t\t\tparent.appendChild(div);\n\t\t},\n\t\t/** @private */\n\t\tcreateAccessible: function() {\n\t\t\tvar mode = this._contentAssistMode;\n\t\t\tvar self = this;\n\t\t\ttextUtil.addEventListener(this.parentNode, \"keydown\", function(evt) { //$NON-NLS-0$\n\t\t\t\tif (!evt) { evt = window.event; }\n\t\t\t\tif (evt.preventDefault) {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t\tif(evt.keyCode === lib.KEY.ESCAPE) {\n\t\t\t\t\treturn mode.cancel(); \n\t\t\t\t} else if(evt.keyCode === lib.KEY.UP) {\n\t\t\t\t\treturn mode.lineUp();\n\t\t\t\t} else if(evt.keyCode === lib.KEY.DOWN) {\n\t\t\t\t\treturn mode.lineDown();\n\t\t\t\t} else if(evt.keyCode === lib.KEY.ENTER) {\n\t\t\t\t\treturn mode.enter(); \n\t\t\t\t} else if(evt.keyCode === lib.KEY.PAGEDOWN) {\n\t\t\t\t\treturn mode.pageDown();\n\t\t\t\t} else if(evt.keyCode === lib.KEY.PAGEUP) {\n\t\t\t\t\treturn mode.pageUp();\n\t\t\t\t} else if(evt.keyCode === lib.KEY.HOME) {\n\t\t\t\t\tself.scrollIndex(0, true);\n\t\t\t\t\treturn mode.lineDown(0); // select first selectable element starting at the top and moving downwards\n\t\t\t\t} else if(evt.keyCode === lib.KEY.END) {\n\t\t\t\t\treturn mode.lineUp(mode.getProposals().length - 1); // select first selectable element starting at the bottom and moving up\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t},\n\t\t/** @private */\n\t\t_createDisplayNode: function(div, proposal, index) {\n\t\t\tvar node = null;\n\t\t\tvar plainString = null;\n\t\t\t\n\t\t\tif (typeof proposal === \"string\") { //$NON-NLS-0$\n\t\t\t\t//for simple string content assist, the display string is just the proposal\n\t\t\t\tplainString = proposal;\n\t\t\t} else if (proposal.description && typeof proposal.description === \"string\") { //$NON-NLS-0$\n\t\t\t\tif (proposal.name && typeof proposal.name === \"string\") { //$NON-NLS-0$\n\t\t\t\t\tvar nameNode = this._createNameNode(proposal.name);\n\t\t\t\t\tnameNode.contentAssistProposalIndex = index;\n\t\t\t\t\t\n\t\t\t\t\tnode = document.createElement(\"span\"); //$NON-NLS-0$\n\t\t\t\t\tnode.appendChild(nameNode);\n\t\t\t\t\t\n\t\t\t\t\tvar descriptionNode = document.createTextNode(proposal.description);\n\t\t\t\t\tnode.appendChild(descriptionNode);\n\t\t\t\t} else {\n\t\t\t\t\tplainString = proposal.description;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//by default return the straight proposal text\n\t\t\t\tplainString = proposal.proposal;\n\t\t\t}\n\t\t\t\n\t\t\tif (plainString) {\n\t\t\t\tnode = this._createNameNode(plainString);\n\t\t\t}\n\t\t\t\n\t\t\tnode.contentAssistProposalIndex = index;\n\t\t\t\n\t\t\treturn node;\n\t\t},\n\t\t/** @private */\n\t\t_createNameNode: function(name) {\n\t\t\tvar node = document.createElement(\"span\"); //$NON-NLS-0$\n\t\t\tnode.classList.add(\"proposal-name\"); //$NON-NLS-0$\n\t\t\tnode.appendChild(document.createTextNode(name));\n\t\t\treturn node;\n\t\t},\n\t\t/**\n\t\t * @private\n\t\t * @returns {Object} The proposal represented by the given node.\n\t\t */\n\t\tgetProposal: function(/**DOMNode*/ node) {\n\t\t\tvar proposal = null;\n\t\t\t\n\t\t\tvar nodeIndex = node.contentAssistProposalIndex;\n\t\t\t\n\t\t\tif (undefined !== nodeIndex){\n\t\t\t\tproposal = this._contentAssistMode.getProposals()[nodeIndex] || null;\n\t\t\t}\n\t\t\t\n\t\t\treturn proposal;\n\t\t},\n\t\t/** @private */\n\t\tgetTopIndex: function() {\n\t\t\tvar nodes = this.parentNode.childNodes;\n\t\t\tfor (var i=0; i < nodes.length; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.offsetTop >= this.parentNode.scrollTop) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\t/** @private */\n\t\tgetBottomIndex: function() {\n\t\t\tvar nodes = this.parentNode.childNodes;\n\t\t\tfor (var i=0; i < nodes.length; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif ((child.offsetTop + child.offsetHeight) > (this.parentNode.scrollTop + this.parentNode.clientHeight)) {\n\t\t\t\t\treturn Math.max(0, i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nodes.length - 1;\n\t\t},\n\t\t/** @private */\n\t\tscrollIndex: function(index, top) {\n\t\t\tvar nodeAtIndex = this.parentNode.childNodes[index];\n\t\t\tif (nodeAtIndex){\n\t\t\t\tnodeAtIndex.scrollIntoView(top);\n\t\t\t\tthis.preserveCloneThroughScroll = true;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Visually selects the node at the specified nodeIndex\n\t\t * by updating its CSS class and scrolling it into view\n\t\t * if necessary.\n\t\t * @param{Number} nodeIndex The index of the node to select\n\t\t */\n\t\tselectNode: function(nodeIndex) {\n\t\t\tvar node = null;\n\t\t\t\n\t\t\tif (this._hideTimeout) {\n\t\t\t\twindow.clearTimeout(this._hideTimeout);\n\t\t\t\tthis._hideTimeout = null;\n\t\t\t}\n\t\t\tif (this._fadeTimer) {\n\t\t\t\twindow.clearTimeout(this._fadeTimer);\n\t\t\t\tthis._fadeTimer = null;\n\t\t\t}\n\t\t\tif (this.previousSelectedNode) {\n\t\t\t\tthis.previousSelectedNode.classList.remove(STYLES.selected);\n\t\t\t\tthis.previousSelectedNode = null;\n\t\t\t\tif (this.previousCloneNode) {\n\t\t\t\t\tthis._removeCloneNode();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (-1 !== nodeIndex) {\n\t\t\t\tnode = this.parentNode.childNodes[nodeIndex];\n\t\t\t\tif (node){\n\t\t\t\t\tnode.classList.add(STYLES.selected);\n\t\t\t\t\tthis.parentNode.setAttribute(\"aria-activedescendant\", node.id); //$NON-NLS-0$\n\t\t\t\t\tnode.focus();\n\t\t\t\t\tif (node.offsetTop < this.parentNode.scrollTop) {\n\t\t\t\t\t\tnode.scrollIntoView(true);\n\t\t\t\t\t\tthis.preserveCloneThroughScroll = true;\n\t\t\t\t\t} else if ((node.offsetTop + node.offsetHeight) > (this.parentNode.scrollTop + this.parentNode.clientHeight)) {\n\t\t\t\t\t\tnode.scrollIntoView(false);\n\t\t\t\t\t\tthis.preserveCloneThroughScroll = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar textNode = node.firstChild || node;  \n\t\t\t\t\tvar textBounds = textNode.getBoundingClientRect();\n\t\t\t\t\tvar parentWidth = this.parentNode.clientWidth ? this.parentNode.clientWidth : this.parentNode.getBoundingClientRect(); // Scrollbar can cover text\n\t\t\t\t\tvar parentStyle = window.getComputedStyle(this.parentNode);\n\t\t\t\t\tvar nodeStyle = window.getComputedStyle(node);\n\t\t\t\t\tvar allPadding = parseInt(parentStyle.paddingLeft) + parseInt(parentStyle.paddingRight) + parseInt(nodeStyle.paddingLeft) + parseInt(nodeStyle.paddingRight);\n\t\t\t\t\tif (textBounds.width >= (parentWidth - allPadding)) {\n\t\t\t\t\t\tvar parentTop = parseInt(parentStyle.top);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// create clone node\n\t\t\t\t\t\tvar clone = node.cloneNode(true); // deep clone\n\t\t\t\t\t\tclone.classList.add(\"cloneProposal\"); //$NON-NLS-0$\n\t\t\t\t\t\tclone.style.top = parentTop + node.offsetTop - this.parentNode.scrollTop + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t\tclone.style.left = parentStyle.left;\n\t\t\t\t\t\tclone.setAttribute(\"id\", clone.id + \"_clone\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\t\n\t\t\t\t\t\t// try to fit clone node on page horizontally\n\t\t\t\t\t\tvar viewportWidth = document.documentElement.clientWidth;\n\t\t\t\t\t\tvar horizontalOffset = (textBounds.left + textBounds.width) - parseInt(viewportWidth);\n\t\t\t\t\t\tif (horizontalOffset > 0) {\n\t\t\t\t\t\t\tvar cloneLeft = parseInt(parentStyle.left) - horizontalOffset;\n\t\t\t\t\t\t\tif (0 > cloneLeft) {\n\t\t\t\t\t\t\t\tcloneLeft = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tclone.style.left = cloneLeft + \"px\";\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create wrapper parent node (to replicate css class hierarchy)\n\t\t\t\t\t\tvar parentClone = document.createElement(\"div\");\n\t\t\t\t\t\tparentClone.id = \"clone_contentassist\";  //$NON-NLS-0$\n\t\t\t\t\t\tparentClone.classList.add(\"contentassist\"); //$NON-NLS-0$\n\t\t\t\t\t\tparentClone.classList.add(\"cloneWrapper\"); //$NON-NLS-0$\n\t\t\t\t\t\tparentClone.appendChild(clone);\n\t\t\t\t\t\tparentClone.onclick = this.parentNode.onclick;\n\t\t\t\t\t\tthis.parentNode.parentNode.insertBefore(parentClone, this.parentNode);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// make all the cloned nodes clickable by setting their contentAssistProposalIndex\n\t\t\t\t\t\tvar recursiveSetIndex = function(cloneNode){\n\t\t\t\t\t\t\tcloneNode.contentAssistProposalIndex = node.contentAssistProposalIndex;\n\t\t\t\t\t\t\tif (cloneNode.hasChildNodes()) {\n\t\t\t\t\t\t\t\tfor (var i = 0 ; i < cloneNode.childNodes.length ; i++){\n\t\t\t\t\t\t\t\t\trecursiveSetIndex(cloneNode.childNodes[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\trecursiveSetIndex(parentClone);\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\tthis._hideTimeout = window.setTimeout(function() {\n\t\t\t\t\t\t\tself._hideTimeout = null;\n\t\t\t\t\t\t\tnode.classList.add(STYLES.selected);\n\t\t\t\t\t\t\tvar opacity = 1;\n\t\t\t\t\t\t\tself._fadeTimer = window.setInterval(function() {\n\t\t\t\t\t\t\t\tif (!self.previousCloneNode || opacity <= 0.01){\n\t\t\t\t\t\t\t\t\tself._removeCloneNode();\n\t\t\t\t\t\t\t\t\twindow.clearInterval(self._fadeTimer);\n\t\t\t\t\t\t\t\t\tself._fadeTimer = null;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparentClone.style.opacity = opacity;\n\t\t\t\t\t\t\t\t\tparentClone.style.filter = 'alpha(opacity=' + opacity * 100 + \")\";\n\t        \t\t\t\t\t\topacity -= opacity * 0.1;\n\t        \t\t\t\t\t}\n\t\t\t\t\t\t\t}, 50);\n\t\t\t\t\t\t}, 1500);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnode.classList.remove(STYLES.selected);\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.previousCloneNode = parentClone;\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.previousSelectedNode = node;\n\t\t},\n\t\tsetContentAssistMode: function(mode) {\n\t\t\tthis._contentAssistMode = mode;\n\t\t},\n\t\tshow: function() {\n\t\t\tvar proposals = this._contentAssistMode.getProposals();\n\t\t\tif (proposals.length === 0) {\n\t\t\t\tthis.hide();\n\t\t\t} else {\n\t\t\t\tthis.parentNode.innerHTML = \"\";\n\t\t\t\tfor (var i = 0; i < proposals.length; i++) {\n\t\t\t\t\tthis.createDiv(proposals[i], this.parentNode, i);\n\t\t\t\t}\n\t\t\t\tthis.position();\n\t\t\t\tthis.parentNode.onclick = this.onClick.bind(this);\n\t\t\t\tthis.isShowing = true;\n\t\t\t\t\n\t\t\t\tthis._contentAssistMode._showTooltip(false);\n\t\t\t\t\n\t\t\t\tif (!this.textViewListenerAdded) {\n\t\t\t\t\tthis.textView.addEventListener(\"MouseDown\", this.textViewListener.onMouseDown); //$NON-NLS-0$\n\t\t\t\t\tthis.textViewListenerAdded = true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thide: function() {\n\t\t\tif(this.parentNode.ownerDocument.activeElement === this.parentNode) {\n\t\t\t\tthis.textView.focus();\n\t\t\t}\n\t\t\tthis.parentNode.style.display = \"none\"; //$NON-NLS-0$\n\t\t\tthis.parentNode.onclick = null;\n\t\t\tthis.isShowing = false;\n\t\t\t\n\t\t\tthis._contentAssistMode._hideTooltip();\n\t\t\t\n\t\t\tif (this.textViewListenerAdded) {\n\t\t\t\tthis.textView.removeEventListener(\"MouseDown\", this.textViewListener.onMouseDown); //$NON-NLS-0$\n\t\t\t\tthis.textViewListenerAdded = false;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.previousSelectedNode) {\n\t\t\t\tthis.previousSelectedNode = null;\n\t\t\t\tif (this.previousCloneNode) {\n\t\t\t\t\tthis._removeCloneNode();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tposition: function() {\n\t\t\tvar contentAssist = this.contentAssist;\n\t\t\tvar offset;\n\t\t\tvar view = this.textView;\n\t\t\tif (contentAssist.offset !== undefined) {\n\t\t\t\toffset = contentAssist.offset;\n\t\t\t\tvar model = view.getModel();\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\toffset = model.mapOffset(offset, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toffset = this.textView.getCaretOffset();\n\t\t\t}\n\t\t\tvar caretLocation = view.getLocationAtOffset(offset);\n\t\t\tcaretLocation.y += view.getLineHeight();\n\t\t\tthis.textView.convert(caretLocation, \"document\", \"page\"); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\tthis.parentNode.style.position = \"fixed\"; //$NON-NLS-0$\n\t\t\tthis.parentNode.style.left = caretLocation.x + \"px\"; //$NON-NLS-0$\n\t\t\tthis.parentNode.style.top = caretLocation.y + \"px\"; //$NON-NLS-0$\n\t\t\tthis.parentNode.style.display = \"block\"; //$NON-NLS-0$\n\t\t\tthis.parentNode.scrollTop = 0;\n\n\t\t\t// Make sure that the panel is never outside the viewport\n\t\t\tvar document = this.parentNode.ownerDocument;\n\t\t\tvar viewportWidth = document.documentElement.clientWidth,\n\t\t\t    viewportHeight =  document.documentElement.clientHeight;\n\t\t\t    \n\t\t\tvar spaceBelow = viewportHeight - caretLocation.y;\t\t\t    \n\t\t\tif (this.parentNode.offsetHeight > spaceBelow) {\n\t\t\t\t// Check if div is too large to fit above\n\t\t\t\tvar spaceAbove = caretLocation.y - this.textView.getLineHeight();\n\t\t\t\tif (this.parentNode.offsetHeight > spaceAbove){\n\t\t\t\t\t// Squeeze the div into the larger area\n\t\t\t\t\tif (spaceBelow > spaceAbove) {\n\t\t\t\t\t\tthis.parentNode.style.maxHeight = spaceBelow + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.parentNode.style.maxHeight = spaceAbove + \"px\"; //$NON-NLS-0$\n\t\t\t\t\t\tthis.parentNode.style.top = \"0\"; //$NON-NLS-0$\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Put the div above the line\n\t\t\t\t\tthis.parentNode.style.top = (caretLocation.y - this.parentNode.offsetHeight - this.textView.getLineHeight()) + \"px\"; //$NON-NLS-0$\n\t\t\t\t\tthis.parentNode.style.maxHeight = spaceAbove + \"px\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.parentNode.style.maxHeight = spaceBelow + \"px\"; //$NON-NLS-0$\n\t\t\t}\n\t\t\t\n\t\t\tif (caretLocation.x + this.parentNode.offsetWidth > viewportWidth) {\n\t\t\t\tvar leftSide = viewportWidth - this.parentNode.offsetWidth;\n\t\t\t\tif (leftSide < 0) {\n\t\t\t\t\tleftSide = 0;\n\t\t\t\t}\n\t\t\t\tthis.parentNode.style.left = leftSide + \"px\"; //$NON-NLS-0$\n\t\t\t\tthis.parentNode.style.maxWidth = viewportWidth - leftSide;\n\t\t\t} else {\n\t\t\t\tthis.parentNode.style.maxWidth = viewportWidth + caretLocation.x + \"px\"; //$NON-NLS-0$\n\t\t\t}\n\t\t},\n\t\t_removeCloneNode: function(){\n\t\t\tif (this.parentNode.parentNode.contains(this.previousCloneNode)) {\n\t\t\t\tthis.parentNode.parentNode.removeChild(this.previousCloneNode);\t\n\t\t\t}\n\t\t\tthis.previousCloneNode = null;\n\t\t}\n\t};\n\treturn {\n\t\tContentAssist: ContentAssist,\n\t\tContentAssistMode: ContentAssistMode,\n\t\tContentAssistWidget: ContentAssistWidget\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2010, 2012 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License v1.0\n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution\n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html).\n *\n * Contributors: IBM Corporation - initial API and implementation\n *               Alex Lakatos - fix for bug#369781\n ******************************************************************************/\n\n/*eslint-env browser, amd*/\ndefine(\"orion/editor/textStyler\", ['orion/editor/annotations', 'orion/editor/eventTarget', 'orion/metrics'], //$NON-NLS-3$ //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-0$\n\tfunction(mAnnotations, mEventTarget, mMetrics) {\n\n\t/*\n\t * Throughout textStyler \"block\" refers to a potentially multi-line token.\n\t * Typical examples are multi-line comments and multi-line strings.\n\t */\n\n\tvar binarySearch = function(array, offset, inclusive, low, high) {\n\t\tvar index;\n\t\tif (low === undefined) { low = -1; }\n\t\tif (high === undefined) { high = array.length; }\n\t\twhile (high - low > 1) {\n\t\t\tindex = Math.floor((high + low) / 2);\n\t\t\tif (offset <= array[index].start) {\n\t\t\t\thigh = index;\n\t\t\t} else if (inclusive && offset < array[index].end) {\n\t\t\t\thigh = index;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlow = index;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t};\n\t\n\tfunction copy(object) {\n\t\treturn JSON.parse(JSON.stringify(object));\n\t}\n\n\tvar createPatternBasedAdapter = function(grammars, rootId, contentType) {\n\t\treturn new PatternBasedAdapter(grammars, rootId, contentType);\n\t};\n\n\tfunction PatternBasedAdapter(grammars, rootId, contentType) {\n\t\tthis._patternManager = new PatternManager(grammars, rootId);\n\t\tthis._contentType = contentType;\n\t}\n\tPatternBasedAdapter.prototype = {\n\t\tblockSpansBeyondEnd: function(block) {\n\t\t\treturn block.pattern.regexEnd === this._eolRegex;\n\t\t},\n\t\tcomputeBlocks: function(model, text, block, offset, startIndex, endIndex, maxBlockCount) {\n\t\t\tif (!text) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tvar results = [];\n\t\t\tvar matches = [];\n\t\t\tvar result;\n\t\t\tstartIndex = startIndex || 0;\n\t\t\tendIndex = endIndex || Infinity;\n\t\t\tmaxBlockCount = maxBlockCount || Infinity;\n\t\t\tblock.blockPatterns.forEach(function(current) {\n\t\t\t\tresult = this._findMatch(current.regexBegin || current.regex, text, startIndex);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatches.push({result: result, pattern: current});\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t\tif (!matches.length) {\n\t\t\t\treturn results;\n\t\t\t}\n\t\t\tmatches.sort(function(a,b) {\n\t\t\t\tif (a.result.index < b.result.index) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.result.index > b.result.index) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn a.pattern.pattern.index < b.pattern.pattern.index ? -1 : 1;\n\t\t\t});\n\n\t\t\tvar index = 0;\n\t\t\twhile (matches.length > 0) {\n\t\t\t\tvar current = matches[0];\n\t\t\t\tmatches.splice(0,1);\n\n\t\t\t\tif (endIndex < current.result.index) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (current.result.index < index) {\n\t\t\t\t\t/* processing of another match has moved index beyond this match */\n\t\t\t\t\tthis._updateMatch(current, text, matches, index, endIndex);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar start = offset + current.result.index;\n\t\t\t\tvar contentStart = current.result.index;\n\t\t\t\tvar resultEnd = null;\n\n\t\t\t\tvar endRegex = current.pattern.regexEnd;\n\t\t\t\tif (!endRegex) {\n\t\t\t\t\tresultEnd = this.createBlock(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstart: start,\n\t\t\t\t\t\t\tend: start + current.result[0].length,\n\t\t\t\t\t\t\tcontentStart: start,\n\t\t\t\t\t\t\tcontentEnd: start + current.result[0].length\n\t\t\t\t\t\t},\n\t\t\t\t\t\tblock.styler,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\tcurrent.pattern);\n\t\t\t\t} else {\n\t\t\t\t\tcontentStart += current.result[0].length;\n\t\t\t\t\tvar testPattern = current.pattern;\n\t\t\t\t\t/*\n\t\t\t\t\t * If the end regex contains a capture reference (eg.- \"\\1\") then substitute\n\t\t\t\t\t * the resolved capture values from the begin match.\n\t\t\t\t\t */\n\t\t\t\t\tvar resolvedEndRegex = this._substituteCaptureValues(endRegex, current.result);\n\t\t\t\t\tif (resolvedEndRegex !== endRegex) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A substitution was made, so make a copy of the test pattern and set its\n\t\t\t\t\t\t * end regex to the resolved one.  This will cause end-match detection to be\n\t\t\t\t\t\t * performed with this concrete end regex value, but the original pattern\n\t\t\t\t\t\t * definition containing the capture reference will not be affected.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttestPattern = {\n\t\t\t\t\t\t\tpattern: testPattern.pattern,\n\t\t\t\t\t\t\tregexBegin: testPattern.regexBegin,\n\t\t\t\t\t\t\tregexEnd: resolvedEndRegex\n\t\t\t\t\t\t};\n\t\t\t\t\t\tendRegex = resolvedEndRegex;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar lastIndex = contentStart;\n\t\t\t\t\twhile (!resultEnd) {\n\t\t\t\t\t\tresult = this._findMatch(endRegex, text, lastIndex);\n\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\tthis._eolRegex.lastIndex = 0;\n\t\t\t\t\t\t\tresult = this._eolRegex.exec(text);\n\t\t\t\t\t\t\ttestPattern = {\n\t\t\t\t\t\t\t\tpattern: testPattern.pattern,\n\t\t\t\t\t\t\t\tregexBegin: testPattern.regexBegin,\n\t\t\t\t\t\t\t\tregexEnd: this._eolRegex\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar testBlock = this.createBlock(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstart: start,\n\t\t\t\t\t\t\t\tend: offset + result.index + result[0].length,\n\t\t\t\t\t\t\t\tcontentStart: offset + contentStart,\n\t\t\t\t\t\t\t\tcontentEnd: offset + result.index\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tblock.styler,\n\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\tblock,\n\t\t\t\t\t\t\ttestPattern);\n\t\t\t\t\t\tvar subBlocks = testBlock.getBlocks();\n\t\t\t\t\t\tif (!subBlocks.length || subBlocks[subBlocks.length - 1].end <= (result.index + offset)) {\n\t\t\t\t\t\t\tresultEnd = testBlock;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastIndex = result.index + result[0].length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults.push(resultEnd);\n\t\t\t\tif (results.length === maxBlockCount || endIndex <= resultEnd.end) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tindex = resultEnd.end - offset;\n\t\t\t\tthis._updateMatch(current, text, matches, index, endIndex);\n\t\t\t}\n\t\t\treturn results;\n\t\t},\n\t\tcomputeStyle: function(block, model, offset) {\n\t\t\tif (!block.pattern) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar fullBlock = {\n\t\t\t\tstart: block.start,\n\t\t\t\tend: block.end,\n\t\t\t\tstyle: block.pattern.pattern.name\n\t\t\t};\n\t\t\tif (block.contentStart <= offset && offset < block.contentEnd) {\n\t\t\t\tif (block.pattern.pattern.contentName) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstart: block.contentStart,\n\t\t\t\t\t\tend: block.contentEnd,\n\t\t\t\t\t\tstyle: block.pattern.pattern.contentName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn fullBlock;\n\t\t\t}\n\n\t\t\tvar regex, captures, testString, index;\n\t\t\tif (offset < block.contentStart) {\n\t\t\t\tcaptures = block.pattern.pattern.beginCaptures || block.pattern.pattern.captures;\n\t\t\t\tif (!captures) {\n\t\t\t\t\treturn fullBlock;\n\t\t\t\t}\n\t\t\t\tregex = block.pattern.regexBegin;\n\t\t\t\ttestString = model.getText(block.start, block.contentStart);\n\t\t\t\tindex = block.start;\n\t\t\t} else {\n\t\t\t\tcaptures = block.pattern.pattern.endCaptures || block.pattern.pattern.captures;\n\t\t\t\tif (!captures) {\n\t\t\t\t\treturn fullBlock;\n\t\t\t\t}\n\t\t\t\tregex = block.pattern.regexEnd;\n\t\t\t\ttestString = model.getText(block.contentEnd, block.end);\n\t\t\t\tindex = block.contentEnd;\n\t\t\t}\n\n\t\t\tregex.lastIndex = 0;\n\t\t\tvar result = regex.exec(testString);\n\t\t\tif (result) {\n\t\t\t\tvar styles = [];\n\t\t\t\tthis._getCaptureStyles(result, captures, index, styles);\n\t\t\t\tvar style = styles[binarySearch(styles, offset, true)];\n\t\t\t\tif (style && style.start <= offset && offset < style.end) {\n\t\t\t\t\treturn style;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fullBlock;\n\t\t},\n\t\tcreateBlock: function(bounds, styler, model, parent, data) {\n\t\t\t/* for pattern-based matching data is a pattern */\n\t\t\treturn new Block(\n\t\t\t\tbounds,\n\t\t\t\tdata ? data.pattern.name : null,\n\t\t\t\tdata ? data.pattern.id : null,\n\t\t\t\tstyler,\n\t\t\t\tmodel,\n\t\t\t\tparent,\n\t\t\t\tfunction(newBlock) {\n\t\t\t\t\tnewBlock.pattern = data;\n\t\t\t\t\tnewBlock.linePatterns = [];\n\t\t\t\t\tnewBlock.blockPatterns = [];\n\t\t\t\t\tnewBlock.enclosurePatterns = {};\n\t\t\t\t\tthis._initPatterns(this._patternManager, newBlock);\n\t\t\t\t}.bind(this));\n\t\t},\n\t\tgetBlockContentStyleName: function(block) {\n\t\t\treturn block.pattern.pattern.contentName || block.pattern.pattern.name;\n\t\t},\n\t\tgetBlockEndStyle: function(block, text, endIndex, _styles) {\n\t\t\t/* pattern-defined blocks specify an end style by either a capture or name */\n\t\t\tvar result;\n\t\t\tif (block.pattern.regexEnd) {\n\t\t\t\tresult = this._findMatch(block.pattern.regexEnd, text, 0);\n\t\t\t\tif (result) {\n\t\t\t\t\t/* the end match is still valid */\n\t\t\t\t\tvar captures = block.pattern.pattern.endCaptures || block.pattern.pattern.captures;\n\t\t\t\t\tif (captures) {\n\t\t\t\t\t\tthis._getCaptureStyles(result, captures, endIndex - result[0].length, _styles);\n\t\t\t\t\t} else if (block.pattern.pattern.name) {\n\t\t\t\t\t\t_styles.push({start: endIndex - result[0].length, end: endIndex, style: block.pattern.pattern.name});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result ? result[0] : null;\n\t\t},\n\t\tgetBlockFoldBounds: function(block, model) {\n\t\t\treturn {start: block.start, end: block.end};\n\t\t},\n\t\tgetBlockStartStyle: function(block, text, index, _styles) {\n\t\t\t/* pattern-defined blocks specify a start style by either a capture or name */\n\t\t\tvar result;\n\t\t\tif (block.pattern.regexBegin) {\n\t\t\t\tresult = this._findMatch(block.pattern.regexBegin, text, 0);\n\t\t\t\tif (result) {\n\t\t\t\t\t/* the begin match is still valid */\n\t\t\t\t\tvar captures = block.pattern.pattern.beginCaptures || block.pattern.pattern.captures;\n\t\t\t\t\tif (captures) {\n\t\t\t\t\t\tthis._getCaptureStyles(result, captures, index, _styles);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_styles.push({start: index, end: index + result[0].length, style: block.pattern.pattern.name});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result ? result[0] : null;\n\t\t},\n\t\tgetBracketMatch: function(block, text) {\n\t\t\tvar match;\n\t\t\tvar keys = Object.keys(block.enclosurePatterns);\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar current = block.enclosurePatterns[keys[i]];\n\t\t\t\tvar result = this._findMatch(current.regex, text, 0);\n\t\t\t\tif (result && result.index === 0) {\n\t\t\t\t\tmatch = current;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!match) { return null; }\n\n\t\t\tvar closingName;\n\t\t\tvar atStart = false;\n\t\t\tif (match.pattern.name.indexOf(this._PUNCTUATION_SECTION_BEGIN) !== -1) {\n\t\t\t\tatStart = true;\n\t\t\t\tclosingName = match.pattern.name.replace(this._PUNCTUATION_SECTION_BEGIN, this._PUNCTUATION_SECTION_END);\n\t\t\t} else {\n\t\t\t\tclosingName = match.pattern.name.replace(this._PUNCTUATION_SECTION_END, this._PUNCTUATION_SECTION_BEGIN);\n\t\t\t}\n\t\t\tvar closingBracket = block.enclosurePatterns[closingName];\n\t\t\tif (!closingBracket) { return null; }\n\n\t\t\treturn {\n\t\t\t\tbeginName: match.pattern.name,\n\t\t\t\tendName: closingName,\n\t\t\t\tatStart: atStart\n\t\t\t};\n\t\t},\n\t\tgetContentType: function() {\n\t\t\treturn this._contentType;\n\t\t},\n\t\tparse: function(text, offset, startIndex, block, _styles, ignoreCaptures) {\n\t\t\tif (!text) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar patterns = block.linePatterns;\n\t\t\tif (!patterns) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar matches = [];\n\t\t\tvar result;\n\t\t\tpatterns.forEach(function(current) {\n\t\t\t\tvar regex = current.regex || current.regexBegin;\n\t\t\t\tregex.oldLastIndex = regex.lastIndex;\n\t\t\t\tresult = this._findMatch(regex, text, startIndex);\n\t\t\t\tif (result) {\n\t\t\t\t\tmatches.push({result: result, pattern: current});\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t\tmatches.sort(function(a,b) {\n\t\t\t\tif (a.result.index < b.result.index) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.result.index > b.result.index) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn a.pattern.pattern.index < b.pattern.pattern.index ? -1 : 1;\n\t\t\t});\n\n\t\t\tvar index = startIndex;\n\t\t\twhile (matches.length > 0) {\n\t\t\t\tvar current = matches[0];\n\t\t\t\tmatches.splice(0,1);\n\n\t\t\t\tif (current.result.index < index) {\n\t\t\t\t\t/* processing of another match has moved index beyond this match */\n\t\t\t\t\tthis._updateMatch(current, text, matches, index);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* apply the style */\n\t\t\t\tvar start = current.result.index;\n\t\t\t\tvar end;\n\t\t\t\tvar substyles = [];\n\t\t\t\tif (current.pattern.regex) {\t/* line pattern defined by a \"match\" */\n\t\t\t\t\tresult = current.result;\n\t\t\t\t\tend = start + result[0].length;\n\t\t\t\t\tvar tokenStyle = {start: offset + start, end: offset + end, style: current.pattern.pattern.name};\n\t\t\t\t\tif (!ignoreCaptures) {\n\t\t\t\t\t\tif (current.pattern.pattern.captures) {\n\t\t\t\t\t\t\tthis._getCaptureStyles(result, current.pattern.pattern.captures, offset + start, substyles);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsubstyles.sort(function(a,b) {\n\t\t\t\t\t\t\tif (a.start < b.start) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a.start > b.start) {\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (var j = 0; j < substyles.length - 1; j++) {\n\t\t\t\t\t\t\tif (substyles[j + 1].start < substyles[j].end) {\n\t\t\t\t\t\t\t\tvar newStyle = {start: substyles[j + 1].end, end: substyles[j].end, style: substyles[j].style};\n\t\t\t\t\t\t\t\tsubstyles[j].end = substyles[j + 1].start;\n\t\t\t\t\t\t\t\tsubstyles.splice(j + 2, 0, newStyle);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._mergeStyles(tokenStyle, substyles, _styles);\n\t\t\t\t} else {\t/* pattern defined by a \"begin/end\" pair */\n\t\t\t\t\t/*\n\t\t\t\t\t * If the end match contains a capture reference (eg.- \"\\1\") then update\n\t\t\t\t\t * its regex with the resolved capture values from the begin match.\n\t\t\t\t\t */\n\t\t\t\t\tvar endRegex = current.pattern.regexEnd;\n\t\t\t\t\tendRegex = this._substituteCaptureValues(endRegex, current.result);\n\n\t\t\t\t\tresult = this._findMatch(endRegex, text, current.result.index + current.result[0].length);\n\t\t\t\t\tif (!result) {\n\t\t\t\t\t\tthis._eolRegex.lastIndex = 0;\n\t\t\t\t\t\tresult = this._eolRegex.exec(text);\n\t\t\t\t\t}\n\t\t\t\t\tend = result.index + result[0].length;\n\t\t\t\t\t_styles.push({start: offset + start, end: offset + end, style: current.pattern.pattern.name});\n\t\t\t\t}\n\t\t\t\tindex = result.index + result[0].length;\n\t\t\t\tthis._updateMatch(current, text, matches, index);\n\t\t\t}\n\t\t\tpatterns.forEach(function(current) {\n\t\t\t\tvar regex = current.regex || current.regexBegin;\n\t\t\t\tregex.lastIndex = regex.oldLastIndex;\n\t\t\t});\n\t\t},\n\t\t/** @callback */\n\t\tsetStyler: function(styler) {\n\t\t},\n\t\tverifyBlock: function(baseModel, text, ancestorBlock, changeCount) {\n\t\t\tvar result = null;\n\t\t\tvar matches = [];\n\t\t\tvar match;\n\t\t\tvar parentBlock = ancestorBlock.parent;\n\t\t\tparentBlock.blockPatterns.forEach(function(current) {\n\t\t\t\tmatch = this._findMatch(current.regexBegin || current.regex, text, 0);\n\t\t\t\tif (match) {\n\t\t\t\t\tmatches.push({result: match, pattern: current});\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t\tmatches.sort(function(a,b) {\n\t\t\t\t/* ensure that matches at index 0 make it to the front, other matches do not matter */\n\t\t\t\tif (!a.result.index && b.result.index) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (a.result.index && !b.result.index) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (!a.result.index && !b.result.index) {\n\t\t\t\t\treturn a.pattern.pattern.index < b.pattern.pattern.index ? -1 : 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tif (!matches.length || matches[0].result.index !== 0 || matches[0].pattern.pattern.id !== ancestorBlock.pattern.pattern.id) {\n\t\t\t\tresult = false;\n\t\t\t} else {\n\t\t\t\t/* the block start appears to be unchanged, now verify that the block end is unchanged */\n\t\t\t\tmatch = matches[0];\n\t\t\t\tvar endRegex = match.pattern.regexEnd;\n\t\t\t\tif (!endRegex) {\n\t\t\t\t\t/* single-match block, just verify its length */\n\t\t\t\t\tresult = ancestorBlock.start + match.result[0].length === ancestorBlock.end + changeCount;\n\t\t\t\t} else {\n\t\t\t\t\t/* begin/end-match block */\n\n\t\t\t\t\t /*\n\t\t\t\t\t  * Determine whether an earlier match of the block's end pattern has been introduced.\n\t\t\t\t\t  * Verifying that this has NOT happened (the most typical case) can be quickly done by\n\t\t\t\t\t  * verifying that the first occurrence of its end pattern is still at its former location.\n\t\t\t\t\t  * However if a match is found prior to this then the blocks preceding it must be computed\n\t\t\t\t\t  * to verify that it is a valid end match (ie.- it is not contained within another block).\n\t\t\t\t \t  */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the end regex contains a capture reference (eg.- \"\\1\") then substitute\n\t\t\t\t\t * the resolved capture values from the begin match.\n\t\t\t\t\t */\n\t\t\t\t\tendRegex = this._substituteCaptureValues(endRegex, match.result);\n\n\t\t\t\t\tvar searchStartIndex = match.result[0].length;\n\t\t\t\t\tvar currentMatch = this._findMatch(endRegex, text, searchStartIndex);\n\t\t\t\t\twhile (result === null && currentMatch && ancestorBlock.start + currentMatch.index !== ancestorBlock.contentEnd + changeCount) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A match was found preceeding the former end match, so now compute\n\t\t\t\t\t\t * blocks to determine whether it is in fact a valid new end match.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tvar blocks = this.computeBlocks(baseModel, text, ancestorBlock, ancestorBlock.start, searchStartIndex, currentMatch.index + 1, null);\n\t\t\t\t\t\tif (!blocks.length || blocks[blocks.length - 1].end <= ancestorBlock.start + currentMatch.index) {\n\t\t\t\t\t\t\t/* the match is valid, so the attempt to use ancestorBlock as-is fails */\n\t\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* the match is not valid, so search for the next potential end match */\n\t\t\t\t\t\t\tif (!blocks.length) {\n\t\t\t\t\t\t\t\tcurrentMatch = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsearchStartIndex = blocks[blocks.length - 1].end - ancestorBlock.start;\n\t\t\t\t\t\t\t\tcurrentMatch = this._findMatch(endRegex, text, searchStartIndex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!currentMatch) {\n\t\t\t\t\t\tthis._eolRegex.lastIndex = 0;\n\t\t\t\t\t\tcurrentMatch = this._eolRegex.exec(text);\n\t\t\t\t\t\tresult = ancestorBlock.start + currentMatch.index === ancestorBlock.end + changeCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result !== null ? result : true;\n\t\t},\n\n\t\t/** @private */\n\n\t\t_findMatch: function(regex, text, startIndex, testBeforeMatch) {\n\t\t\t/*\n\t\t\t * testBeforeMatch provides a potential optimization for callers that do not strongly expect to find\n\t\t\t * a match.  If this argument is defined then test() is initially called on the regex, which executes\n\t\t\t * significantly faster than exec().  If a match is found then the regex's lastIndex is reverted to\n\t\t\t * its pre-test() value, and exec() is then invoked on it in order to get the match details.\n\t\t\t */\n\n\t\t\tvar index = startIndex;\n\t\t\tvar initialLastIndex = regex.lastIndex;\n\t\t\tthis._linebreakRegex.lastIndex = startIndex;\n\n\t\t\tvar currentLine = this._linebreakRegex.exec(text);\n\t\t\t/*\n\t\t\t * Processing of the first line is treated specially, as it may not start at the beginning of a logical line, but\n\t\t\t * regex's may be dependent on matching '^'.  To resolve this, compute the full line corresponding to the start\n\t\t\t * of the text, even if it begins prior to startIndex, and adjust the regex's lastIndex accordingly to begin searching\n\t\t\t * for matches at the correct location.\n\t\t\t */\n\t\t\tvar lineString, indexAdjustment;\n\t\t\tregex.lastIndex = 0;\n\t\t\tif (currentLine) {\n\t\t\t\tvar lineStart = currentLine.index;\n\t\t\t\twhile (0 <= --lineStart) {\n\t\t\t\t\tvar char = text.charAt(lineStart);\n\t\t\t\t\tif (char === this._NEWLINE || char === this._CR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlineString = text.substring(lineStart + 1, currentLine.index + currentLine[1].length);\n\t\t\t\tregex.lastIndex = indexAdjustment = currentLine.index - lineStart - 1;\n\t\t\t}\n\t\t\twhile (currentLine && currentLine.index < text.length) {\n\t\t\t\tvar result;\n\t\t\t\tif (testBeforeMatch) {\n\t\t\t\t\tvar revertIndex = regex.lastIndex;\n\t\t\t\t\tif (regex.test(lineString)) {\n\t\t\t\t\t\tregex.lastIndex = revertIndex;\n\t\t\t\t\t\tresult = regex.exec(lineString);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = regex.exec(lineString);\n\t\t\t\t}\n\t\t\t\tif (result) {\n\t\t\t\t\tresult.index += index;\n\t\t\t\t\tresult.index -= indexAdjustment;\n\t\t\t\t\tregex.lastIndex = initialLastIndex;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tindexAdjustment = 0;\n\t\t\t\tindex += currentLine[0].length;\n\t\t\t\tcurrentLine = this._linebreakRegex.exec(text);\n\t\t\t\tif (currentLine) {\n\t\t\t\t\tlineString = currentLine[1];\n\t\t\t\t\tregex.lastIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregex.lastIndex = initialLastIndex;\n\t\t\treturn null;\n\t\t},\n\t\t_getCaptureStyles: function(result, captures, offset, _styles) {\n\t\t\tif (captures[0]) {\n\t\t\t\t/* capture index 0 is the full result */\n\t\t\t\t_styles.push({start: offset, end: offset + result[0].length, style: captures[0].name});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stringIndex = 0;\n\t\t\tfor (var i = 1; i < result.length; i++) {\n\t\t\t\tif (result[i]) {\n\t\t\t\t\tvar capture = captures[i];\n\t\t\t\t\tif (capture) {\n\t\t\t\t\t\tvar styleStart = offset + stringIndex;\n\t\t\t\t\t\t_styles.push({start: styleStart, end: styleStart + result[i].length, style: capture.name});\n\t\t\t\t\t}\n\t\t\t\t\tstringIndex += result[i].length;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_initPatterns: function(patternManager, block) {\n\t\t\tif (block.pattern && block.pattern.pattern.linePatterns) {\n\t\t\t\tblock.linePatterns = block.pattern.pattern.linePatterns;\n\t\t\t\tblock.blockPatterns = block.pattern.pattern.blockPatterns;\n\t\t\t\tblock.enclosurePatterns = block.pattern.pattern.enclosurePatterns;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar patterns = patternManager.getPatterns(block.pattern ? block.pattern.pattern : null);\n\t\t\tvar initRegex = function(match) {\n\t\t\t\tvar matchString = typeof(match) === \"string\" ? match : match.match;\n\t\t\t\tvar result = this._ignoreCaseRegex.exec(matchString);\n\t\t\t\tvar flags = this._FLAGS;\n\t\t\t\tif (result) {\n\t\t\t\t\tmatchString = matchString.substring(result[0].length);\n\t\t\t\t\tflags += \"i\";\n\t\t\t\t}\n\t\t\t\treturn new RegExp(matchString, flags);\n\t\t\t}.bind(this);\n\t\t\tvar lastBlock = -1;\n\t\t\tvar index = 0;\n\t\t\tpatterns.forEach(function(current) {\n\t\t\t\tvar pattern;\n\t\t\t\tif (current.match && !current.begin && !current.end) {\n\t\t\t\t\tpattern = {regex: initRegex(current.match), pattern: current};\n\t\t\t\t\tblock.linePatterns.push(pattern);\n\t\t\t\t\tif (current.name && current.name.indexOf(\"punctuation.section\") === 0 && (current.name.indexOf(this._PUNCTUATION_SECTION_BEGIN) !== -1 || current.name.indexOf(this._PUNCTUATION_SECTION_END) !== -1)) { //$NON-NLS-0$\n\t\t\t\t\t\tblock.enclosurePatterns[current.name] = pattern;\n\t\t\t\t\t}\n\t\t\t\t} else if (!current.match && current.begin && current.end) {\n\t\t\t\t\tlastBlock = index;\n\t\t\t\t\tpattern = {regexBegin: initRegex(current.begin), regexEnd: initRegex(current.end), pattern: current};\n\t\t\t\t\tblock.linePatterns.push(pattern);\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}.bind(this));\n\t\t\tblock.blockPatterns = block.linePatterns.slice(0, lastBlock + 1);\n\t\t\tif (block.pattern) {\n\t\t\t\tblock.pattern.pattern.enclosurePatterns = block.enclosurePatterns;\n\t\t\t\tblock.pattern.pattern.linePatterns = block.linePatterns;\n\t\t\t\tblock.pattern.pattern.blockPatterns = block.blockPatterns;\n\t\t\t}\n\t\t},\n\t\t_mergeStyles: function(fullStyle, substyles, resultStyles) {\n\t\t\tvar i = fullStyle.start;\n\t\t\tsubstyles.forEach(function(current) {\n\t\t\t\tif (i <= current.start) {\n\t\t\t\t\tresultStyles.push({start: i, end: current.start, style: fullStyle.style});\n\t\t\t\t}\n\t\t\t\tresultStyles.push(current);\n\t\t\t\ti = current.end;\n\t\t\t});\n\t\t\tif (i < fullStyle.end) {\n\t\t\t\tresultStyles.push({start: i, end: fullStyle.end, style: fullStyle.style});\n\t\t\t}\n\t\t},\n\t\t_substituteCaptureValues: function(regex, resolvedResult) {\n\t\t\tvar regexString = regex.toString();\n\t\t\tthis._captureReferenceRegex.lastIndex = 0;\n\t\t\tif (!this._captureReferenceRegex.test(regexString)) {\n\t\t\t\t/* nothing to do */\n\t\t\t\treturn regex;\n\t\t\t}\n\n\t\t\tthis._captureReferenceRegex.lastIndex = 0;\n\t\t\tvar result = this._captureReferenceRegex.exec(regexString);\n\t\t\twhile (result) {\n\t\t\t\tregexString = regexString.replace(result[0], resolvedResult[result[1]] || \"\");\n\t\t\t\tthis._captureReferenceRegex.lastIndex = 0;\n\t\t\t\tresult = this._captureReferenceRegex.exec(regexString);\n\t\t\t}\n\t\t\t/* return an updated regex, remove the leading '/' and trailing /FLAGS */\n\t\t\treturn new RegExp(regexString.substring(1, regexString.length - 1 - this._FLAGS.length), this._FLAGS);\n\t\t},\n\t\t_updateMatch: function(match, text, matches, minimumIndex, endIndex) {\n\t\t\tvar regEx = match.pattern.regex ? match.pattern.regex : match.pattern.regexBegin;\n\t\t\tendIndex = endIndex || Infinity;\n\t\t\tvar result = this._findMatch(regEx, text, minimumIndex, true);\n\t\t\tif (result && result.index < endIndex) {\n\t\t\t\tmatch.result = result;\n\t\t\t\tfor (var i = 0; i < matches.length; i++) {\n\t\t\t\t\tif (result.index < matches[i].result.index || (result.index === matches[i].result.index && match.pattern.pattern.index < matches[i].pattern.pattern.index)) {\n\t\t\t\t\t\tmatches.splice(i, 0, match);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t},\n\t\t_captureReferenceRegex: /\\\\(\\d)/g,\n\t\t_eolRegex: /$/,\n\t\t_ignoreCaseRegex: /^\\(\\?i\\)\\s*/,\n\t\t_linebreakRegex: /(.*)(?:[\\r\\n]|$)/g,\n\t\t_CR: \"\\r\", //$NON-NLS-0$\n\t\t_FLAGS: \"g\", //$NON-NLS-0$\n\t\t_NEWLINE: \"\\n\", //$NON-NLS-0$\n\t\t_PUNCTUATION_SECTION_BEGIN: \".begin\", //$NON-NLS-0$\n\t\t_PUNCTUATION_SECTION_END: \".end\" //$NON-NLS-0$\n\t};\n\n\tfunction PatternManager(grammars, rootId) {\n\t\tthis._unnamedCounter = 0;\n\t\tthis._patterns = [];\n\t\tthis._rootId = rootId;\n\t\tgrammars.forEach(function(grammar) {\n\t\t\tthis._addRepositoryPatterns(grammar.repository || {}, grammar.id);\n\t\t\tthis._addPatterns(grammar.patterns || [], grammar.id);\n\t\t}.bind(this));\n\t}\n\tPatternManager.prototype = {\n\t\tgetPatterns: function(pattern) {\n\t\t\tvar parentId;\n\t\t\tif (!pattern) {\n\t\t\t\tparentId = this._rootId + \"#\" + this._NO_ID;\n\t\t\t} else {\n\t\t\t\tif (typeof(pattern) === \"string\") { //$NON-NLS-0$\n\t\t\t\t\tparentId = pattern;\n\t\t\t\t} else {\n\t\t\t\t\tparentId = pattern.qualifiedId;\n\t\t\t\t}\n\t\t\t\tparentId += \"#\";\n\t\t\t}\n\t\t\t/* indexes on patterns are used to break ties when multiple patterns match the same start text */\n\t\t\tvar indexCounter = [0];\n\t\t\tvar resultObject = {};\n\t\t\tvar regEx = new RegExp(\"^\" + parentId + \"[^#]+$\"); //$NON-NLS-0$\n\t\t\tthis._patterns.forEach(function(current) {\n\t\t\t\tif (regEx.test(current.qualifiedId)) {\n\t\t\t\t\tif (current.include) {\n\t\t\t\t\t\tthis._processInclude(current, indexCounter, resultObject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar newPattern = copy(current);\n\t\t\t\t\t\tnewPattern.index = indexCounter[0]++;\n\t\t\t\t\t\tresultObject[current.qualifiedId] = newPattern;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.bind(this));\n\n\t\t\tvar result = [];\n\t\t\tvar keys = Object.keys(resultObject);\n\t\t\tkeys.forEach(function(current) {\n\t\t\t\tresult.push(resultObject[current]);\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\n\t\t/** @private */\n\n\t\t_addPattern: function(pattern, patternId, parentId) {\n\t\t\tpattern.parentId = parentId;\n\t\t\tpattern.id = patternId;\n\t\t\tpattern.qualifiedId = pattern.parentId + \"#\" + pattern.id;\n\t\t\tthis._patterns.push(pattern);\n\t\t\tif (pattern.patterns && !pattern.include) {\n\t\t\t\tthis._addPatterns(pattern.patterns, pattern.qualifiedId);\n\t\t\t}\n\t\t},\n\t\t_addPatterns: function(patterns, parentId) {\n\t\t\tpatterns.forEach(function(pattern) {\n\t\t\t\tthis._addPattern(pattern, this._NO_ID + this._unnamedCounter++, parentId);\n\t\t\t}.bind(this));\n\t\t},\n\t\t_addRepositoryPatterns: function(repository, parentId) {\n\t\t\tvar keys = Object.keys(repository);\n\t\t\tkeys.forEach(function(key) {\n\t\t\t\tthis._addPattern(repository[key], key, parentId);\n\t\t\t}.bind(this));\n\t\t},\n\t\t_processInclude: function(pattern, indexCounter, resultObject) {\n\t\t\tvar searchExp;\n\t\t\tvar index = pattern.include.indexOf(\"#\");\n\t\t\tif (index === 0) {\n\t\t\t\t/* inclusion of pattern from same grammar */\n\t\t\t\tsearchExp = new RegExp(\"^\" + pattern.qualifiedId.substring(0, pattern.qualifiedId.indexOf(\"#\")) + pattern.include + \"$\");\n\t\t\t} else if (index === -1) {\n\t\t\t\t/* inclusion of whole grammar */\n\t\t\t\tsearchExp = new RegExp(\"^\" + pattern.include + \"#\" + this._NO_ID + \"[^#]+$\");\n\t\t\t} else {\n\t\t\t\t/* inclusion of specific pattern from another grammar */\n\t\t\t\tsearchExp = new RegExp(\"^\" + pattern.include + \"$\");\n\t\t\t}\n\t\t\tthis._patterns.forEach(function(current) {\n\t\t\t\tif (searchExp.test(current.qualifiedId)) {\n\t\t\t\t\tif (current.include) {\n\t\t\t\t\t\tthis._processInclude(current, indexCounter, resultObject);\n\t\t\t\t\t} else if (!resultObject[current.qualifiedId]) {\n\t\t\t\t\t\tvar newPattern = copy(current);\n\t\t\t\t\t\tnewPattern.index = indexCounter[0]++;\n\t\t\t\t\t\tresultObject[current.qualifiedId] = newPattern;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t},\n\t\t_NO_ID: \"NoID\"\t//$NON-NLS-0$\n\t};\n\n\tfunction Block(bounds, name, typeId, styler, model, parent, initFn) {\n\t\tthis.start = bounds.start;\n\t\tthis.end = bounds.end;\n\t\tthis.contentStart = bounds.contentStart;\n\t\tthis.contentEnd = bounds.contentEnd;\n\t\tthis.name = name;\n\t\tthis.typeId = typeId;\n\t\tthis.styler = styler;\n\t\tthis.parent = parent;\n\t\tif (initFn) {\n\t\t\tinitFn(this);\n\t\t}\n\t\tthis._subBlocks = styler.computeBlocks(model, model.getText(this.contentStart, this.end), this, this.contentStart, null, null, null);\n\t}\n\tBlock.prototype = {\n\t\tadjustBounds: function(index, value) {\n\t\t\tif (index < this.start) {\n\t\t\t\tthis.start += value;\n\t\t\t}\n\t\t\tif (index < this.contentStart) {\n\t\t\t\tthis.contentStart += value;\n\t\t\t}\n\t\t\tif (index <= this.end) {\n\t\t\t\tthis.end += value;\n\t\t\t}\n\t\t\tif (index <= this.contentEnd) {\n\t\t\t\tthis.contentEnd += value;\n\t\t\t}\n\t\t\tthis._subBlocks.forEach(function(current) {\n\t\t\t\tif (index <= current.end) {\n\t\t\t\t\tcurrent.adjustBounds(index, value);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tgetBlocks: function() {\n\t\t\treturn this._subBlocks;\n\t\t},\n\t\tgetBlockAtIndex: function(index) {\n\t\t\treturn binarySearch(this.getBlocks(), index, true);\n\t\t},\n\t\tisRenderingWhitespace: function() {\n\t\t\treturn this.styler._isRenderingWhitespace();\n\t\t}\n\t};\n\n\tfunction TextStylerAccessor(styler) {\n\t\tthis._styler = styler;\n\t}\n\tTextStylerAccessor.prototype = {\n\t\tgetStyles: function(offset) {\n\t\t\treturn this._styler.getStyles(offset);\n\t\t}\n\t};\n\n\tfunction TextStyler(view, annotationModel, stylerAdapter) {\t\t\n\t\tthis._whitespacesVisible = false;\n\t\tthis._highlightCaretLine = false;\n\t\tthis._foldingEnabled = true;\n\t\tthis._detectTasks = true;\n\t\tthis._annotationProviders = [];\n\t\tthis._view = view;\n\t\tthis._annotationModel = annotationModel;\n\t\tthis._stylerAdapter = stylerAdapter;\n\t\tthis._stylerAdapter.setStyler(this);\n\t\tthis._accessor = new TextStylerAccessor(this);\n\t\tthis._bracketAnnotations;\n\n\t\tvar self = this;\n\t\tthis._listener = {\n\t\t\tonChanged: function(e) {\n\t\t\t\tself._onModelChanged(e);\n\t\t\t},\n\t\t\tonDestroy: function(e) {\n\t\t\t\tself._onDestroy(e);\n\t\t\t},\n\t\t\tonLineStyle: function(e) {\n\t\t\t\tself._onLineStyle(e);\n\t\t\t},\n\t\t\tonMouseDown: function(e) {\n\t\t\t\tself._onMouseDown(e);\n\t\t\t},\n\t\t\tonSelection: function(e) {\n\t\t\t\tself._onSelection(e);\n\t\t\t}\n\t\t};\n\t\tvar model = view.getModel();\n\t\tif (model.getBaseModel) {\n\t\t\tmodel = model.getBaseModel();\n\t\t}\n\t\tmodel.addEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t\tview.addEventListener(\"MouseDown\", this._listener.onMouseDown); //$NON-NLS-0$\n\t\tview.addEventListener(\"Selection\", this._listener.onSelection); //$NON-NLS-0$\n\t\tview.addEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\tview.addEventListener(\"LineStyle\", this._listener.onLineStyle); //$NON-NLS-0$\n\n\t\tvar charCount = model.getCharCount();\n\t\tvar rootBounds = {start: 0, contentStart: 0, end: charCount, contentEnd: charCount};\n\t\tif (charCount >= 50000) {\n\t\t\tvar startTime = new Date().getTime();\n\t\t}\n\t\tthis._rootBlock = this._stylerAdapter.createBlock(rootBounds, this, model, null);\n\t\tif (startTime) {\n\t\t\tvar interval = new Date().getTime() - startTime;\n\t\t\tif (interval > 10) {\n\t\t\t\tmMetrics.logTiming(\n\t\t\t\t\t\"editor\", //$NON-NLS-0$\n\t\t\t\t\t\"styler compute blocks (ms/50000 chars)\", //$NON-NLS-0$\n\t\t\t\t\tinterval * 50000 / charCount,\n\t\t\t\t\tstylerAdapter.getContentType());\n\t\t\t}\n\t\t}\n\t\tif (annotationModel) {\n\t\t\tvar add = [];\n\t\t\tannotationModel.removeAnnotations(mAnnotations.AnnotationType.ANNOTATION_FOLDING);\n\t\t\tthis._computeFolding(this._rootBlock.getBlocks(), view.getModel(), add);\n\t\t\tif (this._detectTasks) {\n\t\t\t\tannotationModel.removeAnnotations(mAnnotations.AnnotationType.ANNOTATION_TASK);\n\t\t\t\tthis._computeTasks(this._rootBlock, model, add);\n\t\t\t}\n\t\t\tannotationModel.replaceAnnotations([], add);\n\t\t}\n\t\tview.redrawLines();\n\t}\n\tTextStyler.prototype = {\n\t\taddAnnotationProvider: function(value) {\n\t\t\tif (typeof value === \"function\") { //$NON-NLS-0$\n\t\t\t\tthis._annotationProviders.push(value);\n\t\t\t}\n\t\t},\n\t\tcomputeBlocks: function(model, text, block, offset, startIndex, endIndex, maxBlockCount) {\n\t\t\treturn this._stylerAdapter.computeBlocks(model, text, block, offset, startIndex, endIndex, maxBlockCount);\n\t\t},\n\t\tdestroy: function() {\n\t\t\tif (this._view) {\n\t\t\t\tvar model = this._view.getModel();\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tmodel = model.getBaseModel();\n\t\t\t\t}\n\t\t\t\tmodel.removeEventListener(\"Changed\", this._listener.onChanged); //$NON-NLS-0$\n\t\t\t\tthis._view.removeEventListener(\"MouseDown\", this._listener.onMouseDown); //$NON-NLS-0$\n\t\t\t\tthis._view.removeEventListener(\"Selection\", this._listener.onSelection); //$NON-NLS-0$\n\t\t\t\tthis._view.removeEventListener(\"Destroy\", this._listener.onDestroy); //$NON-NLS-0$\n\t\t\t\tthis._view.removeEventListener(\"LineStyle\", this._listener.onLineStyle); //$NON-NLS-0$\n\t\t\t\tthis._view = null;\n\t\t\t}\n\t\t},\n\t\tgetAnnotationModel: function() {\n\t\t\treturn this._annotationModel;\n\t\t},\n\t\tgetBlockAtIndex: function(index) {\n\t\t\treturn this._findBlock(this._rootBlock, index);\n\t\t},\n\t\tgetRootBlock: function() {\n\t\t\treturn this._rootBlock;\n\t\t},\n\t\tgetStyleAccessor: function() {\n\t\t\treturn this._accessor;\n\t\t},\n\t\tgetStyles: function(offset) {\n\t\t\tvar result = [];\n\t\t\tvar model = this._view.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\tvar block = this._findBlock(this._rootBlock, offset);\n\t\t\tvar lineIndex = model.getLineAtOffset(offset);\n\t\t\tvar lineText = model.getLine(lineIndex);\n\t\t\tvar styles = [];\n\t\t\tthis._stylerAdapter.parse(lineText, model.getLineStart(lineIndex), 0, block, styles);\n\t\t\tvar style = styles[binarySearch(styles, offset, true)];\n\t\t\tif (style && style.start <= offset && offset < style.end) {\n\t\t\t\tresult.push(style);\n\t\t\t}\n\t\t\twhile (block) {\n\t\t\t\tstyle = this._stylerAdapter.computeStyle(block, model, offset);\n\t\t\t\tif (style) {\n\t\t\t\t\tresult.splice(0, 0, style);\n\t\t\t\t}\n\t\t\t\tblock = block.parent;\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetTextModel: function() {\n\t\t\tvar model = this._view.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\tmodel = model.getBaseModel();\n\t\t\t}\n\t\t\treturn model;\n\t\t},\n\t\tremoveAnnotationProvider: function(value) {\n\t\t\tif (typeof value !== \"function\") { //$NON-NLS-0$\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar index = this._annotationProviders.indexOf(value);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis._annotationProviders.splice(index, 1);\n\t\t\t}\n\t\t},\n\t\tsetDetectHyperlinks: function() {\n\t\t},\n\t\tsetDetectTasks: function(enabled) {\n\t\t\tthis._detectTasks = enabled;\n\t\t},\n\t\tsetFoldingEnabled: function(enabled) {\n\t\t\tthis._foldingEnabled = enabled;\n\t\t},\n\t\tsetHighlightCaretLine: function(highlight) {\n\t\t\tthis._highlightCaretLine = highlight;\n\t\t},\n\t\tsetWhitespacesVisible: function(visible, redraw) {\n\t\t\tif (this._whitespacesVisible === visible) { return; }\n\t\t\tthis._whitespacesVisible = visible;\n\t\t\tif (redraw) {\n\t\t\t\tthis._view.redraw();\n\t\t\t}\n\t\t},\n\n\t\t/** @private */\n\n\t\t_computeFolding: function(blocks, viewModel, _add) {\n\t\t\tif (!viewModel.getBaseModel) { return; }\n\t\t\tvar baseModel = viewModel.getBaseModel();\n\t\t\tblocks.forEach(function(block) {\n\t\t\t\tvar foldBounds = this._stylerAdapter.getBlockFoldBounds(block, baseModel);\n\t\t\t\tvar annotation = this._createFoldingAnnotation(viewModel, baseModel, foldBounds.start, foldBounds.end);\n\t\t\t\tif (annotation) {\n\t\t\t\t\t_add.push(annotation);\n\t\t\t\t}\n\t\t\t\tthis._computeFolding(block.getBlocks(), viewModel, _add);\n\t\t\t}.bind(this));\n\t\t},\n\t\t_computeTasks: function(block, baseModel, annotations, start, end) {\n\t\t\tstart = start || block.start;\n\t\t\tend = end || block.end;\n\t\t\tif (block.start <= end && start <= block.end) {\n\t\t\t\tif (!this._annotationModel) { return; }\n\n\t\t\t\tvar annotationType = mAnnotations.AnnotationType.ANNOTATION_TASK;\n\t\t\t\tif (block.name && block.name.indexOf(\"comment\") === 0) {\n\t\t\t\t\tvar substyles = [];\n\t\t\t\t\tvar lineIndex = baseModel.getLineAtOffset(block.contentStart);\n\t\t\t\t\tvar lineStart = baseModel.getLineStart(lineIndex);\n\t\t\t\t\tthis._stylerAdapter.parse(baseModel.getText(lineStart, block.end), lineStart, block.contentStart - lineStart, block, substyles, true);\n\t\t\t\t\tfor (var i = 0; i < substyles.length; i++) {\n\t\t\t\t\t\tif (substyles[i].style === \"meta.annotation.task.todo\" && start <= substyles[i].start && substyles[i].end <= end) {\n\t\t\t\t\t\t\tannotations.push(mAnnotations.AnnotationType.createAnnotation(annotationType, substyles[i].start, substyles[i].end, baseModel.getText(substyles[i].start, substyles[i].end)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tblock.getBlocks().forEach(function(current) {\n\t\t\t\t\tthis._computeTasks(current, baseModel, annotations, start, end);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t},\n\t\t_createFoldingAnnotation: function(viewModel, baseModel, start, end) {\n\t\t\tvar startLine = baseModel.getLineAtOffset(start);\n\t\t\tvar endLine = baseModel.getLineAtOffset(end);\n\t\t\tif (startLine === endLine) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (startLine + 1 === endLine && baseModel.getLineStart(endLine) === baseModel.getLineEnd(endLine)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new (mAnnotations.AnnotationType.getType(mAnnotations.AnnotationType.ANNOTATION_FOLDING))(start, end, viewModel);\n\t\t},\n\t\t_findBlock: function(parentBlock, offset) {\n\t\t\tvar blocks = parentBlock.getBlocks();\n\t\t\tif (!blocks.length) {\n\t\t\t\treturn parentBlock;\n\t\t\t}\n\n\t\t\tvar index = binarySearch(blocks, offset, true);\n\t\t\tif (index < blocks.length && blocks[index].start <= offset && offset < blocks[index].end) {\n\t\t\t\treturn this._findBlock(blocks[index], offset);\n\t\t\t}\n\t\t\treturn parentBlock;\n\t\t},\n\t\t_findBrackets: function(model, bracketMatch, block, text, offset, end) {\n\t\t\tvar result = [], styles = [];\n\t\t\tvar start = offset, blocks = block.getBlocks();\n\t\t\tvar startIndex = binarySearch(blocks, offset, true);\n\t\t\tfor (var i = startIndex; i < blocks.length; i++) {\n\t\t\t\tif (blocks[i].start >= end) { break; }\n\t\t\t\tvar blockStart = blocks[i].start;\n\t\t\t\tvar blockEnd = blocks[i].end;\n\t\t\t\tif (start < blockStart) {\n\t\t\t\t\tvar lineIndex = model.getLineAtOffset(start);\n\t\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\t\tthis._stylerAdapter.parse(text.substring(lineStart - offset, blockStart - offset), lineStart, start - lineStart, block, styles);\n\t\t\t\t\tstyles.forEach(function(current) {\n\t\t\t\t\t\tif (current.style) {\n\t\t\t\t\t\t\tif (current.style.indexOf(bracketMatch.beginName) === 0) {\n\t\t\t\t\t\t\t\tresult.push(current.start + 1);\n\t\t\t\t\t\t\t} else if (current.style.indexOf(bracketMatch.endName) === 0) {\n\t\t\t\t\t\t\t\tresult.push(-(current.start + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tstyles = [];\n\t\t\t\t}\n\t\t\t\tstart = blockEnd;\n\t\t\t}\n\t\t\tif (start < end) {\n\t\t\t\tlineIndex = model.getLineAtOffset(start);\n\t\t\t\tlineStart = model.getLineStart(lineIndex);\n\t\t\t\tthis._stylerAdapter.parse(text.substring(lineStart - offset, end - offset), lineStart, start - lineStart, block, styles);\n\t\t\t\tstyles.forEach(function(current) {\n\t\t\t\t\tif (current.style) {\n\t\t\t\t\t\tif (current.style.indexOf(bracketMatch.beginName) === 0) {\n\t\t\t\t\t\t\tresult.push(current.start + 1);\n\t\t\t\t\t\t} else if (current.style.indexOf(bracketMatch.endName) === 0) {\n\t\t\t\t\t\t\tresult.push(-(current.start + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t_findMatchingBracket: function(model, block, offset) {\n\t\t\tvar lineIndex = model.getLineAtOffset(offset);\n\t\t\tvar lineEnd = model.getLineEnd(lineIndex);\n\t\t\tvar text = model.getText(offset, lineEnd);\n\n\t\t\tvar bracketMatch = this._stylerAdapter.getBracketMatch(block, text);\n\t\t\tif (!bracketMatch) { return -1; }\n\n\t\t\tvar lineText = model.getLine(lineIndex);\n\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\tvar brackets = this._findBrackets(model, bracketMatch, block, lineText, lineStart, lineEnd);\n\t\t\tfor (var i = 0; i < brackets.length; i++) {\n\t\t\t\tvar sign = brackets[i] >= 0 ? 1 : -1;\n\t\t\t\tif (brackets[i] * sign - 1 === offset) {\n\t\t\t\t\tvar level = 1;\n\t\t\t\t\tif (!bracketMatch.atStart) {\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tfor (; i>=0; i--) {\n\t\t\t\t\t\t\tsign = brackets[i] >= 0 ? 1 : -1;\n\t\t\t\t\t\t\tlevel += sign;\n\t\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\t\treturn brackets[i] * sign - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlineIndex -= 1;\n\t\t\t\t\t\twhile (lineIndex >= 0) {\n\t\t\t\t\t\t\tlineText = model.getLine(lineIndex);\n\t\t\t\t\t\t\tlineStart = model.getLineStart(lineIndex);\n\t\t\t\t\t\t\tlineEnd = model.getLineEnd(lineIndex);\n\t\t\t\t\t\t\tbrackets = this._findBrackets(model, bracketMatch, block, lineText, lineStart, lineEnd);\n\t\t\t\t\t\t\tfor (var j = brackets.length - 1; j >= 0; j--) {\n\t\t\t\t\t\t\t\tsign = brackets[j] >= 0 ? 1 : -1;\n\t\t\t\t\t\t\t\tlevel += sign;\n\t\t\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\t\t\treturn brackets[j] * sign - 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlineIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tfor (; i<brackets.length; i++) {\n\t\t\t\t\t\t\tsign = brackets[i] >= 0 ? 1 : -1;\n\t\t\t\t\t\t\tlevel += sign;\n\t\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\t\treturn brackets[i] * sign - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlineIndex += 1;\n\t\t\t\t\t\tvar lineCount = model.getLineCount();\n\t\t\t\t\t\twhile (lineIndex < lineCount) {\n\t\t\t\t\t\t\tlineText = model.getLine(lineIndex);\n\t\t\t\t\t\t\tlineStart = model.getLineStart(lineIndex);\n\t\t\t\t\t\t\tlineEnd = model.getLineEnd(lineIndex);\n\t\t\t\t\t\t\tbrackets = this._findBrackets(model, bracketMatch, block, lineText, lineStart, lineEnd);\n\t\t\t\t\t\t\tfor (var k=0; k<brackets.length; k++) {\n\t\t\t\t\t\t\t\tsign = brackets[k] >= 0 ? 1 : -1;\n\t\t\t\t\t\t\t\tlevel += sign;\n\t\t\t\t\t\t\t\tif (level === 0) {\n\t\t\t\t\t\t\t\t\treturn brackets[k] * sign - 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlineIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t_getLineStyle: function(lineIndex) {\n\t\t\tif (this._highlightCaretLine) {\n\t\t\t\tvar view = this._view;\n\t\t\t\tvar model = view.getModel();\n\t\t\t\tvar selections = view.getSelections();\n\t\t\t\tvar hasCaret = false;\n\t\t\t\tif (!selections.some(function(selection) {\n\t\t\t\t\tif (selection.start === selection.end) {\n\t\t\t\t\t\thasCaret = hasCaret || model.getLineAtOffset(selection.start) === lineIndex;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}) && hasCaret) return this._caretLineStyle;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t_getStyles: function(block, model, text, offset, startIndex) {\n\t\t\tvar end = offset + text.length;\n\n\t\t\tvar styles = [];\n\t\t\tvar start = offset + startIndex, blocks = block.getBlocks();\n\t\t\tvar startBlockIndex = binarySearch(blocks, start, true);\n\t\t\tfor (var i = startBlockIndex; i < blocks.length; i++) {\n\t\t\t\tif (blocks[i].start >= end) { break; }\n\t\t\t\tvar blockStart = blocks[i].start;\n\t\t\t\tvar blockEnd = blocks[i].end;\n\t\t\t\tif (start < blockStart) {\n\t\t\t\t\t/* content on that line that preceeds the start of the block */\n\t\t\t\t\tvar lineIndex = model.getLineAtOffset(start);\n\t\t\t\t\tvar lineStart = model.getLineStart(lineIndex);\n\t\t\t\t\tthis._stylerAdapter.parse(text.substring(lineStart - offset, blockStart - offset), lineStart, start - lineStart, block, styles);\n\t\t\t\t}\n\t\t\t\tvar s = Math.max(start, blockStart);\n\t\t\t\tif (s === blockStart) {\n\t\t\t\t\t/* currently in the block's \"start\" segment */\n\t\t\t\t\tvar startString = this._stylerAdapter.getBlockStartStyle(blocks[i], text.substring(s - offset), s, styles);\n\t\t\t\t\tif (startString) {\n\t\t\t\t\t\ts += startString.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Compute the block end now in order to determine the end-bound of the contained content, but do not add\n\t\t\t\t * its styles to the styles array until content styles have been computed, so that ordering is preserved.\n\t\t\t\t */\n\t\t\t\tvar e = Math.min(end, blockEnd);\n\t\t\t\tvar endStyles = [];\n\t\t\t\tif (e === blockEnd) {\n\t\t\t\t\t/* currently in the block's \"end\" segment */\n\t\t\t\t\tvar testString = text.substring(e - start - (blocks[i].end - blocks[i].contentEnd));\n\t\t\t\t\tvar endString = this._stylerAdapter.getBlockEndStyle(blocks[i], testString, e, endStyles);\n\t\t\t\t\tif (endString) {\n\t\t\t\t\t\te -= endString.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlineIndex = model.getLineAtOffset(s);\n\t\t\t\tlineStart = model.getLineStart(lineIndex);\n\t\t\t\tvar blockSubstyles = this._getStyles(blocks[i], model, text.substring(lineStart - offset, e - offset), lineStart, s - lineStart);\n\t\t\t\tvar blockStyleName = this._stylerAdapter.getBlockContentStyleName(blocks[i]);\n\t\t\t\tif (blockStyleName) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If a name was specified for the current block then apply its style throughout its\n\t\t\t\t\t * content wherever a style is not provided by a sub-element.\n\t\t\t\t\t */\n\t\t\t\t\tvar index = s;\n\t\t\t\t\tblockSubstyles.forEach(function(current) {\n\t\t\t\t\t\tif (current.start - index) {\n\t\t\t\t\t\t\tstyles.push({start: index, end: current.start, style: blockStyleName});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (current.mergeable) {\n\t\t\t\t\t\t\tcurrent.style += \",\" + blockStyleName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstyles.push(current);\n\t\t\t\t\t\tindex = current.end;\n\t\t\t\t\t});\n\t\t\t\t\tif (e - index) {\n\t\t\t\t\t\tstyles.push({start: index, end: e, style: blockStyleName});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstyles = styles.concat(blockSubstyles);\n\t\t\t\t}\n\t\t\t\tstyles = styles.concat(endStyles);\n\t\t\t\tstart = blockEnd;\n\t\t\t}\n\t\t\tif (start < end) {\n\t\t\t\t/* content on that line that follows the end of the block */\n\t\t\t\tlineIndex = model.getLineAtOffset(start);\n\t\t\t\tlineStart = model.getLineStart(lineIndex);\n\t\t\t\tthis._stylerAdapter.parse(text.substring(lineStart - offset, end - offset), lineStart, start - lineStart, block, styles);\n\t\t\t}\n\n\t\t\treturn styles;\n\t\t},\n\t\t_isRenderingWhitespace: function() {\n\t\t\treturn this._whitespacesVisible;\n\t\t},\n\t\t_onDestroy: function() {\n\t\t\tthis.destroy();\n\t\t},\n\t\t_onLineStyle: function(e) {\n\t\t\tif (e.textView === this._view) {\n\t\t\t\te.style = this._getLineStyle(e.lineIndex);\n\t\t\t}\n\n\t\t\tvar offset = e.lineStart;\n\t\t\tvar model = e.textView.getModel();\n\t\t\tif (model.getBaseModel) {\n\t\t\t\toffset = model.mapOffset(offset);\n\t\t\t\tvar baseModel = model.getBaseModel();\n\t\t\t}\n\n\t\t\te.ranges = this._getStyles(this._rootBlock, baseModel || model, e.lineText, offset, 0);\n\t\t\tfor (var i = e.ranges.length - 1; i >= 0; i--) {\n\t\t\t\tvar current = e.ranges[i];\n\t\t\t\tif (current.style) {\n\t\t\t\t\tcurrent.style = {styleClass: current.style.replace(/\\./g, \" \")};\n\t\t\t\t\tif (baseModel) {\n\t\t\t\t\t\tvar length = current.end - current.start;\n\t\t\t\t\t\tcurrent.start = model.mapOffset(current.start, true);\n\t\t\t\t\t\tcurrent.end = current.start + length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\te.ranges.splice(i, 1);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (this._isRenderingWhitespace()) {\n\t\t\t\tthis._spliceStyles(this._spacePattern, e.ranges, e.lineText, e.lineStart);\n\t\t\t\tthis._spliceStyles(this._tabPattern, e.ranges, e.lineText, e.lineStart);\n\t\t\t}\n\t\t},\n\t\t_onModelChanged: function(e) {\n\t\t\tvar start = e.start;\n\t\t\tvar removedCharCount = e.removedCharCount;\n\t\t\tvar addedCharCount = e.addedCharCount;\n\t\t\tvar changeCount = addedCharCount - removedCharCount;\n\t\t\tvar viewModel = this._view.getModel();\n\t\t\tvar baseModel = viewModel.getBaseModel ? viewModel.getBaseModel() : viewModel;\n\t\t\tvar end = start + removedCharCount;\n\t\t\tvar charCount = baseModel.getCharCount();\n\n\t\t\t/* compute the nearest ancestor block to the start and end indices */\n\t\t\tvar lineStart = baseModel.getLineStart(baseModel.getLineAtOffset(start));\n\t\t\tvar ancestorBlock = this._findBlock(this._rootBlock, start);\n\n\t\t\tvar blockExtended, blocks, parentBlock, redraw, text, te, ts;\n\t\t\tdo {\n\t\t\t\tparentBlock = ancestorBlock.parent;\n\n\t\t\t\t/*\n\t\t\t\t * Determine whether ancestorBlock contains the full range of\n\t\t\t\t * text whose styling may be affected by this model change.\n\t\t\t\t */\n\t\t\t\tif (!blockExtended && parentBlock) {\n\t\t\t\t\t/* verify that ancestorBlock's start and end bounds are not affected by this change */\n\t\t\t\t\tif (changeCount < 0 && ancestorBlock.end - start <= -changeCount) {\n\t\t\t\t\t\t/* the end bound has definitely been affected, no verifyBlock() required, move up to the parent */\n\t\t\t\t\t\tancestorBlock = parentBlock;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ttext = baseModel.getText(ancestorBlock.start, Math.min(charCount, ancestorBlock.end + changeCount + 1));\n\t\t\t\t\tif (!this._stylerAdapter.verifyBlock(baseModel, text, ancestorBlock, changeCount)) {\n\t\t\t\t\t\tancestorBlock = parentBlock;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * The change has not directly changed ancestorBlock's start/end strings, now verify that its end\n\t\t\t\t * bound is still valid (ie.- ensure that a new block is not extending beyond the end bound).\n\t\t\t\t */\n\n\t\t\t\tblocks = ancestorBlock.getBlocks();\n\t\t\t\tvar blockCount = blocks.length;\n\t\t\t\tvar blockStart = binarySearch(blocks, lineStart, true);\n\t\t\t\tvar blockEnd = binarySearch(blocks, end, false, blockStart - 1, blockCount);\n\n\t\t\t\t/*\n\t\t\t\t * If the change immediately follows the preceding block then test whether\n\t\t\t\t * the block should be extended.\n\t\t\t\t */\n\t\t\t\tblockExtended = false;\n\t\t\t\tif (blockStart && blocks.length && blocks[blockStart - 1].end === start) {\n\t\t\t\t\ttext = baseModel.getText(blocks[blockStart - 1].start, Math.min(charCount, start + 1));\n\t\t\t\t\tvar tempBlocks = this.computeBlocks(baseModel, text, ancestorBlock, blocks[blockStart - 1].start, null, null, null);\n\t\t\t\t\tif (tempBlocks.length && tempBlocks[0].end !== blocks[blockStart - 1].end) {\n\t\t\t\t\t\t/* the change has affected the preceding block's end, so include this block */\n\t\t\t\t\t\tblockStart--;\n\t\t\t\t\t\tblockExtended = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (blockStart < blockCount && blocks[blockStart].start <= lineStart && (lineStart < blocks[blockStart].end || blockExtended)) {\n\t\t\t\t\tts = blocks[blockStart].start;\n\t\t\t\t\tif (ts > start) { ts += changeCount; }\n\t\t\t\t} else if (blockStart === blockCount && blockCount > 0 && ancestorBlock.end - changeCount === blocks[blockCount - 1].end) {\n\t\t\t\t\tts = blocks[--blockStart].start;\n\t\t\t\t\tif (ts > start) { ts += changeCount; }\n\t\t\t\t} else {\n\t\t\t\t\tts = Math.max(lineStart, ancestorBlock.contentStart);\n\t\t\t\t}\n\n\t\t\t\tif (blockEnd < blockCount) {\n\t\t\t\t\tte = blocks[blockEnd].end;\n\t\t\t\t} else {\n\t\t\t\t\tte = ancestorBlock.contentEnd;\n\t\t\t\t}\n\t\t\t\tif (start <= te) { te += changeCount; }\n\t\t\t\tte = Math.min(te, charCount - 1);\n\t\t\t\ttext = baseModel.getText(ts, te + 1);\n\t\t\t\tvar newBlocks = this.computeBlocks(baseModel, text, ancestorBlock, ts, null, null, null);\n\n\t\t\t\tif (blockEnd < blockCount) {\n\t\t\t\t\t/* ensure that blockEnd's end is preserved */\n\t\t\t\t\tif (newBlocks.length && newBlocks[newBlocks.length - 1].end === te && newBlocks[newBlocks.length - 1].typeId === blocks[blockEnd].typeId) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * ancestorBlock's end match is no longer valid because it is being spanned by a block from\n\t\t\t\t\t * within.  Attempt to find a subsequent sibling block with the same type, as its end match\n\t\t\t\t\t * will serve as the end match for this spanning block as well.\n\t\t\t\t\t */\n\t\t\t\t\tif (newBlocks.length && this._stylerAdapter.blockSpansBeyondEnd(newBlocks[newBlocks.length - 1])) {\n\t\t\t\t\t\tblockEnd++;\n\t\t\t\t\t\tvar subBlocks = newBlocks[newBlocks.length - 1].getBlocks();\n\t\t\t\t\t\tvar spanningTypeId = (subBlocks.length ? subBlocks[subBlocks.length - 1] : newBlocks[newBlocks.length - 1]).typeId;\n\t\t\t\t\t\twhile (blockEnd < blockCount) {\n\t\t\t\t\t\t\tif (blocks[blockEnd].typeId === spanningTypeId) {\n\t\t\t\t\t\t\t\t/* found a potential end block, must verify it */\n\t\t\t\t\t\t\t\tvar tempTe = blocks[blockEnd].end + changeCount;\n\t\t\t\t\t\t\t\ttempTe = Math.min(tempTe, charCount - 1);\n\t\t\t\t\t\t\t\ttext = baseModel.getText(ts, tempTe + 1);\n\t\t\t\t\t\t\t\tvar tempNewBlocks = this.computeBlocks(baseModel, text, ancestorBlock, ts, null, null, null);\n\t\t\t\t\t\t\t\tif (tempNewBlocks.length && tempNewBlocks[tempNewBlocks.length - 1].end === tempTe) {\n\t\t\t\t\t\t\t\t\t/* verified, can now stop looking */\n\t\t\t\t\t\t\t\t\tte = tempTe;\n\t\t\t\t\t\t\t\t\tnewBlocks = tempNewBlocks;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblockEnd++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (blockEnd < blockCount) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* ensure that ancestorBlock's end is preserved */\n\t\t\t\t\tif (!newBlocks.length || newBlocks[newBlocks.length - 1].end <= ancestorBlock.contentEnd + changeCount) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * The end block's end bound is spanned by a block from within, so move up to the ancestor\n\t\t\t\t * block, or extend end to the end of the content if already at the root-level block.\n\t\t\t\t */\n\n\t\t\t\tif (!parentBlock) {\n\t\t\t\t\tte = charCount;\n\t\t\t\t\tblockEnd = blockCount;\n\t\t\t\t\ttext = baseModel.getText(ts, te);\n\t\t\t\t\tnewBlocks = this.computeBlocks(baseModel, text, ancestorBlock, ts, null, null, null);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tancestorBlock = parentBlock;\n\t\t\t\tredraw = true; /* blocks may not appear to be changed in the context of the parent block */\n\t\t\t} while (true);\n\n\t\t\tthis._rootBlock.adjustBounds(start, changeCount);\n\t\t\tblockEnd = Math.min(blockEnd + 1, blockCount);\n\n\t\t\tvar block;\n\t\t\tif (!redraw) {\n\t\t\t\tredraw = (blockEnd - blockStart) !== newBlocks.length;\n\t\t\t}\n\t\t\tif (!redraw) {\n\t\t\t\tfor (var i = 0; i < newBlocks.length; i++) {\n\t\t\t\t\tblock = blocks[blockStart + i];\n\t\t\t\t\tvar newBlock = newBlocks[i];\n\t\t\t\t\tif (block.start !== newBlock.start || block.end !== newBlock.end || block.typeId !== newBlock.typeId) {\n\t\t\t\t\t\tredraw = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!blocks.length && !newBlocks.length) {\n\t\t\t\tvar eventOldBlocks = [ancestorBlock];\n\t\t\t\tvar eventNewBlocks = [ancestorBlock];\n\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\ttype: \"BlocksChanged\", //$NON-NLS-0$\n\t\t\t\t\toldBlocks: eventOldBlocks,\n\t\t\t\t\tnewBlocks: eventNewBlocks\n\t\t\t\t});\n\t\t\t\tancestorBlock = eventNewBlocks[0]; /* enables the markdown styler to return a modified ancestorBlock */\n\t\t\t} else {\n\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\ttype: \"BlocksChanged\", //$NON-NLS-0$\n\t\t\t\t\toldBlocks: blocks.slice(blockStart, blockEnd),\n\t\t\t\t\tnewBlocks: newBlocks\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar args = [blockStart, blockEnd - blockStart].concat(newBlocks);\n\t\t\tArray.prototype.splice.apply(blocks, args);\n\t\t\tif (redraw) {\n\t\t\t\tvar redrawStart = ts;\n\t\t\t\tvar redrawEnd = te;\n\t\t\t\tif (viewModel !== baseModel) {\n\t\t\t\t\tredrawStart = viewModel.mapOffset(redrawStart, true);\n\t\t\t\t\tredrawEnd = viewModel.mapOffset(redrawEnd, true);\n\t\t\t\t}\n\t\t\t\tthis._view.redrawRange(redrawStart, redrawEnd);\n\t\t\t}\n\n\t\t\tif (this._annotationModel) {\n\t\t\t\tvar remove = [], add = [];\n\t\t\t\tvar allFolding = [];\n\t\t\t\tvar iter = this._annotationModel.getAnnotations(ts, te);\n\t\t\t\tvar doFolding = this._foldingEnabled && baseModel !== viewModel;\n\t\t\t\tvar parent = ancestorBlock.parent || ancestorBlock;\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tvar annotation = iter.next();\n\t\t\t\t\tif (doFolding && annotation.type === mAnnotations.AnnotationType.ANNOTATION_FOLDING) {\n\t\t\t\t\t\tallFolding.push(annotation);\n\t\t\t\t\t\tblock = this._findBlock(parent, annotation.start);\n\t\t\t\t\t\twhile (block) {\n\t\t\t\t\t\t\tvar foldBounds = this._stylerAdapter.getBlockFoldBounds(block, baseModel);\n\t\t\t\t\t\t\tif (annotation.start === foldBounds.start && annotation.end === foldBounds.end) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblock = block.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (block && annotation.start === foldBounds.start && annotation.end === foldBounds.end) {\n\t\t\t\t\t\t\tvar annotationStart = annotation.start;\n\t\t\t\t\t\t\tvar annotationEnd = annotation.end;\n\t\t\t\t\t\t\tif (annotationStart > start) {\n\t\t\t\t\t\t\t\tannotationStart -= changeCount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (annotationEnd > start) {\n\t\t\t\t\t\t\t\tannotationEnd -= changeCount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (annotationStart <= start && start < annotationEnd && annotationStart <= end && end < annotationEnd) {\n\t\t\t\t\t\t\t\tvar startLine = baseModel.getLineAtOffset(annotation.start);\n\t\t\t\t\t\t\t\tvar endLine = baseModel.getLineAtOffset(annotation.end);\n\t\t\t\t\t\t\t\tif (startLine !== endLine) {\n\t\t\t\t\t\t\t\t\tif (!annotation.expanded) {\n\t\t\t\t\t\t\t\t\t\tannotation.expand();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tremove.push(annotation);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tremove.push(annotation);\n\t\t\t\t\t\t\tannotation.expand();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (annotation.type === mAnnotations.AnnotationType.ANNOTATION_TASK) {\n\t\t\t\t\t\tif (ancestorBlock.start <= annotation.start && annotation.end <= ancestorBlock.end) {\n\t\t\t\t\t\t\tremove.push(annotation);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (doFolding) {\n\t\t\t\t\tparent.getBlocks().forEach(function(block) {\n\t\t\t\t\t\tthis._updateFolding(block, baseModel, viewModel, allFolding, add, ts, te);\n\t\t\t\t\t}.bind(this));\n\t\t\t\t}\n\t\t\t\tif (this._detectTasks) {\n\t\t\t\t\tthis._computeTasks(ancestorBlock, baseModel, add, ts, te);\n\t\t\t\t}\n\t\t\t\tthis._annotationProviders.forEach(function(current) {\n\t\t\t\t\tvar providerRemove = [];\n\t\t\t\t\tvar providerAdd = [];\n\t\t\t\t\tcurrent(this._annotationModel, baseModel, ancestorBlock, ts, te, providerRemove, providerAdd);\n\t\t\t\t\tremove = remove.concat(providerRemove);\n\t\t\t\t\tadd = add.concat(providerAdd);\n\t\t\t\t}.bind(this));\n\t\t\t\tthis._annotationModel.replaceAnnotations(remove, add);\n\t\t\t}\n\t\t},\n\t\t_onMouseDown: function(e) {\n\t\t\tif (e.clickCount !== 2) { return; }\n\t\t\tvar model = this._view.getModel();\n\t\t\tvar offset = this._view.getOffsetAtLocation(e.x, e.y);\n\t\t\tif (offset > 0) {\n\t\t\t\tvar mapOffset = offset - 1;\n\t\t\t\tvar baseModel = model;\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tmapOffset = model.mapOffset(mapOffset);\n\t\t\t\t\tbaseModel = model.getBaseModel();\n\t\t\t\t}\n\t\t\t\tvar block = this._findBlock(this._rootBlock, mapOffset);\n\t\t\t\tvar bracket = this._findMatchingBracket(baseModel, block, mapOffset);\n\t\t\t\tif (bracket !== -1) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tvar mapBracket = bracket;\n\t\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\t\tmapBracket = model.mapOffset(mapBracket, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (offset > mapBracket) {\n\t\t\t\t\t\toffset--;\n\t\t\t\t\t\tmapBracket++;\n\t\t\t\t\t}\n\t\t\t\t\tthis._view.setSelection(mapBracket, offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_onSelection: function(e) {\n\t\t\tvar oldSelections = Array.isArray(e.oldValue) ? e.oldValue : [e.oldValue];\n\t\t\tvar newSelections = Array.isArray(e.newValue) ? e.newValue : [e.newValue];\n\t\t\tvar view = this._view;\n\t\t\tvar model = view.getModel();\n\t\t\tvar lineIndex;\n\t\t\tif (this._highlightCaretLine) {\n\t\t\t\tfunction getHighlightLines(selections) {\n\t\t\t\t\tvar lines = {};\n\t\t\t\t\tif (selections.some(function(selection) {\n\t\t\t\t\t\tif (selection.isEmpty()) {\n\t\t\t\t\t\t\tlines[model.getLineAtOffset(selection.start).toString()] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t})) return {};\n\t\t\t\t\treturn lines;\n\t\t\t\t}\n\t\t\t\tvar oldLines = getHighlightLines(oldSelections);\n\t\t\t\tvar newLines = getHighlightLines(newSelections);\n\t\t\t\tfunction redraw(o, n) {\n\t\t\t\t\tfor (var p in o) {\n\t\t\t\t\t\tif (!n[p]) {\n\t\t\t\t\t\t\tlineIndex = p >> 0;\n\t\t\t\t\t\t\tview.redrawLines(lineIndex, lineIndex + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tredraw(oldLines, newLines);\n\t\t\t\tredraw(newLines, oldLines);\n\t\t\t}\n\t\t\tif (!this._annotationModel) { return; }\n\n\t\t\tvar remove = this._bracketAnnotations, add, caret;\n\t\t\tif (newSelections.length === 1 && newSelections[0].isEmpty() && (caret = newSelections[0].getCaret()) > 0) {\n\t\t\t\tvar mapCaret = caret - 1;\n\t\t\t\tif (model.getBaseModel) {\n\t\t\t\t\tmapCaret = model.mapOffset(mapCaret);\n\t\t\t\t\tmodel = model.getBaseModel();\n\t\t\t\t}\n\t\t\t\tvar block = this._findBlock(this._rootBlock, mapCaret);\n\t\t\t\tvar bracket = this._findMatchingBracket(model, block, mapCaret);\n\t\t\t\tif (bracket !== -1) {\n\t\t\t\t\tadd = [\n\t\t\t\t\t\tmAnnotations.AnnotationType.createAnnotation(mAnnotations.AnnotationType.ANNOTATION_MATCHING_BRACKET, bracket, bracket + 1),\n\t\t\t\t\t\tmAnnotations.AnnotationType.createAnnotation(mAnnotations.AnnotationType.ANNOTATION_CURRENT_BRACKET, mapCaret, mapCaret + 1)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._bracketAnnotations = add;\n\t\t\tthis._annotationModel.replaceAnnotations(remove, add);\n\t\t},\n\t\t_spliceStyles: function(whitespacePattern, ranges, text, offset) {\n\t\t\tvar regex = whitespacePattern.regex;\n\t\t\tregex.lastIndex = 0;\n\t\t\tvar rangeIndex = 0;\n\t\t\tvar result = regex.exec(text);\n\t\t\twhile (result) {\n\t\t\t\tvar charIndex = offset + result.index;\n\t\t\t\twhile (rangeIndex < ranges.length) {\n\t\t\t\t\tif (charIndex < ranges[rangeIndex].end) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trangeIndex++;\n\t\t\t\t}\n\t\t\t\tvar newStyle = {\n\t\t\t\t\tstart: charIndex,\n\t\t\t\t\tend: charIndex + 1,\n\t\t\t\t\tstyle: copy(whitespacePattern.style)\n\t\t\t\t};\n\t\t\t\tif (rangeIndex < ranges.length && ranges[rangeIndex].start <= charIndex) {\n\t\t\t\t\tvar endStyle = {start: charIndex + 1, end: ranges[rangeIndex].end, style: ranges[rangeIndex].style};\n\t\t\t\t\tranges[rangeIndex].end = charIndex;\n\t\t\t\t\tranges.splice(rangeIndex + 1, 0, endStyle);\n\t\t\t\t\tranges.splice(rangeIndex + 1, 0, newStyle);\n\t\t\t\t\trangeIndex += 2;\n\t\t\t\t\tnewStyle.style.styleClass += \" \" + ranges[rangeIndex].style.styleClass; //$NON-NLS-0$\n\t\t\t\t} else {\n\t\t\t\t\tranges.splice(rangeIndex, 0, newStyle);\n\t\t\t\t\trangeIndex++;\n\t\t\t\t}\n\t\t\t\tresult = regex.exec(text);\n\t\t\t}\n\t\t},\n\t\t_updateFolding: function(block, baseModel, viewModel, allFolding, _add, start, end) {\n\t\t\tstart = start || block.start;\n\t\t\tend = end || block.end;\n\t\t\tvar foldBounds = this._stylerAdapter.getBlockFoldBounds(block, baseModel);\n\t\t\tif (!block.doNotFold && foldBounds.start <= end && start <= foldBounds.end) {\n\t\t\t\tvar index = binarySearch(allFolding, foldBounds.start, true);\n\t\t\t\tif (!(index < allFolding.length && allFolding[index].start === foldBounds.start && allFolding[index].end === foldBounds.end)) {\n\t\t\t\t\tvar annotation = this._createFoldingAnnotation(viewModel, baseModel, foldBounds.start, foldBounds.end);\n\t\t\t\t\tif (annotation) {\n\t\t\t\t\t\t_add.push(annotation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tblock.getBlocks().forEach(function(current) {\n\t\t\t\t\tthis._updateFolding(current, baseModel, viewModel, allFolding, _add, start, end);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t},\n\t\t_caretLineStyle: {styleClass: \"meta annotation currentLine\"}, //$NON-NLS-0$\n\t\t_spacePattern: {regex: /[ ]/g, style: {styleClass: \"punctuation separator space\", unmergeable: true}}, //$NON-NLS-0$\n\t\t_tabPattern: {regex: /\\t/g, style: {styleClass: \"punctuation separator tab\", unmergeable: true}} //$NON-NLS-0$\n\t};\n\n\tmEventTarget.EventTarget.addMixin(TextStyler.prototype);\n\n\treturn {\n\t\tTextStyler: TextStyler,\n\t\tBlock: Block,\n\t\tcreatePatternBasedAdapter: createPatternBasedAdapter\n\t};\n});\n\n",
    "/*******************************************************************************\n * @license\n * Copyright (c) 2013, 2015 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials are made \n * available under the terms of the Eclipse Public License v1.0 \n * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution \n * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). \n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\n \n/*eslint-env browser, amd*/\ndefine('orion/editor/edit', [ //$NON-NLS-0$\n\t\"require\", //$NON-NLS-0$\n\n\t\"orion/editor/textView\", //$NON-NLS-0$\n\t\"orion/editor/textModel\", //$NON-NLS-0$\n\t\"orion/editor/textTheme\", //$NON-NLS-0$\n\t\"orion/editor/projectionTextModel\", //$NON-NLS-0$\n\t\"orion/editor/editor\", //$NON-NLS-0$\n\t\"orion/editor/editorFeatures\", //$NON-NLS-0$\n\t\n\t\"orion/editor/contentAssist\", //$NON-NLS-0$\n\t\"orion/editor/textStyler\" //$NON-NLS-0$\n\n], function(require, mTextView, mTextModel, mTextTheme, mProjModel, mEditor, mEditorFeatures, mContentAssist, mTextStyler) {\n\n\t/**\t@private */\n\tfunction getDisplay(window, document, element) {\n\t\tvar display;\n\t\tvar temp = element;\n\t\twhile (temp && temp !== document && display !== \"none\") { //$NON-NLS-0$\n\t\t\tif (window.getComputedStyle) {\n\t\t\t\tvar style = window.getComputedStyle(temp, null);\n\t\t\t\tdisplay = style.getPropertyValue(\"display\"); //$NON-NLS-0$\n\t\t\t} else {\n\t\t\t\tdisplay = temp.currentStyle.display;\n\t\t\t}\n\t\t\ttemp = temp.parentNode;\n\t\t}\n\t\tif (!temp || !display) {\n\t\t\treturn \"none\"; //$NON-NLS-0$\n\t\t}\n\t\treturn display;\n\t}\n\n\t/**\t@private */\n\tfunction getTextFromElement(element) {\n\t\tvar firstChild = element.firstChild;\n\t\tif (firstChild && firstChild.tagName === \"TEXTAREA\") { //$NON-NLS-0$\n\t\t\treturn firstChild.value;\n\t\t}\n\t\tvar document = element.ownerDocument;\n\t\tvar window = document.defaultView || document.parentWindow;\n\t\tif (!window.getSelection ||\n\t\t\t(element.childNodes.length === 1 && firstChild.nodeType === Node.TEXT_NODE) ||\n\t\t\tgetDisplay(window, document, element) === \"none\") //$NON-NLS-0$\n\t\t{\n\t\t\treturn element.innerText || element.textContent;\n\t\t}\n\t\tvar newRange = document.createRange();\n\t\tnewRange.selectNode(element);\n\t\tvar selection = window.getSelection();\n\t\tvar oldRanges = [], i;\n\t\tfor (i = 0; i < selection.rangeCount; i++) {\n\t\t\toldRanges.push(selection.getRangeAt(i));\n\t\t}\n\t\tselection.removeAllRanges();\n\t\tselection.addRange(newRange);\n\t\tvar text = selection.toString();\n\t\tselection.removeAllRanges();\n\t\tfor (i = 0; i < oldRanges.length; i++) {\n\t\t\tselection.addRange(oldRanges[i]);\n\t\t}\n\t\treturn text;\n\t}\n\n\t/**\t@private */\t\n\tfunction optionName(name) {\n\t\tvar prefix = \"data-editor-\"; //$NON-NLS-0$\n\t\tif (name.substring(0, prefix.length) === prefix) {\n\t\t\tvar key = name.substring(prefix.length);\n\t\t\tkey = key.replace(/-([a-z])/ig, /* @callback */ function(all, character) {\n\t\t\t\treturn character.toUpperCase();\n\t\t\t});\n\t\t\treturn key;\n\t\t}\n\t\treturn undefined;\n\t}\n\t\n\t/**\t@private */\n\tfunction merge(obj1, obj2) {\n\t\tfor (var p in obj2) {\n\t\t\tif (obj2.hasOwnProperty(p)) {\n\t\t\t\tobj1[p] = obj2[p];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\t@private */\n\tfunction mergeOptions(parent, defaultOptions) {\n\t\tvar options = {};\n\t\tmerge(options, defaultOptions);\n\t\tfor (var attr, j = 0, attrs = parent.attributes, l = attrs.length; j < l; j++) {\n\t\t\tattr = attrs.item(j);\n\t\t\tvar key = optionName(attr.nodeName);\n\t\t\tif (key) {\n\t\t\t\tvar value = attr.nodeValue;\n\t\t\t\tif (value === \"true\" || value === \"false\") { //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\tvalue = value === \"true\"; //$NON-NLS-0$\n\t\t\t\t}\n\t\t\t\toptions[key] = value;\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\t\n\t/**\t@private */\n\tfunction getParents(document, className) {\n\t\tif (document.getElementsByClassName) {\n\t\t\treturn document.getElementsByClassName(className);\n\t\t}\n\t\tclassName = className.replace(/ *$/, '');\n\t\tif (document.querySelectorAll) {\n\t\t\treturn document.querySelectorAll((' ' + className).replace(/ +/g, '.')); //$NON-NLS-1$ //$NON-NLS-0$\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/**\t@private */\n\tfunction getHeight(node) {\n\t\treturn node.clientHeight;\n\t}\n\t\n\t/**\n\t * @class This object describes the options for <code>edit</code>.\n\t * @name orion.editor.EditOptions\n\t *\n\t * @property {String|DOMElement} parent the parent element for the view, it can be either a DOM element or an ID for a DOM element.\n\t * @property {Boolean} [readonly=false] whether or not the view is read-only.\n\t * @property {Boolean} [fullSelection=true] whether or not the view is in full selection mode.\n\t * @property {Boolean} [tabMode=true] whether or not the tab keypress is consumed by the view or is used for focus traversal.\n\t * @property {Boolean} [expandTab=false] whether or not the tab key inserts white spaces.\n\t * @property {String} [themeClass] the CSS class for the view theming.\n\t * @property {Number} [tabSize=4] The number of spaces in a tab.\n\t * @property {Boolean} [singleMode=false] whether or not the editor is in single line mode.\n\t * @property {Boolean} [wrapMode=false] whether or not the view wraps lines.\n\t * @property {Boolean} [wrapable=false] whether or not the view is wrappable.\n\t * @property {Function} [statusReporter] a status reporter.\n\t * @property {String} [title=\"\"] the editor title.\n\t * @property {String} [contents=\"\"] the editor contents.\n\t * @property {String} [lang] @deprecated use contentType instead\n\t * @property {String} [contentType] the type of the content (eg.- application/javascript, text/html, etc.)\n\t * @property {Boolean} [showLinesRuler=true] whether or not the lines ruler is shown.\n\t * @property {Boolean} [showAnnotationRuler=true] whether or not the annotation ruler is shown.\n\t * @property {Boolean} [showOverviewRuler=true] whether or not the overview ruler is shown.\n\t * @property {Boolean} [showFoldingRuler=true] whether or not the folding ruler is shown.\n\t * @property {Boolean} [showZoomRuler=false] whether or not the zoom ruler is shown.\n\t * @property {Boolean} [noFocus=false] whether or not to focus the editor on creation.\n\t * @property {Number} [firstLineIndex=1] the line index displayed for the first line of text.\n\t */\n\t/**\n\t * Creates an editor instance configured with the given options.\n\t * \n\t * @param {orion.editor.EditOptions} options the editor options.\n\t */\n\tfunction edit(options) {\n\t\tvar doc = options.document || document;\n\t\tvar parent = options.parent;\n\t\tif (!parent) { parent = \"editor\"; } //$NON-NLS-0$\n\t\tif (typeof(parent) === \"string\") { //$NON-NLS-0$\n\t\t\tparent = doc.getElementById(parent);\n\t\t}\n\t\tif (!parent) {\n\t\t\tif (options.className) {\n\t\t\t\tvar parents = getParents(doc, options.className);\n\t\t\t\tif (parents) {\n\t\t\t\t\toptions.className = undefined;\n\t\t\t\t\t// Do not focus editors by default when creating multiple editors\n\t\t\t\t\tif (parents.length > 1 && options.noFocus === undefined) { options.noFocus = true; }\n\t\t\t\t\tvar editors = [];\n\t\t\t\t\tfor (var i = parents.length - 1; i >= 0; i--) {\n\t\t\t\t\t\toptions.parent = parents[i];\n\t\t\t\t\t\teditors.push(edit(options));\n\t\t\t\t\t}\n\t\t\t\t\treturn editors;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!parent) { throw new Error(\"no parent\"); } //$NON-NLS-0$\n\t\toptions = mergeOptions(parent, options);\n\t\n\t\tif (typeof options.theme === \"string\") { //$NON-NLS-0$\n\t\t\tvar theme = mTextTheme.TextTheme.getTheme(options.theme);\n\t\t\tvar index = options.theme.lastIndexOf(\"/\"); //$NON-NLS-0$\n\t\t\tvar themeClass = options.theme; \n\t\t\tif (index !== -1) {\n\t\t\t\tthemeClass = themeClass.substring(index + 1);\n\t\t\t}\n\t\t\tvar extension = \".css\"; //$NON-NLS-0$\n\t\t\tif (themeClass.substring(themeClass.length - extension.length) === extension) {\n\t\t\t\tthemeClass = themeClass.substring(0, themeClass.length - extension.length);\n\t\t\t}\n\t\t\ttheme.setThemeClass(themeClass, {href: options.theme});\n\t\t\toptions.theme = theme;\n\t\t}\n\t\tvar textViewFactory = function() {\n\t\t\treturn new mTextView.TextView({\n\t\t\t\tparent: parent,\n\t\t\t\tmodel: new mProjModel.ProjectionTextModel(options.model ? options.model : new mTextModel.TextModel(\"\")),\n\t\t\t\ttabSize: options.tabSize ? options.tabSize : 4,\n\t\t\t\treadonly: options.readonly,\n\t\t\t\tfullSelection: options.fullSelection,\n\t\t\t\ttabMode: options.tabMode,\n\t\t\t\texpandTab: options.expandTab,\n\t\t\t\tsingleMode: options.singleMode,\n\t\t\t\tthemeClass: options.themeClass,\n\t\t\t\ttheme: options.theme,\n\t\t\t\twrapMode: options.wrapMode,\n\t\t\t\twrappable: options.wrappable\n\t\t\t});\n\t\t};\n\n\t\tvar contentAssist, contentAssistFactory;\n\t\tif (!options.readonly) {\n\t\t\tcontentAssistFactory = {\n\t\t\t\tcreateContentAssistMode: function(editor) {\n\t\t\t\t\tcontentAssist = new mContentAssist.ContentAssist(editor.getTextView());\n\t\t\t\t\tvar contentAssistWidget = new mContentAssist.ContentAssistWidget(contentAssist);\n\t\t\t\t\tvar result = new mContentAssist.ContentAssistMode(contentAssist, contentAssistWidget);\n\t\t\t\t\tcontentAssist.setMode(result);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tvar syntaxHighlighter = {\n\t\t\tstyler: null, \n\t\t\t\n\t\t\thighlight: function(contentType, editor) {\n\t\t\t\tif (this.styler && this.styler.destroy) {\n\t\t\t\t\tthis.styler.destroy();\n\t\t\t\t}\n\t\t\t\tthis.styler = null;\n\n\t\t\t\t/* to maintain backwards-compatibility convert previously-supported lang values to types */\n\t\t\t\tif (contentType === \"js\") { //$NON-NLS-0$\n\t\t\t\t\tcontentType = \"application/javascript\"; //$NON-NLS-0$\n\t\t\t\t} else if (contentType === \"css\") { //$NON-NLS-0$\n\t\t\t\t\tcontentType = \"text/css\"; //$NON-NLS-0$\n\t\t\t\t} else if (contentType === \"html\") { //$NON-NLS-0$\n\t\t\t\t\tcontentType = \"text/html\"; //$NON-NLS-0$\n\t\t\t\t} else if (contentType === \"java\") { //$NON-NLS-0$\n\t\t\t\t\tcontentType = \"text/x-java-source\"; //$NON-NLS-0$\n\t\t\t\t}\n\n\t\t\t\tvar textView = editor.getTextView();\n\t\t\t\tvar annotationModel = editor.getAnnotationModel();\n\t\t\t\tif (contentType) {\n\t\t\t\t\tvar folderName = contentType.replace(/[*|:/\".<>?+]/g, '_');\n\t\t\t\t\trequire([\"./stylers/\" + folderName + \"/syntax\"], //$NON-NLS-1$ //$NON-NLS-0$\n\t\t\t\t\t\tfunction(grammar) {\n\t\t\t\t\t\t\tvar stylerAdapter = new mTextStyler.createPatternBasedAdapter(grammar.grammars, grammar.id, contentType);\n\t\t\t\t\t\t\tthis.styler = new mTextStyler.TextStyler(textView, annotationModel, stylerAdapter);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/* @callback */ function(error) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * A grammar file was not found for the specified contentType, so syntax styling will\n\t\t\t\t\t\t\t * not be shown (the editor will still work fine otherwise).  requireJS has already\n\t\t\t\t\t\t\t * written an error message to the console regarding the missing grammar file.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (contentType === \"text/css\") { //$NON-NLS-0$\n\t\t\t\t\teditor.setFoldingRulerVisible(options.showFoldingRuler === undefined || options.showFoldingRuler);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar editor = new mEditor.Editor({\n\t\t\ttextViewFactory: textViewFactory,\n\t\t\tundoStackFactory: new mEditorFeatures.UndoFactory(),\n\t\t\tannotationFactory: new mEditorFeatures.AnnotationFactory(),\n\t\t\tlineNumberRulerFactory: new mEditorFeatures.LineNumberRulerFactory(),\n\t\t\tfoldingRulerFactory: new mEditorFeatures.FoldingRulerFactory(),\n\t\t\ttextDNDFactory: new mEditorFeatures.TextDNDFactory(),\n\t\t\tcontentAssistFactory: contentAssistFactory,\n\t\t\tkeyBindingFactory: new mEditorFeatures.KeyBindingsFactory(), \n\t\t\tstatusReporter: options.statusReporter,\n\t\t\tdomNode: parent\n\t\t});\n\t\teditor.addEventListener(\"TextViewInstalled\", function() { //$NON-NLS-0$\n\t\t\tvar ruler = editor.getLineNumberRuler();\n\t\t\tif (ruler && options.firstLineIndex !== undefined) {\n\t\t\t\truler.setFirstLine(options.firstLineIndex);\n\t\t\t}\n\t\t\tvar sourceCodeActions = editor.getSourceCodeActions();\n\t\t\tif (sourceCodeActions) {\n\t\t\t\tsourceCodeActions.setAutoPairParentheses(options.autoPairParentheses);\n\t\t\t\tsourceCodeActions.setAutoPairBraces(options.autoPairBraces);\n\t\t\t\tsourceCodeActions.setAutoPairSquareBrackets(options.autoPairSquareBrackets);\n\t\t\t\tsourceCodeActions.setAutoPairAngleBrackets(options.autoPairAngleBrackets);\n\t\t\t\tsourceCodeActions.setAutoPairQuotations(options.autoPairQuotations);\n\t\t\t\tsourceCodeActions.setAutoCompleteComments(options.autoCompleteComments);\n\t\t\t\tsourceCodeActions.setSmartIndentation(options.smartIndentation);\n\t\t\t}\n\t\t});\n\t\t\n\t\tvar contents = options.contents;\n\t\tif (contents === undefined) {\n\t\t\tcontents = getTextFromElement(parent); \n\t\t}\n\t\tif (!contents) { contents=\"\"; }\n\t\t\n\t\teditor.installTextView();\n\t\teditor.setLineNumberRulerVisible(options.showLinesRuler === undefined || options.showLinesRuler);\n\t\teditor.setAnnotationRulerVisible(options.showAnnotationRuler === undefined || options.showFoldingRuler);\n\t\teditor.setOverviewRulerVisible(options.showOverviewRuler === undefined || options.showOverviewRuler);\n\t\teditor.setZoomRulerVisible(options.showZoomRuler === undefined || options.showZoomRuler);\n\t\teditor.setFoldingRulerVisible(options.showFoldingRuler === undefined || options.showFoldingRuler);\n\t\teditor.setInput(options.title, null, contents, false, options.noFocus);\n\t\t\n\t\tsyntaxHighlighter.highlight(options.contentType || options.lang, editor);\n\t\t/*\n\t\t * The minimum height of the editor is 50px. Do not compute size if the editor is not\n\t\t * attached to the DOM or it is display=none.\n\t\t */\n\t\tvar window = doc.defaultView || doc.parentWindow;\n\t\tif (!options.noComputeSize && getDisplay(window, doc, parent) !== \"none\" && getHeight(parent) <= 50) { //$NON-NLS-0$\n\t\t\tvar height = editor.getTextView().computeSize().height;\n\t\t\tparent.style.height = height + \"px\"; //$NON-NLS-0$\n\t\t}\n\t\treturn editor;\n\t}\n\n\tvar editorNS = this.orion ? this.orion.editor : undefined;\n\tif (editorNS) {\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tmerge(editorNS, arguments[i]);\t\n\t\t}\n\t\teditorNS.edit = edit;\n\t}\n\t\n\treturn edit;\n});\n\n\n"
  ]
}
